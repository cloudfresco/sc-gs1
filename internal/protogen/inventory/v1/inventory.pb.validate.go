// Code generated by protoc-gen-validate. DO NOT EDIT.
// source: inventory/v1/inventory.proto

package v1

import (
	"bytes"
	"errors"
	"fmt"
	"net"
	"net/mail"
	"net/url"
	"regexp"
	"sort"
	"strings"
	"time"
	"unicode/utf8"

	"google.golang.org/protobuf/types/known/anypb"
)

// ensure the imports are used
var (
	_ = bytes.MinRead
	_ = errors.New("")
	_ = fmt.Print
	_ = utf8.UTFMax
	_ = (*regexp.Regexp)(nil)
	_ = (*strings.Reader)(nil)
	_ = net.IPv4len
	_ = time.Duration(0)
	_ = (*url.URL)(nil)
	_ = (*mail.Address)(nil)
	_ = anypb.Any{}
	_ = sort.Sort
)

// Validate checks the field values on ConsumptionReportItemLocationInformation
// with the rules defined in the proto definition for this message. If any
// rules are violated, the first error encountered is returned, or nil if
// there are no violations.
func (m *ConsumptionReportItemLocationInformation) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on
// ConsumptionReportItemLocationInformation with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in
// ConsumptionReportItemLocationInformationMultiError, or nil if none found.
func (m *ConsumptionReportItemLocationInformation) ValidateAll() error {
	return m.validate(true)
}

func (m *ConsumptionReportItemLocationInformation) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for TotalConsumptionAmount

	// no validation rules for TCACodeListVersion

	// no validation rules for TCACCurrencyCode

	// no validation rules for InventoryLocation

	// no validation rules for ShipTo

	// no validation rules for ConsumptionReportId

	if len(errors) > 0 {
		return ConsumptionReportItemLocationInformationMultiError(errors)
	}

	return nil
}

// ConsumptionReportItemLocationInformationMultiError is an error wrapping
// multiple validation errors returned by
// ConsumptionReportItemLocationInformation.ValidateAll() if the designated
// constraints aren't met.
type ConsumptionReportItemLocationInformationMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ConsumptionReportItemLocationInformationMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ConsumptionReportItemLocationInformationMultiError) AllErrors() []error { return m }

// ConsumptionReportItemLocationInformationValidationError is the validation
// error returned by ConsumptionReportItemLocationInformation.Validate if the
// designated constraints aren't met.
type ConsumptionReportItemLocationInformationValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ConsumptionReportItemLocationInformationValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ConsumptionReportItemLocationInformationValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ConsumptionReportItemLocationInformationValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ConsumptionReportItemLocationInformationValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ConsumptionReportItemLocationInformationValidationError) ErrorName() string {
	return "ConsumptionReportItemLocationInformationValidationError"
}

// Error satisfies the builtin error interface
func (e ConsumptionReportItemLocationInformationValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sConsumptionReportItemLocationInformation.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ConsumptionReportItemLocationInformationValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ConsumptionReportItemLocationInformationValidationError{}

// Validate checks the field values on
// CreateConsumptionReportItemLocationInformationRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CreateConsumptionReportItemLocationInformationRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on
// CreateConsumptionReportItemLocationInformationRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreateConsumptionReportItemLocationInformationRequestMultiError, or nil if
// none found.
func (m *CreateConsumptionReportItemLocationInformationRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateConsumptionReportItemLocationInformationRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for TotalConsumptionAmount

	// no validation rules for TCACodeListVersion

	// no validation rules for TCACCurrencyCode

	// no validation rules for InventoryLocation

	// no validation rules for ShipTo

	// no validation rules for ConsumptionReportId

	// no validation rules for UserId

	// no validation rules for UserEmail

	// no validation rules for RequestId

	if len(errors) > 0 {
		return CreateConsumptionReportItemLocationInformationRequestMultiError(errors)
	}

	return nil
}

// CreateConsumptionReportItemLocationInformationRequestMultiError is an error
// wrapping multiple validation errors returned by
// CreateConsumptionReportItemLocationInformationRequest.ValidateAll() if the
// designated constraints aren't met.
type CreateConsumptionReportItemLocationInformationRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateConsumptionReportItemLocationInformationRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateConsumptionReportItemLocationInformationRequestMultiError) AllErrors() []error {
	return m
}

// CreateConsumptionReportItemLocationInformationRequestValidationError is the
// validation error returned by
// CreateConsumptionReportItemLocationInformationRequest.Validate if the
// designated constraints aren't met.
type CreateConsumptionReportItemLocationInformationRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateConsumptionReportItemLocationInformationRequestValidationError) Field() string {
	return e.field
}

// Reason function returns reason value.
func (e CreateConsumptionReportItemLocationInformationRequestValidationError) Reason() string {
	return e.reason
}

// Cause function returns cause value.
func (e CreateConsumptionReportItemLocationInformationRequestValidationError) Cause() error {
	return e.cause
}

// Key function returns key value.
func (e CreateConsumptionReportItemLocationInformationRequestValidationError) Key() bool {
	return e.key
}

// ErrorName returns error name.
func (e CreateConsumptionReportItemLocationInformationRequestValidationError) ErrorName() string {
	return "CreateConsumptionReportItemLocationInformationRequestValidationError"
}

// Error satisfies the builtin error interface
func (e CreateConsumptionReportItemLocationInformationRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateConsumptionReportItemLocationInformationRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateConsumptionReportItemLocationInformationRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateConsumptionReportItemLocationInformationRequestValidationError{}

// Validate checks the field values on
// CreateConsumptionReportItemLocationInformationResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CreateConsumptionReportItemLocationInformationResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on
// CreateConsumptionReportItemLocationInformationResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreateConsumptionReportItemLocationInformationResponseMultiError, or nil if
// none found.
func (m *CreateConsumptionReportItemLocationInformationResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateConsumptionReportItemLocationInformationResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetConsumptionReportItemLocationInformation()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreateConsumptionReportItemLocationInformationResponseValidationError{
					field:  "ConsumptionReportItemLocationInformation",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreateConsumptionReportItemLocationInformationResponseValidationError{
					field:  "ConsumptionReportItemLocationInformation",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetConsumptionReportItemLocationInformation()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreateConsumptionReportItemLocationInformationResponseValidationError{
				field:  "ConsumptionReportItemLocationInformation",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return CreateConsumptionReportItemLocationInformationResponseMultiError(errors)
	}

	return nil
}

// CreateConsumptionReportItemLocationInformationResponseMultiError is an error
// wrapping multiple validation errors returned by
// CreateConsumptionReportItemLocationInformationResponse.ValidateAll() if the
// designated constraints aren't met.
type CreateConsumptionReportItemLocationInformationResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateConsumptionReportItemLocationInformationResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateConsumptionReportItemLocationInformationResponseMultiError) AllErrors() []error {
	return m
}

// CreateConsumptionReportItemLocationInformationResponseValidationError is the
// validation error returned by
// CreateConsumptionReportItemLocationInformationResponse.Validate if the
// designated constraints aren't met.
type CreateConsumptionReportItemLocationInformationResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateConsumptionReportItemLocationInformationResponseValidationError) Field() string {
	return e.field
}

// Reason function returns reason value.
func (e CreateConsumptionReportItemLocationInformationResponseValidationError) Reason() string {
	return e.reason
}

// Cause function returns cause value.
func (e CreateConsumptionReportItemLocationInformationResponseValidationError) Cause() error {
	return e.cause
}

// Key function returns key value.
func (e CreateConsumptionReportItemLocationInformationResponseValidationError) Key() bool {
	return e.key
}

// ErrorName returns error name.
func (e CreateConsumptionReportItemLocationInformationResponseValidationError) ErrorName() string {
	return "CreateConsumptionReportItemLocationInformationResponseValidationError"
}

// Error satisfies the builtin error interface
func (e CreateConsumptionReportItemLocationInformationResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateConsumptionReportItemLocationInformationResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateConsumptionReportItemLocationInformationResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateConsumptionReportItemLocationInformationResponseValidationError{}

// Validate checks the field values on ConsumptionReportLineItem with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ConsumptionReportLineItem) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ConsumptionReportLineItem with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ConsumptionReportLineItemMultiError, or nil if none found.
func (m *ConsumptionReportLineItem) ValidateAll() error {
	return m.validate(true)
}

func (m *ConsumptionReportLineItem) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetConsumptionReportLineItemD()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ConsumptionReportLineItemValidationError{
					field:  "ConsumptionReportLineItemD",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ConsumptionReportLineItemValidationError{
					field:  "ConsumptionReportLineItemD",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetConsumptionReportLineItemD()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ConsumptionReportLineItemValidationError{
				field:  "ConsumptionReportLineItemD",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetConsumptionReportLineItemT()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ConsumptionReportLineItemValidationError{
					field:  "ConsumptionReportLineItemT",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ConsumptionReportLineItemValidationError{
					field:  "ConsumptionReportLineItemT",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetConsumptionReportLineItemT()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ConsumptionReportLineItemValidationError{
				field:  "ConsumptionReportLineItemT",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetCrUpdUser()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ConsumptionReportLineItemValidationError{
					field:  "CrUpdUser",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ConsumptionReportLineItemValidationError{
					field:  "CrUpdUser",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCrUpdUser()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ConsumptionReportLineItemValidationError{
				field:  "CrUpdUser",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetCrUpdTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ConsumptionReportLineItemValidationError{
					field:  "CrUpdTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ConsumptionReportLineItemValidationError{
					field:  "CrUpdTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCrUpdTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ConsumptionReportLineItemValidationError{
				field:  "CrUpdTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ConsumptionReportLineItemMultiError(errors)
	}

	return nil
}

// ConsumptionReportLineItemMultiError is an error wrapping multiple validation
// errors returned by ConsumptionReportLineItem.ValidateAll() if the
// designated constraints aren't met.
type ConsumptionReportLineItemMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ConsumptionReportLineItemMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ConsumptionReportLineItemMultiError) AllErrors() []error { return m }

// ConsumptionReportLineItemValidationError is the validation error returned by
// ConsumptionReportLineItem.Validate if the designated constraints aren't met.
type ConsumptionReportLineItemValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ConsumptionReportLineItemValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ConsumptionReportLineItemValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ConsumptionReportLineItemValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ConsumptionReportLineItemValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ConsumptionReportLineItemValidationError) ErrorName() string {
	return "ConsumptionReportLineItemValidationError"
}

// Error satisfies the builtin error interface
func (e ConsumptionReportLineItemValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sConsumptionReportLineItem.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ConsumptionReportLineItemValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ConsumptionReportLineItemValidationError{}

// Validate checks the field values on ConsumptionReportLineItemD with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ConsumptionReportLineItemD) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ConsumptionReportLineItemD with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ConsumptionReportLineItemDMultiError, or nil if none found.
func (m *ConsumptionReportLineItemD) ValidateAll() error {
	return m.validate(true)
}

func (m *ConsumptionReportLineItemD) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for Uuid4

	// no validation rules for IdS

	// no validation rules for ConsumedQuantity

	// no validation rules for CQMeasurementUnitCode

	// no validation rules for CQCodeListVersion

	// no validation rules for LineItemNumber

	// no validation rules for NetConsumptionAmount

	// no validation rules for NetConsumptionAmountCurrency

	// no validation rules for NetConsumptionAmountValue

	// no validation rules for NCACCodeListVersion

	// no validation rules for NCACCurrencyCode

	// no validation rules for NetPrice

	// no validation rules for NetPriceCurrency

	// no validation rules for NetPriceValue

	// no validation rules for NPCodeListVersion

	// no validation rules for NPCurrencyCode

	// no validation rules for ParentLineItemNumber

	// no validation rules for PlanBucketSizeCode

	// no validation rules for PurchaseConditions

	// no validation rules for ConsumptionReportId

	if len(errors) > 0 {
		return ConsumptionReportLineItemDMultiError(errors)
	}

	return nil
}

// ConsumptionReportLineItemDMultiError is an error wrapping multiple
// validation errors returned by ConsumptionReportLineItemD.ValidateAll() if
// the designated constraints aren't met.
type ConsumptionReportLineItemDMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ConsumptionReportLineItemDMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ConsumptionReportLineItemDMultiError) AllErrors() []error { return m }

// ConsumptionReportLineItemDValidationError is the validation error returned
// by ConsumptionReportLineItemD.Validate if the designated constraints aren't met.
type ConsumptionReportLineItemDValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ConsumptionReportLineItemDValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ConsumptionReportLineItemDValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ConsumptionReportLineItemDValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ConsumptionReportLineItemDValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ConsumptionReportLineItemDValidationError) ErrorName() string {
	return "ConsumptionReportLineItemDValidationError"
}

// Error satisfies the builtin error interface
func (e ConsumptionReportLineItemDValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sConsumptionReportLineItemD.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ConsumptionReportLineItemDValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ConsumptionReportLineItemDValidationError{}

// Validate checks the field values on ConsumptionReportLineItemT with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ConsumptionReportLineItemT) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ConsumptionReportLineItemT with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ConsumptionReportLineItemTMultiError, or nil if none found.
func (m *ConsumptionReportLineItemT) ValidateAll() error {
	return m.validate(true)
}

func (m *ConsumptionReportLineItemT) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetConsumptionPeriodBegin()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ConsumptionReportLineItemTValidationError{
					field:  "ConsumptionPeriodBegin",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ConsumptionReportLineItemTValidationError{
					field:  "ConsumptionPeriodBegin",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetConsumptionPeriodBegin()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ConsumptionReportLineItemTValidationError{
				field:  "ConsumptionPeriodBegin",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetConsumptionPeriodEnd()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ConsumptionReportLineItemTValidationError{
					field:  "ConsumptionPeriodEnd",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ConsumptionReportLineItemTValidationError{
					field:  "ConsumptionPeriodEnd",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetConsumptionPeriodEnd()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ConsumptionReportLineItemTValidationError{
				field:  "ConsumptionPeriodEnd",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ConsumptionReportLineItemTMultiError(errors)
	}

	return nil
}

// ConsumptionReportLineItemTMultiError is an error wrapping multiple
// validation errors returned by ConsumptionReportLineItemT.ValidateAll() if
// the designated constraints aren't met.
type ConsumptionReportLineItemTMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ConsumptionReportLineItemTMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ConsumptionReportLineItemTMultiError) AllErrors() []error { return m }

// ConsumptionReportLineItemTValidationError is the validation error returned
// by ConsumptionReportLineItemT.Validate if the designated constraints aren't met.
type ConsumptionReportLineItemTValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ConsumptionReportLineItemTValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ConsumptionReportLineItemTValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ConsumptionReportLineItemTValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ConsumptionReportLineItemTValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ConsumptionReportLineItemTValidationError) ErrorName() string {
	return "ConsumptionReportLineItemTValidationError"
}

// Error satisfies the builtin error interface
func (e ConsumptionReportLineItemTValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sConsumptionReportLineItemT.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ConsumptionReportLineItemTValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ConsumptionReportLineItemTValidationError{}

// Validate checks the field values on CreateConsumptionReportLineItemRequest
// with the rules defined in the proto definition for this message. If any
// rules are violated, the first error encountered is returned, or nil if
// there are no violations.
func (m *CreateConsumptionReportLineItemRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on
// CreateConsumptionReportLineItemRequest with the rules defined in the proto
// definition for this message. If any rules are violated, the result is a
// list of violation errors wrapped in
// CreateConsumptionReportLineItemRequestMultiError, or nil if none found.
func (m *CreateConsumptionReportLineItemRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateConsumptionReportLineItemRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ConsumedQuantity

	// no validation rules for CQMeasurementUnitCode

	// no validation rules for CQCodeListVersion

	// no validation rules for LineItemNumber

	// no validation rules for NetConsumptionAmount

	// no validation rules for NetConsumptionAmountCurrency

	// no validation rules for NCACCodeListVersion

	// no validation rules for NCACCurrencyCode

	// no validation rules for NetPrice

	// no validation rules for NetPriceCurrency

	// no validation rules for NPCodeListVersion

	// no validation rules for NPCurrencyCode

	// no validation rules for ParentLineItemNumber

	// no validation rules for PlanBucketSizeCode

	// no validation rules for ConsumptionPeriodBegin

	// no validation rules for ConsumptionPeriodEnd

	// no validation rules for PurchaseConditions

	// no validation rules for ConsumptionReportId

	// no validation rules for UserId

	// no validation rules for UserEmail

	// no validation rules for RequestId

	if len(errors) > 0 {
		return CreateConsumptionReportLineItemRequestMultiError(errors)
	}

	return nil
}

// CreateConsumptionReportLineItemRequestMultiError is an error wrapping
// multiple validation errors returned by
// CreateConsumptionReportLineItemRequest.ValidateAll() if the designated
// constraints aren't met.
type CreateConsumptionReportLineItemRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateConsumptionReportLineItemRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateConsumptionReportLineItemRequestMultiError) AllErrors() []error { return m }

// CreateConsumptionReportLineItemRequestValidationError is the validation
// error returned by CreateConsumptionReportLineItemRequest.Validate if the
// designated constraints aren't met.
type CreateConsumptionReportLineItemRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateConsumptionReportLineItemRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateConsumptionReportLineItemRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateConsumptionReportLineItemRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateConsumptionReportLineItemRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateConsumptionReportLineItemRequestValidationError) ErrorName() string {
	return "CreateConsumptionReportLineItemRequestValidationError"
}

// Error satisfies the builtin error interface
func (e CreateConsumptionReportLineItemRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateConsumptionReportLineItemRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateConsumptionReportLineItemRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateConsumptionReportLineItemRequestValidationError{}

// Validate checks the field values on CreateConsumptionReportLineItemResponse
// with the rules defined in the proto definition for this message. If any
// rules are violated, the first error encountered is returned, or nil if
// there are no violations.
func (m *CreateConsumptionReportLineItemResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on
// CreateConsumptionReportLineItemResponse with the rules defined in the proto
// definition for this message. If any rules are violated, the result is a
// list of violation errors wrapped in
// CreateConsumptionReportLineItemResponseMultiError, or nil if none found.
func (m *CreateConsumptionReportLineItemResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateConsumptionReportLineItemResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetConsumptionReportLineItem()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreateConsumptionReportLineItemResponseValidationError{
					field:  "ConsumptionReportLineItem",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreateConsumptionReportLineItemResponseValidationError{
					field:  "ConsumptionReportLineItem",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetConsumptionReportLineItem()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreateConsumptionReportLineItemResponseValidationError{
				field:  "ConsumptionReportLineItem",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return CreateConsumptionReportLineItemResponseMultiError(errors)
	}

	return nil
}

// CreateConsumptionReportLineItemResponseMultiError is an error wrapping
// multiple validation errors returned by
// CreateConsumptionReportLineItemResponse.ValidateAll() if the designated
// constraints aren't met.
type CreateConsumptionReportLineItemResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateConsumptionReportLineItemResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateConsumptionReportLineItemResponseMultiError) AllErrors() []error { return m }

// CreateConsumptionReportLineItemResponseValidationError is the validation
// error returned by CreateConsumptionReportLineItemResponse.Validate if the
// designated constraints aren't met.
type CreateConsumptionReportLineItemResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateConsumptionReportLineItemResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateConsumptionReportLineItemResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateConsumptionReportLineItemResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateConsumptionReportLineItemResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateConsumptionReportLineItemResponseValidationError) ErrorName() string {
	return "CreateConsumptionReportLineItemResponseValidationError"
}

// Error satisfies the builtin error interface
func (e CreateConsumptionReportLineItemResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateConsumptionReportLineItemResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateConsumptionReportLineItemResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateConsumptionReportLineItemResponseValidationError{}

// Validate checks the field values on ConsumptionReport with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *ConsumptionReport) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ConsumptionReport with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ConsumptionReportMultiError, or nil if none found.
func (m *ConsumptionReport) ValidateAll() error {
	return m.validate(true)
}

func (m *ConsumptionReport) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetConsumptionReportD()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ConsumptionReportValidationError{
					field:  "ConsumptionReportD",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ConsumptionReportValidationError{
					field:  "ConsumptionReportD",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetConsumptionReportD()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ConsumptionReportValidationError{
				field:  "ConsumptionReportD",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetCrUpdUser()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ConsumptionReportValidationError{
					field:  "CrUpdUser",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ConsumptionReportValidationError{
					field:  "CrUpdUser",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCrUpdUser()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ConsumptionReportValidationError{
				field:  "CrUpdUser",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetCrUpdTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ConsumptionReportValidationError{
					field:  "CrUpdTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ConsumptionReportValidationError{
					field:  "CrUpdTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCrUpdTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ConsumptionReportValidationError{
				field:  "CrUpdTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ConsumptionReportMultiError(errors)
	}

	return nil
}

// ConsumptionReportMultiError is an error wrapping multiple validation errors
// returned by ConsumptionReport.ValidateAll() if the designated constraints
// aren't met.
type ConsumptionReportMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ConsumptionReportMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ConsumptionReportMultiError) AllErrors() []error { return m }

// ConsumptionReportValidationError is the validation error returned by
// ConsumptionReport.Validate if the designated constraints aren't met.
type ConsumptionReportValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ConsumptionReportValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ConsumptionReportValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ConsumptionReportValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ConsumptionReportValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ConsumptionReportValidationError) ErrorName() string {
	return "ConsumptionReportValidationError"
}

// Error satisfies the builtin error interface
func (e ConsumptionReportValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sConsumptionReport.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ConsumptionReportValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ConsumptionReportValidationError{}

// Validate checks the field values on ConsumptionReportD with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ConsumptionReportD) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ConsumptionReportD with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ConsumptionReportDMultiError, or nil if none found.
func (m *ConsumptionReportD) ValidateAll() error {
	return m.validate(true)
}

func (m *ConsumptionReportD) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for Uuid4

	// no validation rules for IdS

	// no validation rules for Buyer

	// no validation rules for ConsumptionReportIdentification

	// no validation rules for Seller

	if len(errors) > 0 {
		return ConsumptionReportDMultiError(errors)
	}

	return nil
}

// ConsumptionReportDMultiError is an error wrapping multiple validation errors
// returned by ConsumptionReportD.ValidateAll() if the designated constraints
// aren't met.
type ConsumptionReportDMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ConsumptionReportDMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ConsumptionReportDMultiError) AllErrors() []error { return m }

// ConsumptionReportDValidationError is the validation error returned by
// ConsumptionReportD.Validate if the designated constraints aren't met.
type ConsumptionReportDValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ConsumptionReportDValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ConsumptionReportDValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ConsumptionReportDValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ConsumptionReportDValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ConsumptionReportDValidationError) ErrorName() string {
	return "ConsumptionReportDValidationError"
}

// Error satisfies the builtin error interface
func (e ConsumptionReportDValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sConsumptionReportD.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ConsumptionReportDValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ConsumptionReportDValidationError{}

// Validate checks the field values on CreateConsumptionReportRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CreateConsumptionReportRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateConsumptionReportRequest with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// CreateConsumptionReportRequestMultiError, or nil if none found.
func (m *CreateConsumptionReportRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateConsumptionReportRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Buyer

	// no validation rules for ConsumptionReportIdentification

	// no validation rules for Seller

	// no validation rules for UserId

	// no validation rules for UserEmail

	// no validation rules for RequestId

	if len(errors) > 0 {
		return CreateConsumptionReportRequestMultiError(errors)
	}

	return nil
}

// CreateConsumptionReportRequestMultiError is an error wrapping multiple
// validation errors returned by CreateConsumptionReportRequest.ValidateAll()
// if the designated constraints aren't met.
type CreateConsumptionReportRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateConsumptionReportRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateConsumptionReportRequestMultiError) AllErrors() []error { return m }

// CreateConsumptionReportRequestValidationError is the validation error
// returned by CreateConsumptionReportRequest.Validate if the designated
// constraints aren't met.
type CreateConsumptionReportRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateConsumptionReportRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateConsumptionReportRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateConsumptionReportRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateConsumptionReportRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateConsumptionReportRequestValidationError) ErrorName() string {
	return "CreateConsumptionReportRequestValidationError"
}

// Error satisfies the builtin error interface
func (e CreateConsumptionReportRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateConsumptionReportRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateConsumptionReportRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateConsumptionReportRequestValidationError{}

// Validate checks the field values on CreateConsumptionReportResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CreateConsumptionReportResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateConsumptionReportResponse with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// CreateConsumptionReportResponseMultiError, or nil if none found.
func (m *CreateConsumptionReportResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateConsumptionReportResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetConsumptionReport()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreateConsumptionReportResponseValidationError{
					field:  "ConsumptionReport",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreateConsumptionReportResponseValidationError{
					field:  "ConsumptionReport",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetConsumptionReport()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreateConsumptionReportResponseValidationError{
				field:  "ConsumptionReport",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return CreateConsumptionReportResponseMultiError(errors)
	}

	return nil
}

// CreateConsumptionReportResponseMultiError is an error wrapping multiple
// validation errors returned by CreateConsumptionReportResponse.ValidateAll()
// if the designated constraints aren't met.
type CreateConsumptionReportResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateConsumptionReportResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateConsumptionReportResponseMultiError) AllErrors() []error { return m }

// CreateConsumptionReportResponseValidationError is the validation error
// returned by CreateConsumptionReportResponse.Validate if the designated
// constraints aren't met.
type CreateConsumptionReportResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateConsumptionReportResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateConsumptionReportResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateConsumptionReportResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateConsumptionReportResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateConsumptionReportResponseValidationError) ErrorName() string {
	return "CreateConsumptionReportResponseValidationError"
}

// Error satisfies the builtin error interface
func (e CreateConsumptionReportResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateConsumptionReportResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateConsumptionReportResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateConsumptionReportResponseValidationError{}

// Validate checks the field values on InventoryActivityLineItem with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *InventoryActivityLineItem) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on InventoryActivityLineItem with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// InventoryActivityLineItemMultiError, or nil if none found.
func (m *InventoryActivityLineItem) ValidateAll() error {
	return m.validate(true)
}

func (m *InventoryActivityLineItem) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetInventoryActivityLineItemD()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, InventoryActivityLineItemValidationError{
					field:  "InventoryActivityLineItemD",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, InventoryActivityLineItemValidationError{
					field:  "InventoryActivityLineItemD",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetInventoryActivityLineItemD()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return InventoryActivityLineItemValidationError{
				field:  "InventoryActivityLineItemD",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetInventoryActivityLineItemT()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, InventoryActivityLineItemValidationError{
					field:  "InventoryActivityLineItemT",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, InventoryActivityLineItemValidationError{
					field:  "InventoryActivityLineItemT",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetInventoryActivityLineItemT()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return InventoryActivityLineItemValidationError{
				field:  "InventoryActivityLineItemT",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return InventoryActivityLineItemMultiError(errors)
	}

	return nil
}

// InventoryActivityLineItemMultiError is an error wrapping multiple validation
// errors returned by InventoryActivityLineItem.ValidateAll() if the
// designated constraints aren't met.
type InventoryActivityLineItemMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m InventoryActivityLineItemMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m InventoryActivityLineItemMultiError) AllErrors() []error { return m }

// InventoryActivityLineItemValidationError is the validation error returned by
// InventoryActivityLineItem.Validate if the designated constraints aren't met.
type InventoryActivityLineItemValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e InventoryActivityLineItemValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e InventoryActivityLineItemValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e InventoryActivityLineItemValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e InventoryActivityLineItemValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e InventoryActivityLineItemValidationError) ErrorName() string {
	return "InventoryActivityLineItemValidationError"
}

// Error satisfies the builtin error interface
func (e InventoryActivityLineItemValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sInventoryActivityLineItem.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = InventoryActivityLineItemValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = InventoryActivityLineItemValidationError{}

// Validate checks the field values on InventoryActivityLineItemD with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *InventoryActivityLineItemD) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on InventoryActivityLineItemD with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// InventoryActivityLineItemDMultiError, or nil if none found.
func (m *InventoryActivityLineItemD) ValidateAll() error {
	return m.validate(true)
}

func (m *InventoryActivityLineItemD) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for LineItemNumber

	// no validation rules for ParentLineItemNumber

	// no validation rules for InventoryItemLocationInformationId

	// no validation rules for InventoryReportId

	if len(errors) > 0 {
		return InventoryActivityLineItemDMultiError(errors)
	}

	return nil
}

// InventoryActivityLineItemDMultiError is an error wrapping multiple
// validation errors returned by InventoryActivityLineItemD.ValidateAll() if
// the designated constraints aren't met.
type InventoryActivityLineItemDMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m InventoryActivityLineItemDMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m InventoryActivityLineItemDMultiError) AllErrors() []error { return m }

// InventoryActivityLineItemDValidationError is the validation error returned
// by InventoryActivityLineItemD.Validate if the designated constraints aren't met.
type InventoryActivityLineItemDValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e InventoryActivityLineItemDValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e InventoryActivityLineItemDValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e InventoryActivityLineItemDValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e InventoryActivityLineItemDValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e InventoryActivityLineItemDValidationError) ErrorName() string {
	return "InventoryActivityLineItemDValidationError"
}

// Error satisfies the builtin error interface
func (e InventoryActivityLineItemDValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sInventoryActivityLineItemD.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = InventoryActivityLineItemDValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = InventoryActivityLineItemDValidationError{}

// Validate checks the field values on InventoryActivityLineItemT with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *InventoryActivityLineItemT) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on InventoryActivityLineItemT with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// InventoryActivityLineItemTMultiError, or nil if none found.
func (m *InventoryActivityLineItemT) ValidateAll() error {
	return m.validate(true)
}

func (m *InventoryActivityLineItemT) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetReportingPeriodBegin()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, InventoryActivityLineItemTValidationError{
					field:  "ReportingPeriodBegin",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, InventoryActivityLineItemTValidationError{
					field:  "ReportingPeriodBegin",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetReportingPeriodBegin()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return InventoryActivityLineItemTValidationError{
				field:  "ReportingPeriodBegin",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetReportingPeriodEnd()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, InventoryActivityLineItemTValidationError{
					field:  "ReportingPeriodEnd",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, InventoryActivityLineItemTValidationError{
					field:  "ReportingPeriodEnd",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetReportingPeriodEnd()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return InventoryActivityLineItemTValidationError{
				field:  "ReportingPeriodEnd",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return InventoryActivityLineItemTMultiError(errors)
	}

	return nil
}

// InventoryActivityLineItemTMultiError is an error wrapping multiple
// validation errors returned by InventoryActivityLineItemT.ValidateAll() if
// the designated constraints aren't met.
type InventoryActivityLineItemTMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m InventoryActivityLineItemTMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m InventoryActivityLineItemTMultiError) AllErrors() []error { return m }

// InventoryActivityLineItemTValidationError is the validation error returned
// by InventoryActivityLineItemT.Validate if the designated constraints aren't met.
type InventoryActivityLineItemTValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e InventoryActivityLineItemTValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e InventoryActivityLineItemTValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e InventoryActivityLineItemTValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e InventoryActivityLineItemTValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e InventoryActivityLineItemTValidationError) ErrorName() string {
	return "InventoryActivityLineItemTValidationError"
}

// Error satisfies the builtin error interface
func (e InventoryActivityLineItemTValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sInventoryActivityLineItemT.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = InventoryActivityLineItemTValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = InventoryActivityLineItemTValidationError{}

// Validate checks the field values on CreateInventoryActivityLineItemRequest
// with the rules defined in the proto definition for this message. If any
// rules are violated, the first error encountered is returned, or nil if
// there are no violations.
func (m *CreateInventoryActivityLineItemRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on
// CreateInventoryActivityLineItemRequest with the rules defined in the proto
// definition for this message. If any rules are violated, the result is a
// list of violation errors wrapped in
// CreateInventoryActivityLineItemRequestMultiError, or nil if none found.
func (m *CreateInventoryActivityLineItemRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateInventoryActivityLineItemRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for LineItemNumber

	// no validation rules for ParentLineItemNumber

	// no validation rules for ReportingPeriodBegin

	// no validation rules for ReportingPeriodEnd

	// no validation rules for InventoryItemLocationInformationId

	// no validation rules for InventoryReportId

	// no validation rules for UserId

	// no validation rules for UserEmail

	// no validation rules for RequestId

	if len(errors) > 0 {
		return CreateInventoryActivityLineItemRequestMultiError(errors)
	}

	return nil
}

// CreateInventoryActivityLineItemRequestMultiError is an error wrapping
// multiple validation errors returned by
// CreateInventoryActivityLineItemRequest.ValidateAll() if the designated
// constraints aren't met.
type CreateInventoryActivityLineItemRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateInventoryActivityLineItemRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateInventoryActivityLineItemRequestMultiError) AllErrors() []error { return m }

// CreateInventoryActivityLineItemRequestValidationError is the validation
// error returned by CreateInventoryActivityLineItemRequest.Validate if the
// designated constraints aren't met.
type CreateInventoryActivityLineItemRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateInventoryActivityLineItemRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateInventoryActivityLineItemRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateInventoryActivityLineItemRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateInventoryActivityLineItemRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateInventoryActivityLineItemRequestValidationError) ErrorName() string {
	return "CreateInventoryActivityLineItemRequestValidationError"
}

// Error satisfies the builtin error interface
func (e CreateInventoryActivityLineItemRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateInventoryActivityLineItemRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateInventoryActivityLineItemRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateInventoryActivityLineItemRequestValidationError{}

// Validate checks the field values on CreateInventoryActivityLineItemResponse
// with the rules defined in the proto definition for this message. If any
// rules are violated, the first error encountered is returned, or nil if
// there are no violations.
func (m *CreateInventoryActivityLineItemResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on
// CreateInventoryActivityLineItemResponse with the rules defined in the proto
// definition for this message. If any rules are violated, the result is a
// list of violation errors wrapped in
// CreateInventoryActivityLineItemResponseMultiError, or nil if none found.
func (m *CreateInventoryActivityLineItemResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateInventoryActivityLineItemResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetInventoryActivityLineItem()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreateInventoryActivityLineItemResponseValidationError{
					field:  "InventoryActivityLineItem",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreateInventoryActivityLineItemResponseValidationError{
					field:  "InventoryActivityLineItem",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetInventoryActivityLineItem()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreateInventoryActivityLineItemResponseValidationError{
				field:  "InventoryActivityLineItem",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return CreateInventoryActivityLineItemResponseMultiError(errors)
	}

	return nil
}

// CreateInventoryActivityLineItemResponseMultiError is an error wrapping
// multiple validation errors returned by
// CreateInventoryActivityLineItemResponse.ValidateAll() if the designated
// constraints aren't met.
type CreateInventoryActivityLineItemResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateInventoryActivityLineItemResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateInventoryActivityLineItemResponseMultiError) AllErrors() []error { return m }

// CreateInventoryActivityLineItemResponseValidationError is the validation
// error returned by CreateInventoryActivityLineItemResponse.Validate if the
// designated constraints aren't met.
type CreateInventoryActivityLineItemResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateInventoryActivityLineItemResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateInventoryActivityLineItemResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateInventoryActivityLineItemResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateInventoryActivityLineItemResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateInventoryActivityLineItemResponseValidationError) ErrorName() string {
	return "CreateInventoryActivityLineItemResponseValidationError"
}

// Error satisfies the builtin error interface
func (e CreateInventoryActivityLineItemResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateInventoryActivityLineItemResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateInventoryActivityLineItemResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateInventoryActivityLineItemResponseValidationError{}

// Validate checks the field values on InventoryActivityQuantitySpecification
// with the rules defined in the proto definition for this message. If any
// rules are violated, the first error encountered is returned, or nil if
// there are no violations.
func (m *InventoryActivityQuantitySpecification) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on
// InventoryActivityQuantitySpecification with the rules defined in the proto
// definition for this message. If any rules are violated, the result is a
// list of violation errors wrapped in
// InventoryActivityQuantitySpecificationMultiError, or nil if none found.
func (m *InventoryActivityQuantitySpecification) ValidateAll() error {
	return m.validate(true)
}

func (m *InventoryActivityQuantitySpecification) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for InventoryActivityTypeCode

	// no validation rules for InventoryMovementTypeCode

	// no validation rules for QuantityOfUnits

	// no validation rules for QOUMeasurementUnitCode

	// no validation rules for QOUCodeListVersion

	// no validation rules for InventoryStatusLineItemId

	// no validation rules for InventoryActivityLineItemId

	// no validation rules for InventoryReportId

	if len(errors) > 0 {
		return InventoryActivityQuantitySpecificationMultiError(errors)
	}

	return nil
}

// InventoryActivityQuantitySpecificationMultiError is an error wrapping
// multiple validation errors returned by
// InventoryActivityQuantitySpecification.ValidateAll() if the designated
// constraints aren't met.
type InventoryActivityQuantitySpecificationMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m InventoryActivityQuantitySpecificationMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m InventoryActivityQuantitySpecificationMultiError) AllErrors() []error { return m }

// InventoryActivityQuantitySpecificationValidationError is the validation
// error returned by InventoryActivityQuantitySpecification.Validate if the
// designated constraints aren't met.
type InventoryActivityQuantitySpecificationValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e InventoryActivityQuantitySpecificationValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e InventoryActivityQuantitySpecificationValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e InventoryActivityQuantitySpecificationValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e InventoryActivityQuantitySpecificationValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e InventoryActivityQuantitySpecificationValidationError) ErrorName() string {
	return "InventoryActivityQuantitySpecificationValidationError"
}

// Error satisfies the builtin error interface
func (e InventoryActivityQuantitySpecificationValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sInventoryActivityQuantitySpecification.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = InventoryActivityQuantitySpecificationValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = InventoryActivityQuantitySpecificationValidationError{}

// Validate checks the field values on
// CreateInventoryActivityQuantitySpecificationRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *CreateInventoryActivityQuantitySpecificationRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on
// CreateInventoryActivityQuantitySpecificationRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in
// CreateInventoryActivityQuantitySpecificationRequestMultiError, or nil if
// none found.
func (m *CreateInventoryActivityQuantitySpecificationRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateInventoryActivityQuantitySpecificationRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for InventoryActivityTypeCode

	// no validation rules for InventoryMovementTypeCode

	// no validation rules for QuantityOfUnits

	// no validation rules for QOUMeasurementUnitCode

	// no validation rules for QOUCodeListVersion

	// no validation rules for InventoryStatusLineItemId

	// no validation rules for InventoryActivityLineItemId

	// no validation rules for InventoryReportId

	// no validation rules for UserId

	// no validation rules for UserEmail

	// no validation rules for RequestId

	if len(errors) > 0 {
		return CreateInventoryActivityQuantitySpecificationRequestMultiError(errors)
	}

	return nil
}

// CreateInventoryActivityQuantitySpecificationRequestMultiError is an error
// wrapping multiple validation errors returned by
// CreateInventoryActivityQuantitySpecificationRequest.ValidateAll() if the
// designated constraints aren't met.
type CreateInventoryActivityQuantitySpecificationRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateInventoryActivityQuantitySpecificationRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateInventoryActivityQuantitySpecificationRequestMultiError) AllErrors() []error { return m }

// CreateInventoryActivityQuantitySpecificationRequestValidationError is the
// validation error returned by
// CreateInventoryActivityQuantitySpecificationRequest.Validate if the
// designated constraints aren't met.
type CreateInventoryActivityQuantitySpecificationRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateInventoryActivityQuantitySpecificationRequestValidationError) Field() string {
	return e.field
}

// Reason function returns reason value.
func (e CreateInventoryActivityQuantitySpecificationRequestValidationError) Reason() string {
	return e.reason
}

// Cause function returns cause value.
func (e CreateInventoryActivityQuantitySpecificationRequestValidationError) Cause() error {
	return e.cause
}

// Key function returns key value.
func (e CreateInventoryActivityQuantitySpecificationRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateInventoryActivityQuantitySpecificationRequestValidationError) ErrorName() string {
	return "CreateInventoryActivityQuantitySpecificationRequestValidationError"
}

// Error satisfies the builtin error interface
func (e CreateInventoryActivityQuantitySpecificationRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateInventoryActivityQuantitySpecificationRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateInventoryActivityQuantitySpecificationRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateInventoryActivityQuantitySpecificationRequestValidationError{}

// Validate checks the field values on
// CreateInventoryActivityQuantitySpecificationResponse with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *CreateInventoryActivityQuantitySpecificationResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on
// CreateInventoryActivityQuantitySpecificationResponse with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in
// CreateInventoryActivityQuantitySpecificationResponseMultiError, or nil if
// none found.
func (m *CreateInventoryActivityQuantitySpecificationResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateInventoryActivityQuantitySpecificationResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetInventoryActivityQuantitySpecification()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreateInventoryActivityQuantitySpecificationResponseValidationError{
					field:  "InventoryActivityQuantitySpecification",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreateInventoryActivityQuantitySpecificationResponseValidationError{
					field:  "InventoryActivityQuantitySpecification",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetInventoryActivityQuantitySpecification()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreateInventoryActivityQuantitySpecificationResponseValidationError{
				field:  "InventoryActivityQuantitySpecification",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return CreateInventoryActivityQuantitySpecificationResponseMultiError(errors)
	}

	return nil
}

// CreateInventoryActivityQuantitySpecificationResponseMultiError is an error
// wrapping multiple validation errors returned by
// CreateInventoryActivityQuantitySpecificationResponse.ValidateAll() if the
// designated constraints aren't met.
type CreateInventoryActivityQuantitySpecificationResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateInventoryActivityQuantitySpecificationResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateInventoryActivityQuantitySpecificationResponseMultiError) AllErrors() []error { return m }

// CreateInventoryActivityQuantitySpecificationResponseValidationError is the
// validation error returned by
// CreateInventoryActivityQuantitySpecificationResponse.Validate if the
// designated constraints aren't met.
type CreateInventoryActivityQuantitySpecificationResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateInventoryActivityQuantitySpecificationResponseValidationError) Field() string {
	return e.field
}

// Reason function returns reason value.
func (e CreateInventoryActivityQuantitySpecificationResponseValidationError) Reason() string {
	return e.reason
}

// Cause function returns cause value.
func (e CreateInventoryActivityQuantitySpecificationResponseValidationError) Cause() error {
	return e.cause
}

// Key function returns key value.
func (e CreateInventoryActivityQuantitySpecificationResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateInventoryActivityQuantitySpecificationResponseValidationError) ErrorName() string {
	return "CreateInventoryActivityQuantitySpecificationResponseValidationError"
}

// Error satisfies the builtin error interface
func (e CreateInventoryActivityQuantitySpecificationResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateInventoryActivityQuantitySpecificationResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateInventoryActivityQuantitySpecificationResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateInventoryActivityQuantitySpecificationResponseValidationError{}

// Validate checks the field values on InventoryItemLocationInformation with
// the rules defined in the proto definition for this message. If any rules
// are violated, the first error encountered is returned, or nil if there are
// no violations.
func (m *InventoryItemLocationInformation) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on InventoryItemLocationInformation with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// InventoryItemLocationInformationMultiError, or nil if none found.
func (m *InventoryItemLocationInformation) ValidateAll() error {
	return m.validate(true)
}

func (m *InventoryItemLocationInformation) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for InventoryLocationId

	// no validation rules for InventoryReportId

	if len(errors) > 0 {
		return InventoryItemLocationInformationMultiError(errors)
	}

	return nil
}

// InventoryItemLocationInformationMultiError is an error wrapping multiple
// validation errors returned by
// InventoryItemLocationInformation.ValidateAll() if the designated
// constraints aren't met.
type InventoryItemLocationInformationMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m InventoryItemLocationInformationMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m InventoryItemLocationInformationMultiError) AllErrors() []error { return m }

// InventoryItemLocationInformationValidationError is the validation error
// returned by InventoryItemLocationInformation.Validate if the designated
// constraints aren't met.
type InventoryItemLocationInformationValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e InventoryItemLocationInformationValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e InventoryItemLocationInformationValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e InventoryItemLocationInformationValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e InventoryItemLocationInformationValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e InventoryItemLocationInformationValidationError) ErrorName() string {
	return "InventoryItemLocationInformationValidationError"
}

// Error satisfies the builtin error interface
func (e InventoryItemLocationInformationValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sInventoryItemLocationInformation.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = InventoryItemLocationInformationValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = InventoryItemLocationInformationValidationError{}

// Validate checks the field values on
// CreateInventoryItemLocationInformationRequest with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *CreateInventoryItemLocationInformationRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on
// CreateInventoryItemLocationInformationRequest with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in
// CreateInventoryItemLocationInformationRequestMultiError, or nil if none found.
func (m *CreateInventoryItemLocationInformationRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateInventoryItemLocationInformationRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for InventoryLocationId

	// no validation rules for InventoryReportId

	// no validation rules for UserId

	// no validation rules for UserEmail

	// no validation rules for RequestId

	if len(errors) > 0 {
		return CreateInventoryItemLocationInformationRequestMultiError(errors)
	}

	return nil
}

// CreateInventoryItemLocationInformationRequestMultiError is an error wrapping
// multiple validation errors returned by
// CreateInventoryItemLocationInformationRequest.ValidateAll() if the
// designated constraints aren't met.
type CreateInventoryItemLocationInformationRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateInventoryItemLocationInformationRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateInventoryItemLocationInformationRequestMultiError) AllErrors() []error { return m }

// CreateInventoryItemLocationInformationRequestValidationError is the
// validation error returned by
// CreateInventoryItemLocationInformationRequest.Validate if the designated
// constraints aren't met.
type CreateInventoryItemLocationInformationRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateInventoryItemLocationInformationRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateInventoryItemLocationInformationRequestValidationError) Reason() string {
	return e.reason
}

// Cause function returns cause value.
func (e CreateInventoryItemLocationInformationRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateInventoryItemLocationInformationRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateInventoryItemLocationInformationRequestValidationError) ErrorName() string {
	return "CreateInventoryItemLocationInformationRequestValidationError"
}

// Error satisfies the builtin error interface
func (e CreateInventoryItemLocationInformationRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateInventoryItemLocationInformationRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateInventoryItemLocationInformationRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateInventoryItemLocationInformationRequestValidationError{}

// Validate checks the field values on
// CreateInventoryItemLocationInformationResponse with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *CreateInventoryItemLocationInformationResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on
// CreateInventoryItemLocationInformationResponse with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in
// CreateInventoryItemLocationInformationResponseMultiError, or nil if none found.
func (m *CreateInventoryItemLocationInformationResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateInventoryItemLocationInformationResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetInventoryItemLocationInformation()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreateInventoryItemLocationInformationResponseValidationError{
					field:  "InventoryItemLocationInformation",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreateInventoryItemLocationInformationResponseValidationError{
					field:  "InventoryItemLocationInformation",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetInventoryItemLocationInformation()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreateInventoryItemLocationInformationResponseValidationError{
				field:  "InventoryItemLocationInformation",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return CreateInventoryItemLocationInformationResponseMultiError(errors)
	}

	return nil
}

// CreateInventoryItemLocationInformationResponseMultiError is an error
// wrapping multiple validation errors returned by
// CreateInventoryItemLocationInformationResponse.ValidateAll() if the
// designated constraints aren't met.
type CreateInventoryItemLocationInformationResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateInventoryItemLocationInformationResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateInventoryItemLocationInformationResponseMultiError) AllErrors() []error { return m }

// CreateInventoryItemLocationInformationResponseValidationError is the
// validation error returned by
// CreateInventoryItemLocationInformationResponse.Validate if the designated
// constraints aren't met.
type CreateInventoryItemLocationInformationResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateInventoryItemLocationInformationResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateInventoryItemLocationInformationResponseValidationError) Reason() string {
	return e.reason
}

// Cause function returns cause value.
func (e CreateInventoryItemLocationInformationResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateInventoryItemLocationInformationResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateInventoryItemLocationInformationResponseValidationError) ErrorName() string {
	return "CreateInventoryItemLocationInformationResponseValidationError"
}

// Error satisfies the builtin error interface
func (e CreateInventoryItemLocationInformationResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateInventoryItemLocationInformationResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateInventoryItemLocationInformationResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateInventoryItemLocationInformationResponseValidationError{}

// Validate checks the field values on InventoryReport with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *InventoryReport) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on InventoryReport with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// InventoryReportMultiError, or nil if none found.
func (m *InventoryReport) ValidateAll() error {
	return m.validate(true)
}

func (m *InventoryReport) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetInventoryReportD()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, InventoryReportValidationError{
					field:  "InventoryReportD",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, InventoryReportValidationError{
					field:  "InventoryReportD",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetInventoryReportD()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return InventoryReportValidationError{
				field:  "InventoryReportD",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetInventoryReportT()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, InventoryReportValidationError{
					field:  "InventoryReportT",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, InventoryReportValidationError{
					field:  "InventoryReportT",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetInventoryReportT()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return InventoryReportValidationError{
				field:  "InventoryReportT",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetCrUpdUser()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, InventoryReportValidationError{
					field:  "CrUpdUser",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, InventoryReportValidationError{
					field:  "CrUpdUser",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCrUpdUser()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return InventoryReportValidationError{
				field:  "CrUpdUser",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetCrUpdTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, InventoryReportValidationError{
					field:  "CrUpdTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, InventoryReportValidationError{
					field:  "CrUpdTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCrUpdTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return InventoryReportValidationError{
				field:  "CrUpdTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return InventoryReportMultiError(errors)
	}

	return nil
}

// InventoryReportMultiError is an error wrapping multiple validation errors
// returned by InventoryReport.ValidateAll() if the designated constraints
// aren't met.
type InventoryReportMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m InventoryReportMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m InventoryReportMultiError) AllErrors() []error { return m }

// InventoryReportValidationError is the validation error returned by
// InventoryReport.Validate if the designated constraints aren't met.
type InventoryReportValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e InventoryReportValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e InventoryReportValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e InventoryReportValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e InventoryReportValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e InventoryReportValidationError) ErrorName() string { return "InventoryReportValidationError" }

// Error satisfies the builtin error interface
func (e InventoryReportValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sInventoryReport.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = InventoryReportValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = InventoryReportValidationError{}

// Validate checks the field values on InventoryReportD with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *InventoryReportD) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on InventoryReportD with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// InventoryReportDMultiError, or nil if none found.
func (m *InventoryReportD) ValidateAll() error {
	return m.validate(true)
}

func (m *InventoryReportD) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for Uuid4

	// no validation rules for IdS

	// no validation rules for InventoryReportTypeCode

	// no validation rules for StructureTypeCode

	// no validation rules for InventoryReportIdentification

	// no validation rules for InventoryReportingParty

	// no validation rules for InventoryReportToParty

	if len(errors) > 0 {
		return InventoryReportDMultiError(errors)
	}

	return nil
}

// InventoryReportDMultiError is an error wrapping multiple validation errors
// returned by InventoryReportD.ValidateAll() if the designated constraints
// aren't met.
type InventoryReportDMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m InventoryReportDMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m InventoryReportDMultiError) AllErrors() []error { return m }

// InventoryReportDValidationError is the validation error returned by
// InventoryReportD.Validate if the designated constraints aren't met.
type InventoryReportDValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e InventoryReportDValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e InventoryReportDValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e InventoryReportDValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e InventoryReportDValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e InventoryReportDValidationError) ErrorName() string { return "InventoryReportDValidationError" }

// Error satisfies the builtin error interface
func (e InventoryReportDValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sInventoryReportD.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = InventoryReportDValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = InventoryReportDValidationError{}

// Validate checks the field values on InventoryReportT with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *InventoryReportT) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on InventoryReportT with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// InventoryReportTMultiError, or nil if none found.
func (m *InventoryReportT) ValidateAll() error {
	return m.validate(true)
}

func (m *InventoryReportT) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetReportingPeriodBegin()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, InventoryReportTValidationError{
					field:  "ReportingPeriodBegin",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, InventoryReportTValidationError{
					field:  "ReportingPeriodBegin",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetReportingPeriodBegin()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return InventoryReportTValidationError{
				field:  "ReportingPeriodBegin",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetReportingPeriodEnd()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, InventoryReportTValidationError{
					field:  "ReportingPeriodEnd",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, InventoryReportTValidationError{
					field:  "ReportingPeriodEnd",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetReportingPeriodEnd()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return InventoryReportTValidationError{
				field:  "ReportingPeriodEnd",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return InventoryReportTMultiError(errors)
	}

	return nil
}

// InventoryReportTMultiError is an error wrapping multiple validation errors
// returned by InventoryReportT.ValidateAll() if the designated constraints
// aren't met.
type InventoryReportTMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m InventoryReportTMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m InventoryReportTMultiError) AllErrors() []error { return m }

// InventoryReportTValidationError is the validation error returned by
// InventoryReportT.Validate if the designated constraints aren't met.
type InventoryReportTValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e InventoryReportTValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e InventoryReportTValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e InventoryReportTValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e InventoryReportTValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e InventoryReportTValidationError) ErrorName() string { return "InventoryReportTValidationError" }

// Error satisfies the builtin error interface
func (e InventoryReportTValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sInventoryReportT.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = InventoryReportTValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = InventoryReportTValidationError{}

// Validate checks the field values on CreateInventoryReportRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CreateInventoryReportRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateInventoryReportRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreateInventoryReportRequestMultiError, or nil if none found.
func (m *CreateInventoryReportRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateInventoryReportRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for InventoryReportTypeCode

	// no validation rules for StructureTypeCode

	// no validation rules for InventoryReportIdentification

	// no validation rules for InventoryReportingParty

	// no validation rules for InventoryReportToParty

	// no validation rules for ReportingPeriodBegin

	// no validation rules for ReportingPeriodEnd

	// no validation rules for UserId

	// no validation rules for UserEmail

	// no validation rules for RequestId

	if len(errors) > 0 {
		return CreateInventoryReportRequestMultiError(errors)
	}

	return nil
}

// CreateInventoryReportRequestMultiError is an error wrapping multiple
// validation errors returned by CreateInventoryReportRequest.ValidateAll() if
// the designated constraints aren't met.
type CreateInventoryReportRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateInventoryReportRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateInventoryReportRequestMultiError) AllErrors() []error { return m }

// CreateInventoryReportRequestValidationError is the validation error returned
// by CreateInventoryReportRequest.Validate if the designated constraints
// aren't met.
type CreateInventoryReportRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateInventoryReportRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateInventoryReportRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateInventoryReportRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateInventoryReportRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateInventoryReportRequestValidationError) ErrorName() string {
	return "CreateInventoryReportRequestValidationError"
}

// Error satisfies the builtin error interface
func (e CreateInventoryReportRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateInventoryReportRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateInventoryReportRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateInventoryReportRequestValidationError{}

// Validate checks the field values on CreateInventoryReportResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CreateInventoryReportResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateInventoryReportResponse with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// CreateInventoryReportResponseMultiError, or nil if none found.
func (m *CreateInventoryReportResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateInventoryReportResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetInventoryReport()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreateInventoryReportResponseValidationError{
					field:  "InventoryReport",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreateInventoryReportResponseValidationError{
					field:  "InventoryReport",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetInventoryReport()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreateInventoryReportResponseValidationError{
				field:  "InventoryReport",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return CreateInventoryReportResponseMultiError(errors)
	}

	return nil
}

// CreateInventoryReportResponseMultiError is an error wrapping multiple
// validation errors returned by CreateInventoryReportResponse.ValidateAll()
// if the designated constraints aren't met.
type CreateInventoryReportResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateInventoryReportResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateInventoryReportResponseMultiError) AllErrors() []error { return m }

// CreateInventoryReportResponseValidationError is the validation error
// returned by CreateInventoryReportResponse.Validate if the designated
// constraints aren't met.
type CreateInventoryReportResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateInventoryReportResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateInventoryReportResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateInventoryReportResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateInventoryReportResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateInventoryReportResponseValidationError) ErrorName() string {
	return "CreateInventoryReportResponseValidationError"
}

// Error satisfies the builtin error interface
func (e CreateInventoryReportResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateInventoryReportResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateInventoryReportResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateInventoryReportResponseValidationError{}

// Validate checks the field values on InventoryStatusLineItem with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *InventoryStatusLineItem) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on InventoryStatusLineItem with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// InventoryStatusLineItemMultiError, or nil if none found.
func (m *InventoryStatusLineItem) ValidateAll() error {
	return m.validate(true)
}

func (m *InventoryStatusLineItem) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetInventoryStatusLineItemD()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, InventoryStatusLineItemValidationError{
					field:  "InventoryStatusLineItemD",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, InventoryStatusLineItemValidationError{
					field:  "InventoryStatusLineItemD",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetInventoryStatusLineItemD()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return InventoryStatusLineItemValidationError{
				field:  "InventoryStatusLineItemD",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetInventoryStatusLineItemT()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, InventoryStatusLineItemValidationError{
					field:  "InventoryStatusLineItemT",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, InventoryStatusLineItemValidationError{
					field:  "InventoryStatusLineItemT",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetInventoryStatusLineItemT()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return InventoryStatusLineItemValidationError{
				field:  "InventoryStatusLineItemT",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetCrUpdUser()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, InventoryStatusLineItemValidationError{
					field:  "CrUpdUser",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, InventoryStatusLineItemValidationError{
					field:  "CrUpdUser",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCrUpdUser()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return InventoryStatusLineItemValidationError{
				field:  "CrUpdUser",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetCrUpdTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, InventoryStatusLineItemValidationError{
					field:  "CrUpdTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, InventoryStatusLineItemValidationError{
					field:  "CrUpdTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCrUpdTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return InventoryStatusLineItemValidationError{
				field:  "CrUpdTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return InventoryStatusLineItemMultiError(errors)
	}

	return nil
}

// InventoryStatusLineItemMultiError is an error wrapping multiple validation
// errors returned by InventoryStatusLineItem.ValidateAll() if the designated
// constraints aren't met.
type InventoryStatusLineItemMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m InventoryStatusLineItemMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m InventoryStatusLineItemMultiError) AllErrors() []error { return m }

// InventoryStatusLineItemValidationError is the validation error returned by
// InventoryStatusLineItem.Validate if the designated constraints aren't met.
type InventoryStatusLineItemValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e InventoryStatusLineItemValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e InventoryStatusLineItemValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e InventoryStatusLineItemValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e InventoryStatusLineItemValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e InventoryStatusLineItemValidationError) ErrorName() string {
	return "InventoryStatusLineItemValidationError"
}

// Error satisfies the builtin error interface
func (e InventoryStatusLineItemValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sInventoryStatusLineItem.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = InventoryStatusLineItemValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = InventoryStatusLineItemValidationError{}

// Validate checks the field values on InventoryStatusLineItemD with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *InventoryStatusLineItemD) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on InventoryStatusLineItemD with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// InventoryStatusLineItemDMultiError, or nil if none found.
func (m *InventoryStatusLineItemD) ValidateAll() error {
	return m.validate(true)
}

func (m *InventoryStatusLineItemD) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for Uuid4

	// no validation rules for IdS

	// no validation rules for HandlingUnitType

	// no validation rules for InventoryUnitCost

	// no validation rules for IUCCodeListVersion

	// no validation rules for IUCCurrencyCode

	// no validation rules for LineItemNumber

	// no validation rules for ParentLineItemNumber

	// no validation rules for InventoryStatusOwner

	// no validation rules for InventorySubLocationId

	// no validation rules for LogisticUnitIdentification

	// no validation rules for ReturnableAssetIdentification

	// no validation rules for InventoryReportTypeCode

	// no validation rules for StructureTypeCode

	// no validation rules for InventoryReportIdentification

	// no validation rules for InventoryReportingParty

	// no validation rules for InventoryReportToParty

	// no validation rules for InventoryItemLocationInformationId

	// no validation rules for InventoryReportId

	if len(errors) > 0 {
		return InventoryStatusLineItemDMultiError(errors)
	}

	return nil
}

// InventoryStatusLineItemDMultiError is an error wrapping multiple validation
// errors returned by InventoryStatusLineItemD.ValidateAll() if the designated
// constraints aren't met.
type InventoryStatusLineItemDMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m InventoryStatusLineItemDMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m InventoryStatusLineItemDMultiError) AllErrors() []error { return m }

// InventoryStatusLineItemDValidationError is the validation error returned by
// InventoryStatusLineItemD.Validate if the designated constraints aren't met.
type InventoryStatusLineItemDValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e InventoryStatusLineItemDValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e InventoryStatusLineItemDValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e InventoryStatusLineItemDValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e InventoryStatusLineItemDValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e InventoryStatusLineItemDValidationError) ErrorName() string {
	return "InventoryStatusLineItemDValidationError"
}

// Error satisfies the builtin error interface
func (e InventoryStatusLineItemDValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sInventoryStatusLineItemD.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = InventoryStatusLineItemDValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = InventoryStatusLineItemDValidationError{}

// Validate checks the field values on InventoryStatusLineItemT with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *InventoryStatusLineItemT) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on InventoryStatusLineItemT with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// InventoryStatusLineItemTMultiError, or nil if none found.
func (m *InventoryStatusLineItemT) ValidateAll() error {
	return m.validate(true)
}

func (m *InventoryStatusLineItemT) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetFirstInFirstOutDateTimeBegin()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, InventoryStatusLineItemTValidationError{
					field:  "FirstInFirstOutDateTimeBegin",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, InventoryStatusLineItemTValidationError{
					field:  "FirstInFirstOutDateTimeBegin",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetFirstInFirstOutDateTimeBegin()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return InventoryStatusLineItemTValidationError{
				field:  "FirstInFirstOutDateTimeBegin",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetFirstInFirstOutDateTimeEnd()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, InventoryStatusLineItemTValidationError{
					field:  "FirstInFirstOutDateTimeEnd",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, InventoryStatusLineItemTValidationError{
					field:  "FirstInFirstOutDateTimeEnd",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetFirstInFirstOutDateTimeEnd()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return InventoryStatusLineItemTValidationError{
				field:  "FirstInFirstOutDateTimeEnd",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetInventoryDateTimeBegin()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, InventoryStatusLineItemTValidationError{
					field:  "InventoryDateTimeBegin",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, InventoryStatusLineItemTValidationError{
					field:  "InventoryDateTimeBegin",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetInventoryDateTimeBegin()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return InventoryStatusLineItemTValidationError{
				field:  "InventoryDateTimeBegin",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetInventoryDateTimeEnd()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, InventoryStatusLineItemTValidationError{
					field:  "InventoryDateTimeEnd",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, InventoryStatusLineItemTValidationError{
					field:  "InventoryDateTimeEnd",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetInventoryDateTimeEnd()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return InventoryStatusLineItemTValidationError{
				field:  "InventoryDateTimeEnd",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetReportingPeriodBegin()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, InventoryStatusLineItemTValidationError{
					field:  "ReportingPeriodBegin",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, InventoryStatusLineItemTValidationError{
					field:  "ReportingPeriodBegin",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetReportingPeriodBegin()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return InventoryStatusLineItemTValidationError{
				field:  "ReportingPeriodBegin",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetReportingPeriodEnd()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, InventoryStatusLineItemTValidationError{
					field:  "ReportingPeriodEnd",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, InventoryStatusLineItemTValidationError{
					field:  "ReportingPeriodEnd",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetReportingPeriodEnd()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return InventoryStatusLineItemTValidationError{
				field:  "ReportingPeriodEnd",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return InventoryStatusLineItemTMultiError(errors)
	}

	return nil
}

// InventoryStatusLineItemTMultiError is an error wrapping multiple validation
// errors returned by InventoryStatusLineItemT.ValidateAll() if the designated
// constraints aren't met.
type InventoryStatusLineItemTMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m InventoryStatusLineItemTMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m InventoryStatusLineItemTMultiError) AllErrors() []error { return m }

// InventoryStatusLineItemTValidationError is the validation error returned by
// InventoryStatusLineItemT.Validate if the designated constraints aren't met.
type InventoryStatusLineItemTValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e InventoryStatusLineItemTValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e InventoryStatusLineItemTValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e InventoryStatusLineItemTValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e InventoryStatusLineItemTValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e InventoryStatusLineItemTValidationError) ErrorName() string {
	return "InventoryStatusLineItemTValidationError"
}

// Error satisfies the builtin error interface
func (e InventoryStatusLineItemTValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sInventoryStatusLineItemT.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = InventoryStatusLineItemTValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = InventoryStatusLineItemTValidationError{}

// Validate checks the field values on CreateInventoryStatusLineItemRequest
// with the rules defined in the proto definition for this message. If any
// rules are violated, the first error encountered is returned, or nil if
// there are no violations.
func (m *CreateInventoryStatusLineItemRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateInventoryStatusLineItemRequest
// with the rules defined in the proto definition for this message. If any
// rules are violated, the result is a list of violation errors wrapped in
// CreateInventoryStatusLineItemRequestMultiError, or nil if none found.
func (m *CreateInventoryStatusLineItemRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateInventoryStatusLineItemRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for FirstInFirstOutDateTimeBegin

	// no validation rules for FirstInFirstOutDateTimeEnd

	// no validation rules for HandlingUnitType

	// no validation rules for InventoryDateTimeBegin

	// no validation rules for InventoryDateTimeEnd

	// no validation rules for InventoryUnitCost

	// no validation rules for IUCCodeListVersion

	// no validation rules for IUCCurrencyCode

	// no validation rules for LineItemNumber

	// no validation rules for ParentLineItemNumber

	// no validation rules for InventoryStatusOwner

	// no validation rules for InventorySubLocationId

	// no validation rules for LogisticUnitIdentification

	// no validation rules for ReturnableAssetIdentification

	// no validation rules for InventoryReportTypeCode

	// no validation rules for StructureTypeCode

	// no validation rules for InventoryReportIdentification

	// no validation rules for InventoryReportingParty

	// no validation rules for InventoryReportToParty

	// no validation rules for ReportingPeriodBegin

	// no validation rules for ReportingPeriodEnd

	// no validation rules for InventoryItemLocationInformationId

	// no validation rules for InventoryReportId

	// no validation rules for UserId

	// no validation rules for UserEmail

	// no validation rules for RequestId

	if len(errors) > 0 {
		return CreateInventoryStatusLineItemRequestMultiError(errors)
	}

	return nil
}

// CreateInventoryStatusLineItemRequestMultiError is an error wrapping multiple
// validation errors returned by
// CreateInventoryStatusLineItemRequest.ValidateAll() if the designated
// constraints aren't met.
type CreateInventoryStatusLineItemRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateInventoryStatusLineItemRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateInventoryStatusLineItemRequestMultiError) AllErrors() []error { return m }

// CreateInventoryStatusLineItemRequestValidationError is the validation error
// returned by CreateInventoryStatusLineItemRequest.Validate if the designated
// constraints aren't met.
type CreateInventoryStatusLineItemRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateInventoryStatusLineItemRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateInventoryStatusLineItemRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateInventoryStatusLineItemRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateInventoryStatusLineItemRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateInventoryStatusLineItemRequestValidationError) ErrorName() string {
	return "CreateInventoryStatusLineItemRequestValidationError"
}

// Error satisfies the builtin error interface
func (e CreateInventoryStatusLineItemRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateInventoryStatusLineItemRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateInventoryStatusLineItemRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateInventoryStatusLineItemRequestValidationError{}

// Validate checks the field values on CreateInventoryStatusLineItemResponse
// with the rules defined in the proto definition for this message. If any
// rules are violated, the first error encountered is returned, or nil if
// there are no violations.
func (m *CreateInventoryStatusLineItemResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateInventoryStatusLineItemResponse
// with the rules defined in the proto definition for this message. If any
// rules are violated, the result is a list of violation errors wrapped in
// CreateInventoryStatusLineItemResponseMultiError, or nil if none found.
func (m *CreateInventoryStatusLineItemResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateInventoryStatusLineItemResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetInventoryStatusLineItem()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreateInventoryStatusLineItemResponseValidationError{
					field:  "InventoryStatusLineItem",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreateInventoryStatusLineItemResponseValidationError{
					field:  "InventoryStatusLineItem",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetInventoryStatusLineItem()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreateInventoryStatusLineItemResponseValidationError{
				field:  "InventoryStatusLineItem",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return CreateInventoryStatusLineItemResponseMultiError(errors)
	}

	return nil
}

// CreateInventoryStatusLineItemResponseMultiError is an error wrapping
// multiple validation errors returned by
// CreateInventoryStatusLineItemResponse.ValidateAll() if the designated
// constraints aren't met.
type CreateInventoryStatusLineItemResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateInventoryStatusLineItemResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateInventoryStatusLineItemResponseMultiError) AllErrors() []error { return m }

// CreateInventoryStatusLineItemResponseValidationError is the validation error
// returned by CreateInventoryStatusLineItemResponse.Validate if the
// designated constraints aren't met.
type CreateInventoryStatusLineItemResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateInventoryStatusLineItemResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateInventoryStatusLineItemResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateInventoryStatusLineItemResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateInventoryStatusLineItemResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateInventoryStatusLineItemResponseValidationError) ErrorName() string {
	return "CreateInventoryStatusLineItemResponseValidationError"
}

// Error satisfies the builtin error interface
func (e CreateInventoryStatusLineItemResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateInventoryStatusLineItemResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateInventoryStatusLineItemResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateInventoryStatusLineItemResponseValidationError{}

// Validate checks the field values on InventorySubLocation with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *InventorySubLocation) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on InventorySubLocation with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// InventorySubLocationMultiError, or nil if none found.
func (m *InventorySubLocation) ValidateAll() error {
	return m.validate(true)
}

func (m *InventorySubLocation) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for Buyer

	// no validation rules for AdditionalPartyIdentification

	// no validation rules for AdditionalPartyIdentificationTypeCode

	// no validation rules for CodeListVersion

	// no validation rules for Gln

	// no validation rules for GlnExtension

	// no validation rules for InventorySubLocationFunctionCode

	// no validation rules for InventorySubLocationTypeCode

	if len(errors) > 0 {
		return InventorySubLocationMultiError(errors)
	}

	return nil
}

// InventorySubLocationMultiError is an error wrapping multiple validation
// errors returned by InventorySubLocation.ValidateAll() if the designated
// constraints aren't met.
type InventorySubLocationMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m InventorySubLocationMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m InventorySubLocationMultiError) AllErrors() []error { return m }

// InventorySubLocationValidationError is the validation error returned by
// InventorySubLocation.Validate if the designated constraints aren't met.
type InventorySubLocationValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e InventorySubLocationValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e InventorySubLocationValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e InventorySubLocationValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e InventorySubLocationValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e InventorySubLocationValidationError) ErrorName() string {
	return "InventorySubLocationValidationError"
}

// Error satisfies the builtin error interface
func (e InventorySubLocationValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sInventorySubLocation.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = InventorySubLocationValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = InventorySubLocationValidationError{}

// Validate checks the field values on CreateInventorySubLocationRequest with
// the rules defined in the proto definition for this message. If any rules
// are violated, the first error encountered is returned, or nil if there are
// no violations.
func (m *CreateInventorySubLocationRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateInventorySubLocationRequest
// with the rules defined in the proto definition for this message. If any
// rules are violated, the result is a list of violation errors wrapped in
// CreateInventorySubLocationRequestMultiError, or nil if none found.
func (m *CreateInventorySubLocationRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateInventorySubLocationRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for AdditionalPartyIdentification

	// no validation rules for AdditionalPartyIdentificationTypeCode

	// no validation rules for CodeListVersion

	// no validation rules for Gln

	// no validation rules for GlnExtension

	// no validation rules for InventorySubLocationFunctionCode

	// no validation rules for InventorySubLocationTypeCode

	// no validation rules for UserId

	// no validation rules for UserEmail

	// no validation rules for RequestId

	if len(errors) > 0 {
		return CreateInventorySubLocationRequestMultiError(errors)
	}

	return nil
}

// CreateInventorySubLocationRequestMultiError is an error wrapping multiple
// validation errors returned by
// CreateInventorySubLocationRequest.ValidateAll() if the designated
// constraints aren't met.
type CreateInventorySubLocationRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateInventorySubLocationRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateInventorySubLocationRequestMultiError) AllErrors() []error { return m }

// CreateInventorySubLocationRequestValidationError is the validation error
// returned by CreateInventorySubLocationRequest.Validate if the designated
// constraints aren't met.
type CreateInventorySubLocationRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateInventorySubLocationRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateInventorySubLocationRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateInventorySubLocationRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateInventorySubLocationRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateInventorySubLocationRequestValidationError) ErrorName() string {
	return "CreateInventorySubLocationRequestValidationError"
}

// Error satisfies the builtin error interface
func (e CreateInventorySubLocationRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateInventorySubLocationRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateInventorySubLocationRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateInventorySubLocationRequestValidationError{}

// Validate checks the field values on CreateInventorySubLocationResponse with
// the rules defined in the proto definition for this message. If any rules
// are violated, the first error encountered is returned, or nil if there are
// no violations.
func (m *CreateInventorySubLocationResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateInventorySubLocationResponse
// with the rules defined in the proto definition for this message. If any
// rules are violated, the result is a list of violation errors wrapped in
// CreateInventorySubLocationResponseMultiError, or nil if none found.
func (m *CreateInventorySubLocationResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateInventorySubLocationResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetInventorySubLocation()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreateInventorySubLocationResponseValidationError{
					field:  "InventorySubLocation",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreateInventorySubLocationResponseValidationError{
					field:  "InventorySubLocation",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetInventorySubLocation()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreateInventorySubLocationResponseValidationError{
				field:  "InventorySubLocation",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return CreateInventorySubLocationResponseMultiError(errors)
	}

	return nil
}

// CreateInventorySubLocationResponseMultiError is an error wrapping multiple
// validation errors returned by
// CreateInventorySubLocationResponse.ValidateAll() if the designated
// constraints aren't met.
type CreateInventorySubLocationResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateInventorySubLocationResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateInventorySubLocationResponseMultiError) AllErrors() []error { return m }

// CreateInventorySubLocationResponseValidationError is the validation error
// returned by CreateInventorySubLocationResponse.Validate if the designated
// constraints aren't met.
type CreateInventorySubLocationResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateInventorySubLocationResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateInventorySubLocationResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateInventorySubLocationResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateInventorySubLocationResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateInventorySubLocationResponseValidationError) ErrorName() string {
	return "CreateInventorySubLocationResponseValidationError"
}

// Error satisfies the builtin error interface
func (e CreateInventorySubLocationResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateInventorySubLocationResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateInventorySubLocationResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateInventorySubLocationResponseValidationError{}

// Validate checks the field values on LogisticUnitInventoryEvent with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *LogisticUnitInventoryEvent) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on LogisticUnitInventoryEvent with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// LogisticUnitInventoryEventMultiError, or nil if none found.
func (m *LogisticUnitInventoryEvent) ValidateAll() error {
	return m.validate(true)
}

func (m *LogisticUnitInventoryEvent) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetLogisticUnitInventoryEventD()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, LogisticUnitInventoryEventValidationError{
					field:  "LogisticUnitInventoryEventD",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, LogisticUnitInventoryEventValidationError{
					field:  "LogisticUnitInventoryEventD",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetLogisticUnitInventoryEventD()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return LogisticUnitInventoryEventValidationError{
				field:  "LogisticUnitInventoryEventD",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetLogisticUnitInventoryEventT()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, LogisticUnitInventoryEventValidationError{
					field:  "LogisticUnitInventoryEventT",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, LogisticUnitInventoryEventValidationError{
					field:  "LogisticUnitInventoryEventT",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetLogisticUnitInventoryEventT()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return LogisticUnitInventoryEventValidationError{
				field:  "LogisticUnitInventoryEventT",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetCrUpdUser()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, LogisticUnitInventoryEventValidationError{
					field:  "CrUpdUser",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, LogisticUnitInventoryEventValidationError{
					field:  "CrUpdUser",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCrUpdUser()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return LogisticUnitInventoryEventValidationError{
				field:  "CrUpdUser",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetCrUpdTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, LogisticUnitInventoryEventValidationError{
					field:  "CrUpdTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, LogisticUnitInventoryEventValidationError{
					field:  "CrUpdTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCrUpdTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return LogisticUnitInventoryEventValidationError{
				field:  "CrUpdTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return LogisticUnitInventoryEventMultiError(errors)
	}

	return nil
}

// LogisticUnitInventoryEventMultiError is an error wrapping multiple
// validation errors returned by LogisticUnitInventoryEvent.ValidateAll() if
// the designated constraints aren't met.
type LogisticUnitInventoryEventMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m LogisticUnitInventoryEventMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m LogisticUnitInventoryEventMultiError) AllErrors() []error { return m }

// LogisticUnitInventoryEventValidationError is the validation error returned
// by LogisticUnitInventoryEvent.Validate if the designated constraints aren't met.
type LogisticUnitInventoryEventValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e LogisticUnitInventoryEventValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e LogisticUnitInventoryEventValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e LogisticUnitInventoryEventValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e LogisticUnitInventoryEventValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e LogisticUnitInventoryEventValidationError) ErrorName() string {
	return "LogisticUnitInventoryEventValidationError"
}

// Error satisfies the builtin error interface
func (e LogisticUnitInventoryEventValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sLogisticUnitInventoryEvent.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = LogisticUnitInventoryEventValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = LogisticUnitInventoryEventValidationError{}

// Validate checks the field values on LogisticUnitInventoryEventD with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *LogisticUnitInventoryEventD) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on LogisticUnitInventoryEventD with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// LogisticUnitInventoryEventDMultiError, or nil if none found.
func (m *LogisticUnitInventoryEventD) ValidateAll() error {
	return m.validate(true)
}

func (m *LogisticUnitInventoryEventD) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for Uuid4

	// no validation rules for IdS

	// no validation rules for EventIdentifier

	// no validation rules for InventoryBusinessStepCode

	// no validation rules for InventoryEventReasonCode

	// no validation rules for InventoryMovementTypeCode

	// no validation rules for InventorySubLocationId

	if len(errors) > 0 {
		return LogisticUnitInventoryEventDMultiError(errors)
	}

	return nil
}

// LogisticUnitInventoryEventDMultiError is an error wrapping multiple
// validation errors returned by LogisticUnitInventoryEventD.ValidateAll() if
// the designated constraints aren't met.
type LogisticUnitInventoryEventDMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m LogisticUnitInventoryEventDMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m LogisticUnitInventoryEventDMultiError) AllErrors() []error { return m }

// LogisticUnitInventoryEventDValidationError is the validation error returned
// by LogisticUnitInventoryEventD.Validate if the designated constraints
// aren't met.
type LogisticUnitInventoryEventDValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e LogisticUnitInventoryEventDValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e LogisticUnitInventoryEventDValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e LogisticUnitInventoryEventDValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e LogisticUnitInventoryEventDValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e LogisticUnitInventoryEventDValidationError) ErrorName() string {
	return "LogisticUnitInventoryEventDValidationError"
}

// Error satisfies the builtin error interface
func (e LogisticUnitInventoryEventDValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sLogisticUnitInventoryEventD.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = LogisticUnitInventoryEventDValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = LogisticUnitInventoryEventDValidationError{}

// Validate checks the field values on LogisticUnitInventoryEventT with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *LogisticUnitInventoryEventT) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on LogisticUnitInventoryEventT with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// LogisticUnitInventoryEventTMultiError, or nil if none found.
func (m *LogisticUnitInventoryEventT) ValidateAll() error {
	return m.validate(true)
}

func (m *LogisticUnitInventoryEventT) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetEventDateTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, LogisticUnitInventoryEventTValidationError{
					field:  "EventDateTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, LogisticUnitInventoryEventTValidationError{
					field:  "EventDateTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetEventDateTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return LogisticUnitInventoryEventTValidationError{
				field:  "EventDateTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return LogisticUnitInventoryEventTMultiError(errors)
	}

	return nil
}

// LogisticUnitInventoryEventTMultiError is an error wrapping multiple
// validation errors returned by LogisticUnitInventoryEventT.ValidateAll() if
// the designated constraints aren't met.
type LogisticUnitInventoryEventTMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m LogisticUnitInventoryEventTMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m LogisticUnitInventoryEventTMultiError) AllErrors() []error { return m }

// LogisticUnitInventoryEventTValidationError is the validation error returned
// by LogisticUnitInventoryEventT.Validate if the designated constraints
// aren't met.
type LogisticUnitInventoryEventTValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e LogisticUnitInventoryEventTValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e LogisticUnitInventoryEventTValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e LogisticUnitInventoryEventTValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e LogisticUnitInventoryEventTValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e LogisticUnitInventoryEventTValidationError) ErrorName() string {
	return "LogisticUnitInventoryEventTValidationError"
}

// Error satisfies the builtin error interface
func (e LogisticUnitInventoryEventTValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sLogisticUnitInventoryEventT.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = LogisticUnitInventoryEventTValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = LogisticUnitInventoryEventTValidationError{}

// Validate checks the field values on CreateLogisticUnitInventoryEventRequest
// with the rules defined in the proto definition for this message. If any
// rules are violated, the first error encountered is returned, or nil if
// there are no violations.
func (m *CreateLogisticUnitInventoryEventRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on
// CreateLogisticUnitInventoryEventRequest with the rules defined in the proto
// definition for this message. If any rules are violated, the result is a
// list of violation errors wrapped in
// CreateLogisticUnitInventoryEventRequestMultiError, or nil if none found.
func (m *CreateLogisticUnitInventoryEventRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateLogisticUnitInventoryEventRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for EventDateTime

	// no validation rules for EventIdentifier

	// no validation rules for InventoryBusinessStepCode

	// no validation rules for InventoryEventReasonCode

	// no validation rules for InventoryMovementTypeCode

	// no validation rules for InventorySubLocationId

	// no validation rules for UserId

	// no validation rules for UserEmail

	// no validation rules for RequestId

	if len(errors) > 0 {
		return CreateLogisticUnitInventoryEventRequestMultiError(errors)
	}

	return nil
}

// CreateLogisticUnitInventoryEventRequestMultiError is an error wrapping
// multiple validation errors returned by
// CreateLogisticUnitInventoryEventRequest.ValidateAll() if the designated
// constraints aren't met.
type CreateLogisticUnitInventoryEventRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateLogisticUnitInventoryEventRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateLogisticUnitInventoryEventRequestMultiError) AllErrors() []error { return m }

// CreateLogisticUnitInventoryEventRequestValidationError is the validation
// error returned by CreateLogisticUnitInventoryEventRequest.Validate if the
// designated constraints aren't met.
type CreateLogisticUnitInventoryEventRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateLogisticUnitInventoryEventRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateLogisticUnitInventoryEventRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateLogisticUnitInventoryEventRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateLogisticUnitInventoryEventRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateLogisticUnitInventoryEventRequestValidationError) ErrorName() string {
	return "CreateLogisticUnitInventoryEventRequestValidationError"
}

// Error satisfies the builtin error interface
func (e CreateLogisticUnitInventoryEventRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateLogisticUnitInventoryEventRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateLogisticUnitInventoryEventRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateLogisticUnitInventoryEventRequestValidationError{}

// Validate checks the field values on CreateLogisticUnitInventoryEventResponse
// with the rules defined in the proto definition for this message. If any
// rules are violated, the first error encountered is returned, or nil if
// there are no violations.
func (m *CreateLogisticUnitInventoryEventResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on
// CreateLogisticUnitInventoryEventResponse with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in
// CreateLogisticUnitInventoryEventResponseMultiError, or nil if none found.
func (m *CreateLogisticUnitInventoryEventResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateLogisticUnitInventoryEventResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetLogisticUnitInventoryEvent()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreateLogisticUnitInventoryEventResponseValidationError{
					field:  "LogisticUnitInventoryEvent",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreateLogisticUnitInventoryEventResponseValidationError{
					field:  "LogisticUnitInventoryEvent",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetLogisticUnitInventoryEvent()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreateLogisticUnitInventoryEventResponseValidationError{
				field:  "LogisticUnitInventoryEvent",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return CreateLogisticUnitInventoryEventResponseMultiError(errors)
	}

	return nil
}

// CreateLogisticUnitInventoryEventResponseMultiError is an error wrapping
// multiple validation errors returned by
// CreateLogisticUnitInventoryEventResponse.ValidateAll() if the designated
// constraints aren't met.
type CreateLogisticUnitInventoryEventResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateLogisticUnitInventoryEventResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateLogisticUnitInventoryEventResponseMultiError) AllErrors() []error { return m }

// CreateLogisticUnitInventoryEventResponseValidationError is the validation
// error returned by CreateLogisticUnitInventoryEventResponse.Validate if the
// designated constraints aren't met.
type CreateLogisticUnitInventoryEventResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateLogisticUnitInventoryEventResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateLogisticUnitInventoryEventResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateLogisticUnitInventoryEventResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateLogisticUnitInventoryEventResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateLogisticUnitInventoryEventResponseValidationError) ErrorName() string {
	return "CreateLogisticUnitInventoryEventResponseValidationError"
}

// Error satisfies the builtin error interface
func (e CreateLogisticUnitInventoryEventResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateLogisticUnitInventoryEventResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateLogisticUnitInventoryEventResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateLogisticUnitInventoryEventResponseValidationError{}

// Validate checks the field values on LogisticsInventoryReport with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *LogisticsInventoryReport) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on LogisticsInventoryReport with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// LogisticsInventoryReportMultiError, or nil if none found.
func (m *LogisticsInventoryReport) ValidateAll() error {
	return m.validate(true)
}

func (m *LogisticsInventoryReport) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetLogisticsInventoryReportD()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, LogisticsInventoryReportValidationError{
					field:  "LogisticsInventoryReportD",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, LogisticsInventoryReportValidationError{
					field:  "LogisticsInventoryReportD",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetLogisticsInventoryReportD()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return LogisticsInventoryReportValidationError{
				field:  "LogisticsInventoryReportD",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetLogisticsInventoryReportT()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, LogisticsInventoryReportValidationError{
					field:  "LogisticsInventoryReportT",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, LogisticsInventoryReportValidationError{
					field:  "LogisticsInventoryReportT",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetLogisticsInventoryReportT()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return LogisticsInventoryReportValidationError{
				field:  "LogisticsInventoryReportT",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetCrUpdUser()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, LogisticsInventoryReportValidationError{
					field:  "CrUpdUser",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, LogisticsInventoryReportValidationError{
					field:  "CrUpdUser",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCrUpdUser()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return LogisticsInventoryReportValidationError{
				field:  "CrUpdUser",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetCrUpdTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, LogisticsInventoryReportValidationError{
					field:  "CrUpdTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, LogisticsInventoryReportValidationError{
					field:  "CrUpdTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCrUpdTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return LogisticsInventoryReportValidationError{
				field:  "CrUpdTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return LogisticsInventoryReportMultiError(errors)
	}

	return nil
}

// LogisticsInventoryReportMultiError is an error wrapping multiple validation
// errors returned by LogisticsInventoryReport.ValidateAll() if the designated
// constraints aren't met.
type LogisticsInventoryReportMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m LogisticsInventoryReportMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m LogisticsInventoryReportMultiError) AllErrors() []error { return m }

// LogisticsInventoryReportValidationError is the validation error returned by
// LogisticsInventoryReport.Validate if the designated constraints aren't met.
type LogisticsInventoryReportValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e LogisticsInventoryReportValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e LogisticsInventoryReportValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e LogisticsInventoryReportValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e LogisticsInventoryReportValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e LogisticsInventoryReportValidationError) ErrorName() string {
	return "LogisticsInventoryReportValidationError"
}

// Error satisfies the builtin error interface
func (e LogisticsInventoryReportValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sLogisticsInventoryReport.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = LogisticsInventoryReportValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = LogisticsInventoryReportValidationError{}

// Validate checks the field values on LogisticsInventoryReportD with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *LogisticsInventoryReportD) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on LogisticsInventoryReportD with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// LogisticsInventoryReportDMultiError, or nil if none found.
func (m *LogisticsInventoryReportD) ValidateAll() error {
	return m.validate(true)
}

func (m *LogisticsInventoryReportD) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for Uuid4

	// no validation rules for IdS

	// no validation rules for StructureTypeCode

	// no validation rules for TypeOfServiceTransaction

	// no validation rules for InventoryReportingParty

	// no validation rules for InventoryReportToParty

	// no validation rules for LogisticsInventoryReportIdentification

	// no validation rules for LogisticsInventoryReportRequest

	if len(errors) > 0 {
		return LogisticsInventoryReportDMultiError(errors)
	}

	return nil
}

// LogisticsInventoryReportDMultiError is an error wrapping multiple validation
// errors returned by LogisticsInventoryReportD.ValidateAll() if the
// designated constraints aren't met.
type LogisticsInventoryReportDMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m LogisticsInventoryReportDMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m LogisticsInventoryReportDMultiError) AllErrors() []error { return m }

// LogisticsInventoryReportDValidationError is the validation error returned by
// LogisticsInventoryReportD.Validate if the designated constraints aren't met.
type LogisticsInventoryReportDValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e LogisticsInventoryReportDValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e LogisticsInventoryReportDValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e LogisticsInventoryReportDValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e LogisticsInventoryReportDValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e LogisticsInventoryReportDValidationError) ErrorName() string {
	return "LogisticsInventoryReportDValidationError"
}

// Error satisfies the builtin error interface
func (e LogisticsInventoryReportDValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sLogisticsInventoryReportD.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = LogisticsInventoryReportDValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = LogisticsInventoryReportDValidationError{}

// Validate checks the field values on LogisticsInventoryReportT with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *LogisticsInventoryReportT) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on LogisticsInventoryReportT with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// LogisticsInventoryReportTMultiError, or nil if none found.
func (m *LogisticsInventoryReportT) ValidateAll() error {
	return m.validate(true)
}

func (m *LogisticsInventoryReportT) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetReportingPeriodBegin()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, LogisticsInventoryReportTValidationError{
					field:  "ReportingPeriodBegin",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, LogisticsInventoryReportTValidationError{
					field:  "ReportingPeriodBegin",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetReportingPeriodBegin()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return LogisticsInventoryReportTValidationError{
				field:  "ReportingPeriodBegin",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetReportingPeriodEnd()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, LogisticsInventoryReportTValidationError{
					field:  "ReportingPeriodEnd",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, LogisticsInventoryReportTValidationError{
					field:  "ReportingPeriodEnd",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetReportingPeriodEnd()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return LogisticsInventoryReportTValidationError{
				field:  "ReportingPeriodEnd",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return LogisticsInventoryReportTMultiError(errors)
	}

	return nil
}

// LogisticsInventoryReportTMultiError is an error wrapping multiple validation
// errors returned by LogisticsInventoryReportT.ValidateAll() if the
// designated constraints aren't met.
type LogisticsInventoryReportTMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m LogisticsInventoryReportTMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m LogisticsInventoryReportTMultiError) AllErrors() []error { return m }

// LogisticsInventoryReportTValidationError is the validation error returned by
// LogisticsInventoryReportT.Validate if the designated constraints aren't met.
type LogisticsInventoryReportTValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e LogisticsInventoryReportTValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e LogisticsInventoryReportTValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e LogisticsInventoryReportTValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e LogisticsInventoryReportTValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e LogisticsInventoryReportTValidationError) ErrorName() string {
	return "LogisticsInventoryReportTValidationError"
}

// Error satisfies the builtin error interface
func (e LogisticsInventoryReportTValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sLogisticsInventoryReportT.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = LogisticsInventoryReportTValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = LogisticsInventoryReportTValidationError{}

// Validate checks the field values on CreateLogisticsInventoryReportRequest
// with the rules defined in the proto definition for this message. If any
// rules are violated, the first error encountered is returned, or nil if
// there are no violations.
func (m *CreateLogisticsInventoryReportRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateLogisticsInventoryReportRequest
// with the rules defined in the proto definition for this message. If any
// rules are violated, the result is a list of violation errors wrapped in
// CreateLogisticsInventoryReportRequestMultiError, or nil if none found.
func (m *CreateLogisticsInventoryReportRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateLogisticsInventoryReportRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for StructureTypeCode

	// no validation rules for TypeOfServiceTransaction

	// no validation rules for InventoryReportingParty

	// no validation rules for InventoryReportToParty

	// no validation rules for LogisticsInventoryReportIdentification

	// no validation rules for LogisticsInventoryReportRequest

	// no validation rules for ReportingPeriodBegin

	// no validation rules for ReportingPeriodEnd

	// no validation rules for UserId

	// no validation rules for UserEmail

	// no validation rules for RequestId

	if len(errors) > 0 {
		return CreateLogisticsInventoryReportRequestMultiError(errors)
	}

	return nil
}

// CreateLogisticsInventoryReportRequestMultiError is an error wrapping
// multiple validation errors returned by
// CreateLogisticsInventoryReportRequest.ValidateAll() if the designated
// constraints aren't met.
type CreateLogisticsInventoryReportRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateLogisticsInventoryReportRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateLogisticsInventoryReportRequestMultiError) AllErrors() []error { return m }

// CreateLogisticsInventoryReportRequestValidationError is the validation error
// returned by CreateLogisticsInventoryReportRequest.Validate if the
// designated constraints aren't met.
type CreateLogisticsInventoryReportRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateLogisticsInventoryReportRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateLogisticsInventoryReportRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateLogisticsInventoryReportRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateLogisticsInventoryReportRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateLogisticsInventoryReportRequestValidationError) ErrorName() string {
	return "CreateLogisticsInventoryReportRequestValidationError"
}

// Error satisfies the builtin error interface
func (e CreateLogisticsInventoryReportRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateLogisticsInventoryReportRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateLogisticsInventoryReportRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateLogisticsInventoryReportRequestValidationError{}

// Validate checks the field values on CreateLogisticsInventoryReportResponse
// with the rules defined in the proto definition for this message. If any
// rules are violated, the first error encountered is returned, or nil if
// there are no violations.
func (m *CreateLogisticsInventoryReportResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on
// CreateLogisticsInventoryReportResponse with the rules defined in the proto
// definition for this message. If any rules are violated, the result is a
// list of violation errors wrapped in
// CreateLogisticsInventoryReportResponseMultiError, or nil if none found.
func (m *CreateLogisticsInventoryReportResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateLogisticsInventoryReportResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetLogisticsInventoryReport()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreateLogisticsInventoryReportResponseValidationError{
					field:  "LogisticsInventoryReport",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreateLogisticsInventoryReportResponseValidationError{
					field:  "LogisticsInventoryReport",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetLogisticsInventoryReport()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreateLogisticsInventoryReportResponseValidationError{
				field:  "LogisticsInventoryReport",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return CreateLogisticsInventoryReportResponseMultiError(errors)
	}

	return nil
}

// CreateLogisticsInventoryReportResponseMultiError is an error wrapping
// multiple validation errors returned by
// CreateLogisticsInventoryReportResponse.ValidateAll() if the designated
// constraints aren't met.
type CreateLogisticsInventoryReportResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateLogisticsInventoryReportResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateLogisticsInventoryReportResponseMultiError) AllErrors() []error { return m }

// CreateLogisticsInventoryReportResponseValidationError is the validation
// error returned by CreateLogisticsInventoryReportResponse.Validate if the
// designated constraints aren't met.
type CreateLogisticsInventoryReportResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateLogisticsInventoryReportResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateLogisticsInventoryReportResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateLogisticsInventoryReportResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateLogisticsInventoryReportResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateLogisticsInventoryReportResponseValidationError) ErrorName() string {
	return "CreateLogisticsInventoryReportResponseValidationError"
}

// Error satisfies the builtin error interface
func (e CreateLogisticsInventoryReportResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateLogisticsInventoryReportResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateLogisticsInventoryReportResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateLogisticsInventoryReportResponseValidationError{}

// Validate checks the field values on
// LogisticsInventoryReportInventoryLocation with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *LogisticsInventoryReportInventoryLocation) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on
// LogisticsInventoryReportInventoryLocation with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in
// LogisticsInventoryReportInventoryLocationMultiError, or nil if none found.
func (m *LogisticsInventoryReportInventoryLocation) ValidateAll() error {
	return m.validate(true)
}

func (m *LogisticsInventoryReportInventoryLocation) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for InventoryLocationId

	// no validation rules for LogisticsInventoryReportId

	if len(errors) > 0 {
		return LogisticsInventoryReportInventoryLocationMultiError(errors)
	}

	return nil
}

// LogisticsInventoryReportInventoryLocationMultiError is an error wrapping
// multiple validation errors returned by
// LogisticsInventoryReportInventoryLocation.ValidateAll() if the designated
// constraints aren't met.
type LogisticsInventoryReportInventoryLocationMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m LogisticsInventoryReportInventoryLocationMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m LogisticsInventoryReportInventoryLocationMultiError) AllErrors() []error { return m }

// LogisticsInventoryReportInventoryLocationValidationError is the validation
// error returned by LogisticsInventoryReportInventoryLocation.Validate if the
// designated constraints aren't met.
type LogisticsInventoryReportInventoryLocationValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e LogisticsInventoryReportInventoryLocationValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e LogisticsInventoryReportInventoryLocationValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e LogisticsInventoryReportInventoryLocationValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e LogisticsInventoryReportInventoryLocationValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e LogisticsInventoryReportInventoryLocationValidationError) ErrorName() string {
	return "LogisticsInventoryReportInventoryLocationValidationError"
}

// Error satisfies the builtin error interface
func (e LogisticsInventoryReportInventoryLocationValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sLogisticsInventoryReportInventoryLocation.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = LogisticsInventoryReportInventoryLocationValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = LogisticsInventoryReportInventoryLocationValidationError{}

// Validate checks the field values on
// CreateLogisticsInventoryReportInventoryLocationRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CreateLogisticsInventoryReportInventoryLocationRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on
// CreateLogisticsInventoryReportInventoryLocationRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreateLogisticsInventoryReportInventoryLocationRequestMultiError, or nil if
// none found.
func (m *CreateLogisticsInventoryReportInventoryLocationRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateLogisticsInventoryReportInventoryLocationRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for InventoryLocationId

	// no validation rules for LogisticsInventoryReportId

	// no validation rules for UserId

	// no validation rules for UserEmail

	// no validation rules for RequestId

	if len(errors) > 0 {
		return CreateLogisticsInventoryReportInventoryLocationRequestMultiError(errors)
	}

	return nil
}

// CreateLogisticsInventoryReportInventoryLocationRequestMultiError is an error
// wrapping multiple validation errors returned by
// CreateLogisticsInventoryReportInventoryLocationRequest.ValidateAll() if the
// designated constraints aren't met.
type CreateLogisticsInventoryReportInventoryLocationRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateLogisticsInventoryReportInventoryLocationRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateLogisticsInventoryReportInventoryLocationRequestMultiError) AllErrors() []error {
	return m
}

// CreateLogisticsInventoryReportInventoryLocationRequestValidationError is the
// validation error returned by
// CreateLogisticsInventoryReportInventoryLocationRequest.Validate if the
// designated constraints aren't met.
type CreateLogisticsInventoryReportInventoryLocationRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateLogisticsInventoryReportInventoryLocationRequestValidationError) Field() string {
	return e.field
}

// Reason function returns reason value.
func (e CreateLogisticsInventoryReportInventoryLocationRequestValidationError) Reason() string {
	return e.reason
}

// Cause function returns cause value.
func (e CreateLogisticsInventoryReportInventoryLocationRequestValidationError) Cause() error {
	return e.cause
}

// Key function returns key value.
func (e CreateLogisticsInventoryReportInventoryLocationRequestValidationError) Key() bool {
	return e.key
}

// ErrorName returns error name.
func (e CreateLogisticsInventoryReportInventoryLocationRequestValidationError) ErrorName() string {
	return "CreateLogisticsInventoryReportInventoryLocationRequestValidationError"
}

// Error satisfies the builtin error interface
func (e CreateLogisticsInventoryReportInventoryLocationRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateLogisticsInventoryReportInventoryLocationRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateLogisticsInventoryReportInventoryLocationRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateLogisticsInventoryReportInventoryLocationRequestValidationError{}

// Validate checks the field values on
// CreateLogisticsInventoryReportInventoryLocationResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CreateLogisticsInventoryReportInventoryLocationResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on
// CreateLogisticsInventoryReportInventoryLocationResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreateLogisticsInventoryReportInventoryLocationResponseMultiError, or nil
// if none found.
func (m *CreateLogisticsInventoryReportInventoryLocationResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateLogisticsInventoryReportInventoryLocationResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetLogisticsInventoryReportInventoryLocation()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreateLogisticsInventoryReportInventoryLocationResponseValidationError{
					field:  "LogisticsInventoryReportInventoryLocation",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreateLogisticsInventoryReportInventoryLocationResponseValidationError{
					field:  "LogisticsInventoryReportInventoryLocation",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetLogisticsInventoryReportInventoryLocation()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreateLogisticsInventoryReportInventoryLocationResponseValidationError{
				field:  "LogisticsInventoryReportInventoryLocation",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return CreateLogisticsInventoryReportInventoryLocationResponseMultiError(errors)
	}

	return nil
}

// CreateLogisticsInventoryReportInventoryLocationResponseMultiError is an
// error wrapping multiple validation errors returned by
// CreateLogisticsInventoryReportInventoryLocationResponse.ValidateAll() if
// the designated constraints aren't met.
type CreateLogisticsInventoryReportInventoryLocationResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateLogisticsInventoryReportInventoryLocationResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateLogisticsInventoryReportInventoryLocationResponseMultiError) AllErrors() []error {
	return m
}

// CreateLogisticsInventoryReportInventoryLocationResponseValidationError is
// the validation error returned by
// CreateLogisticsInventoryReportInventoryLocationResponse.Validate if the
// designated constraints aren't met.
type CreateLogisticsInventoryReportInventoryLocationResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateLogisticsInventoryReportInventoryLocationResponseValidationError) Field() string {
	return e.field
}

// Reason function returns reason value.
func (e CreateLogisticsInventoryReportInventoryLocationResponseValidationError) Reason() string {
	return e.reason
}

// Cause function returns cause value.
func (e CreateLogisticsInventoryReportInventoryLocationResponseValidationError) Cause() error {
	return e.cause
}

// Key function returns key value.
func (e CreateLogisticsInventoryReportInventoryLocationResponseValidationError) Key() bool {
	return e.key
}

// ErrorName returns error name.
func (e CreateLogisticsInventoryReportInventoryLocationResponseValidationError) ErrorName() string {
	return "CreateLogisticsInventoryReportInventoryLocationResponseValidationError"
}

// Error satisfies the builtin error interface
func (e CreateLogisticsInventoryReportInventoryLocationResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateLogisticsInventoryReportInventoryLocationResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateLogisticsInventoryReportInventoryLocationResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateLogisticsInventoryReportInventoryLocationResponseValidationError{}

// Validate checks the field values on LogisticUnitInventoryStatus with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *LogisticUnitInventoryStatus) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on LogisticUnitInventoryStatus with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// LogisticUnitInventoryStatusMultiError, or nil if none found.
func (m *LogisticUnitInventoryStatus) ValidateAll() error {
	return m.validate(true)
}

func (m *LogisticUnitInventoryStatus) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetLogisticUnitInventoryStatusD()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, LogisticUnitInventoryStatusValidationError{
					field:  "LogisticUnitInventoryStatusD",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, LogisticUnitInventoryStatusValidationError{
					field:  "LogisticUnitInventoryStatusD",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetLogisticUnitInventoryStatusD()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return LogisticUnitInventoryStatusValidationError{
				field:  "LogisticUnitInventoryStatusD",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetLogisticUnitInventoryStatusT()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, LogisticUnitInventoryStatusValidationError{
					field:  "LogisticUnitInventoryStatusT",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, LogisticUnitInventoryStatusValidationError{
					field:  "LogisticUnitInventoryStatusT",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetLogisticUnitInventoryStatusT()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return LogisticUnitInventoryStatusValidationError{
				field:  "LogisticUnitInventoryStatusT",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return LogisticUnitInventoryStatusMultiError(errors)
	}

	return nil
}

// LogisticUnitInventoryStatusMultiError is an error wrapping multiple
// validation errors returned by LogisticUnitInventoryStatus.ValidateAll() if
// the designated constraints aren't met.
type LogisticUnitInventoryStatusMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m LogisticUnitInventoryStatusMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m LogisticUnitInventoryStatusMultiError) AllErrors() []error { return m }

// LogisticUnitInventoryStatusValidationError is the validation error returned
// by LogisticUnitInventoryStatus.Validate if the designated constraints
// aren't met.
type LogisticUnitInventoryStatusValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e LogisticUnitInventoryStatusValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e LogisticUnitInventoryStatusValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e LogisticUnitInventoryStatusValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e LogisticUnitInventoryStatusValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e LogisticUnitInventoryStatusValidationError) ErrorName() string {
	return "LogisticUnitInventoryStatusValidationError"
}

// Error satisfies the builtin error interface
func (e LogisticUnitInventoryStatusValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sLogisticUnitInventoryStatus.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = LogisticUnitInventoryStatusValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = LogisticUnitInventoryStatusValidationError{}

// Validate checks the field values on LogisticUnitInventoryStatusD with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *LogisticUnitInventoryStatusD) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on LogisticUnitInventoryStatusD with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// LogisticUnitInventoryStatusDMultiError, or nil if none found.
func (m *LogisticUnitInventoryStatusD) ValidateAll() error {
	return m.validate(true)
}

func (m *LogisticUnitInventoryStatusD) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for InventoryDispositionCode

	// no validation rules for InventorySubLocationId

	if len(errors) > 0 {
		return LogisticUnitInventoryStatusDMultiError(errors)
	}

	return nil
}

// LogisticUnitInventoryStatusDMultiError is an error wrapping multiple
// validation errors returned by LogisticUnitInventoryStatusD.ValidateAll() if
// the designated constraints aren't met.
type LogisticUnitInventoryStatusDMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m LogisticUnitInventoryStatusDMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m LogisticUnitInventoryStatusDMultiError) AllErrors() []error { return m }

// LogisticUnitInventoryStatusDValidationError is the validation error returned
// by LogisticUnitInventoryStatusD.Validate if the designated constraints
// aren't met.
type LogisticUnitInventoryStatusDValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e LogisticUnitInventoryStatusDValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e LogisticUnitInventoryStatusDValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e LogisticUnitInventoryStatusDValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e LogisticUnitInventoryStatusDValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e LogisticUnitInventoryStatusDValidationError) ErrorName() string {
	return "LogisticUnitInventoryStatusDValidationError"
}

// Error satisfies the builtin error interface
func (e LogisticUnitInventoryStatusDValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sLogisticUnitInventoryStatusD.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = LogisticUnitInventoryStatusDValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = LogisticUnitInventoryStatusDValidationError{}

// Validate checks the field values on LogisticUnitInventoryStatusT with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *LogisticUnitInventoryStatusT) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on LogisticUnitInventoryStatusT with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// LogisticUnitInventoryStatusTMultiError, or nil if none found.
func (m *LogisticUnitInventoryStatusT) ValidateAll() error {
	return m.validate(true)
}

func (m *LogisticUnitInventoryStatusT) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetInventoryDateTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, LogisticUnitInventoryStatusTValidationError{
					field:  "InventoryDateTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, LogisticUnitInventoryStatusTValidationError{
					field:  "InventoryDateTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetInventoryDateTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return LogisticUnitInventoryStatusTValidationError{
				field:  "InventoryDateTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return LogisticUnitInventoryStatusTMultiError(errors)
	}

	return nil
}

// LogisticUnitInventoryStatusTMultiError is an error wrapping multiple
// validation errors returned by LogisticUnitInventoryStatusT.ValidateAll() if
// the designated constraints aren't met.
type LogisticUnitInventoryStatusTMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m LogisticUnitInventoryStatusTMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m LogisticUnitInventoryStatusTMultiError) AllErrors() []error { return m }

// LogisticUnitInventoryStatusTValidationError is the validation error returned
// by LogisticUnitInventoryStatusT.Validate if the designated constraints
// aren't met.
type LogisticUnitInventoryStatusTValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e LogisticUnitInventoryStatusTValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e LogisticUnitInventoryStatusTValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e LogisticUnitInventoryStatusTValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e LogisticUnitInventoryStatusTValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e LogisticUnitInventoryStatusTValidationError) ErrorName() string {
	return "LogisticUnitInventoryStatusTValidationError"
}

// Error satisfies the builtin error interface
func (e LogisticUnitInventoryStatusTValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sLogisticUnitInventoryStatusT.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = LogisticUnitInventoryStatusTValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = LogisticUnitInventoryStatusTValidationError{}

// Validate checks the field values on CreateLogisticUnitInventoryStatusRequest
// with the rules defined in the proto definition for this message. If any
// rules are violated, the first error encountered is returned, or nil if
// there are no violations.
func (m *CreateLogisticUnitInventoryStatusRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on
// CreateLogisticUnitInventoryStatusRequest with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in
// CreateLogisticUnitInventoryStatusRequestMultiError, or nil if none found.
func (m *CreateLogisticUnitInventoryStatusRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateLogisticUnitInventoryStatusRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for InventoryDateTime

	// no validation rules for InventoryDispositionCode

	// no validation rules for InventorySubLocationId

	// no validation rules for UserId

	// no validation rules for UserEmail

	// no validation rules for RequestId

	if len(errors) > 0 {
		return CreateLogisticUnitInventoryStatusRequestMultiError(errors)
	}

	return nil
}

// CreateLogisticUnitInventoryStatusRequestMultiError is an error wrapping
// multiple validation errors returned by
// CreateLogisticUnitInventoryStatusRequest.ValidateAll() if the designated
// constraints aren't met.
type CreateLogisticUnitInventoryStatusRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateLogisticUnitInventoryStatusRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateLogisticUnitInventoryStatusRequestMultiError) AllErrors() []error { return m }

// CreateLogisticUnitInventoryStatusRequestValidationError is the validation
// error returned by CreateLogisticUnitInventoryStatusRequest.Validate if the
// designated constraints aren't met.
type CreateLogisticUnitInventoryStatusRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateLogisticUnitInventoryStatusRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateLogisticUnitInventoryStatusRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateLogisticUnitInventoryStatusRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateLogisticUnitInventoryStatusRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateLogisticUnitInventoryStatusRequestValidationError) ErrorName() string {
	return "CreateLogisticUnitInventoryStatusRequestValidationError"
}

// Error satisfies the builtin error interface
func (e CreateLogisticUnitInventoryStatusRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateLogisticUnitInventoryStatusRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateLogisticUnitInventoryStatusRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateLogisticUnitInventoryStatusRequestValidationError{}

// Validate checks the field values on
// CreateLogisticUnitInventoryStatusResponse with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *CreateLogisticUnitInventoryStatusResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on
// CreateLogisticUnitInventoryStatusResponse with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in
// CreateLogisticUnitInventoryStatusResponseMultiError, or nil if none found.
func (m *CreateLogisticUnitInventoryStatusResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateLogisticUnitInventoryStatusResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetLogisticUnitInventoryStatus()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreateLogisticUnitInventoryStatusResponseValidationError{
					field:  "LogisticUnitInventoryStatus",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreateLogisticUnitInventoryStatusResponseValidationError{
					field:  "LogisticUnitInventoryStatus",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetLogisticUnitInventoryStatus()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreateLogisticUnitInventoryStatusResponseValidationError{
				field:  "LogisticUnitInventoryStatus",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return CreateLogisticUnitInventoryStatusResponseMultiError(errors)
	}

	return nil
}

// CreateLogisticUnitInventoryStatusResponseMultiError is an error wrapping
// multiple validation errors returned by
// CreateLogisticUnitInventoryStatusResponse.ValidateAll() if the designated
// constraints aren't met.
type CreateLogisticUnitInventoryStatusResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateLogisticUnitInventoryStatusResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateLogisticUnitInventoryStatusResponseMultiError) AllErrors() []error { return m }

// CreateLogisticUnitInventoryStatusResponseValidationError is the validation
// error returned by CreateLogisticUnitInventoryStatusResponse.Validate if the
// designated constraints aren't met.
type CreateLogisticUnitInventoryStatusResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateLogisticUnitInventoryStatusResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateLogisticUnitInventoryStatusResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateLogisticUnitInventoryStatusResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateLogisticUnitInventoryStatusResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateLogisticUnitInventoryStatusResponseValidationError) ErrorName() string {
	return "CreateLogisticUnitInventoryStatusResponseValidationError"
}

// Error satisfies the builtin error interface
func (e CreateLogisticUnitInventoryStatusResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateLogisticUnitInventoryStatusResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateLogisticUnitInventoryStatusResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateLogisticUnitInventoryStatusResponseValidationError{}

// Validate checks the field values on LogisticUnitReference with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *LogisticUnitReference) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on LogisticUnitReference with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// LogisticUnitReferenceMultiError, or nil if none found.
func (m *LogisticUnitReference) ValidateAll() error {
	return m.validate(true)
}

func (m *LogisticUnitReference) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for TradeItemQuantity

	// no validation rules for QMeasurementUnitCode

	// no validation rules for QCodeListVersion

	if len(errors) > 0 {
		return LogisticUnitReferenceMultiError(errors)
	}

	return nil
}

// LogisticUnitReferenceMultiError is an error wrapping multiple validation
// errors returned by LogisticUnitReference.ValidateAll() if the designated
// constraints aren't met.
type LogisticUnitReferenceMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m LogisticUnitReferenceMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m LogisticUnitReferenceMultiError) AllErrors() []error { return m }

// LogisticUnitReferenceValidationError is the validation error returned by
// LogisticUnitReference.Validate if the designated constraints aren't met.
type LogisticUnitReferenceValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e LogisticUnitReferenceValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e LogisticUnitReferenceValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e LogisticUnitReferenceValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e LogisticUnitReferenceValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e LogisticUnitReferenceValidationError) ErrorName() string {
	return "LogisticUnitReferenceValidationError"
}

// Error satisfies the builtin error interface
func (e LogisticUnitReferenceValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sLogisticUnitReference.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = LogisticUnitReferenceValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = LogisticUnitReferenceValidationError{}

// Validate checks the field values on CreateLogisticUnitReferenceRequest with
// the rules defined in the proto definition for this message. If any rules
// are violated, the first error encountered is returned, or nil if there are
// no violations.
func (m *CreateLogisticUnitReferenceRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateLogisticUnitReferenceRequest
// with the rules defined in the proto definition for this message. If any
// rules are violated, the result is a list of violation errors wrapped in
// CreateLogisticUnitReferenceRequestMultiError, or nil if none found.
func (m *CreateLogisticUnitReferenceRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateLogisticUnitReferenceRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for TradeItemQuantity

	// no validation rules for QMeasurementUnitCode

	// no validation rules for QCodeListVersion

	// no validation rules for UserId

	// no validation rules for UserEmail

	// no validation rules for RequestId

	if len(errors) > 0 {
		return CreateLogisticUnitReferenceRequestMultiError(errors)
	}

	return nil
}

// CreateLogisticUnitReferenceRequestMultiError is an error wrapping multiple
// validation errors returned by
// CreateLogisticUnitReferenceRequest.ValidateAll() if the designated
// constraints aren't met.
type CreateLogisticUnitReferenceRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateLogisticUnitReferenceRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateLogisticUnitReferenceRequestMultiError) AllErrors() []error { return m }

// CreateLogisticUnitReferenceRequestValidationError is the validation error
// returned by CreateLogisticUnitReferenceRequest.Validate if the designated
// constraints aren't met.
type CreateLogisticUnitReferenceRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateLogisticUnitReferenceRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateLogisticUnitReferenceRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateLogisticUnitReferenceRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateLogisticUnitReferenceRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateLogisticUnitReferenceRequestValidationError) ErrorName() string {
	return "CreateLogisticUnitReferenceRequestValidationError"
}

// Error satisfies the builtin error interface
func (e CreateLogisticUnitReferenceRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateLogisticUnitReferenceRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateLogisticUnitReferenceRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateLogisticUnitReferenceRequestValidationError{}

// Validate checks the field values on CreateLogisticUnitReferenceResponse with
// the rules defined in the proto definition for this message. If any rules
// are violated, the first error encountered is returned, or nil if there are
// no violations.
func (m *CreateLogisticUnitReferenceResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateLogisticUnitReferenceResponse
// with the rules defined in the proto definition for this message. If any
// rules are violated, the result is a list of violation errors wrapped in
// CreateLogisticUnitReferenceResponseMultiError, or nil if none found.
func (m *CreateLogisticUnitReferenceResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateLogisticUnitReferenceResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetLogisticUnitReference()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreateLogisticUnitReferenceResponseValidationError{
					field:  "LogisticUnitReference",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreateLogisticUnitReferenceResponseValidationError{
					field:  "LogisticUnitReference",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetLogisticUnitReference()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreateLogisticUnitReferenceResponseValidationError{
				field:  "LogisticUnitReference",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return CreateLogisticUnitReferenceResponseMultiError(errors)
	}

	return nil
}

// CreateLogisticUnitReferenceResponseMultiError is an error wrapping multiple
// validation errors returned by
// CreateLogisticUnitReferenceResponse.ValidateAll() if the designated
// constraints aren't met.
type CreateLogisticUnitReferenceResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateLogisticUnitReferenceResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateLogisticUnitReferenceResponseMultiError) AllErrors() []error { return m }

// CreateLogisticUnitReferenceResponseValidationError is the validation error
// returned by CreateLogisticUnitReferenceResponse.Validate if the designated
// constraints aren't met.
type CreateLogisticUnitReferenceResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateLogisticUnitReferenceResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateLogisticUnitReferenceResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateLogisticUnitReferenceResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateLogisticUnitReferenceResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateLogisticUnitReferenceResponseValidationError) ErrorName() string {
	return "CreateLogisticUnitReferenceResponseValidationError"
}

// Error satisfies the builtin error interface
func (e CreateLogisticUnitReferenceResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateLogisticUnitReferenceResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateLogisticUnitReferenceResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateLogisticUnitReferenceResponseValidationError{}

// Validate checks the field values on ReturnablePackagingInventoryEvent with
// the rules defined in the proto definition for this message. If any rules
// are violated, the first error encountered is returned, or nil if there are
// no violations.
func (m *ReturnablePackagingInventoryEvent) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ReturnablePackagingInventoryEvent
// with the rules defined in the proto definition for this message. If any
// rules are violated, the result is a list of violation errors wrapped in
// ReturnablePackagingInventoryEventMultiError, or nil if none found.
func (m *ReturnablePackagingInventoryEvent) ValidateAll() error {
	return m.validate(true)
}

func (m *ReturnablePackagingInventoryEvent) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetReturnablePackagingInventoryEventD()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ReturnablePackagingInventoryEventValidationError{
					field:  "ReturnablePackagingInventoryEventD",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ReturnablePackagingInventoryEventValidationError{
					field:  "ReturnablePackagingInventoryEventD",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetReturnablePackagingInventoryEventD()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ReturnablePackagingInventoryEventValidationError{
				field:  "ReturnablePackagingInventoryEventD",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetReturnablePackagingInventoryEventT()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ReturnablePackagingInventoryEventValidationError{
					field:  "ReturnablePackagingInventoryEventT",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ReturnablePackagingInventoryEventValidationError{
					field:  "ReturnablePackagingInventoryEventT",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetReturnablePackagingInventoryEventT()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ReturnablePackagingInventoryEventValidationError{
				field:  "ReturnablePackagingInventoryEventT",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetCrUpdUser()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ReturnablePackagingInventoryEventValidationError{
					field:  "CrUpdUser",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ReturnablePackagingInventoryEventValidationError{
					field:  "CrUpdUser",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCrUpdUser()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ReturnablePackagingInventoryEventValidationError{
				field:  "CrUpdUser",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetCrUpdTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ReturnablePackagingInventoryEventValidationError{
					field:  "CrUpdTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ReturnablePackagingInventoryEventValidationError{
					field:  "CrUpdTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCrUpdTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ReturnablePackagingInventoryEventValidationError{
				field:  "CrUpdTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ReturnablePackagingInventoryEventMultiError(errors)
	}

	return nil
}

// ReturnablePackagingInventoryEventMultiError is an error wrapping multiple
// validation errors returned by
// ReturnablePackagingInventoryEvent.ValidateAll() if the designated
// constraints aren't met.
type ReturnablePackagingInventoryEventMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ReturnablePackagingInventoryEventMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ReturnablePackagingInventoryEventMultiError) AllErrors() []error { return m }

// ReturnablePackagingInventoryEventValidationError is the validation error
// returned by ReturnablePackagingInventoryEvent.Validate if the designated
// constraints aren't met.
type ReturnablePackagingInventoryEventValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ReturnablePackagingInventoryEventValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ReturnablePackagingInventoryEventValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ReturnablePackagingInventoryEventValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ReturnablePackagingInventoryEventValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ReturnablePackagingInventoryEventValidationError) ErrorName() string {
	return "ReturnablePackagingInventoryEventValidationError"
}

// Error satisfies the builtin error interface
func (e ReturnablePackagingInventoryEventValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sReturnablePackagingInventoryEvent.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ReturnablePackagingInventoryEventValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ReturnablePackagingInventoryEventValidationError{}

// Validate checks the field values on ReturnablePackagingInventoryEventD with
// the rules defined in the proto definition for this message. If any rules
// are violated, the first error encountered is returned, or nil if there are
// no violations.
func (m *ReturnablePackagingInventoryEventD) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ReturnablePackagingInventoryEventD
// with the rules defined in the proto definition for this message. If any
// rules are violated, the result is a list of violation errors wrapped in
// ReturnablePackagingInventoryEventDMultiError, or nil if none found.
func (m *ReturnablePackagingInventoryEventD) ValidateAll() error {
	return m.validate(true)
}

func (m *ReturnablePackagingInventoryEventD) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for Uuid4

	// no validation rules for IdS

	// no validation rules for EventIdentifier

	// no validation rules for InventoryBusinessStepCode

	// no validation rules for InventoryEventReasonCode

	// no validation rules for InventoryMovementTypeCode

	// no validation rules for InventorySubLocationId

	if len(errors) > 0 {
		return ReturnablePackagingInventoryEventDMultiError(errors)
	}

	return nil
}

// ReturnablePackagingInventoryEventDMultiError is an error wrapping multiple
// validation errors returned by
// ReturnablePackagingInventoryEventD.ValidateAll() if the designated
// constraints aren't met.
type ReturnablePackagingInventoryEventDMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ReturnablePackagingInventoryEventDMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ReturnablePackagingInventoryEventDMultiError) AllErrors() []error { return m }

// ReturnablePackagingInventoryEventDValidationError is the validation error
// returned by ReturnablePackagingInventoryEventD.Validate if the designated
// constraints aren't met.
type ReturnablePackagingInventoryEventDValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ReturnablePackagingInventoryEventDValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ReturnablePackagingInventoryEventDValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ReturnablePackagingInventoryEventDValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ReturnablePackagingInventoryEventDValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ReturnablePackagingInventoryEventDValidationError) ErrorName() string {
	return "ReturnablePackagingInventoryEventDValidationError"
}

// Error satisfies the builtin error interface
func (e ReturnablePackagingInventoryEventDValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sReturnablePackagingInventoryEventD.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ReturnablePackagingInventoryEventDValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ReturnablePackagingInventoryEventDValidationError{}

// Validate checks the field values on ReturnablePackagingInventoryEventT with
// the rules defined in the proto definition for this message. If any rules
// are violated, the first error encountered is returned, or nil if there are
// no violations.
func (m *ReturnablePackagingInventoryEventT) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ReturnablePackagingInventoryEventT
// with the rules defined in the proto definition for this message. If any
// rules are violated, the result is a list of violation errors wrapped in
// ReturnablePackagingInventoryEventTMultiError, or nil if none found.
func (m *ReturnablePackagingInventoryEventT) ValidateAll() error {
	return m.validate(true)
}

func (m *ReturnablePackagingInventoryEventT) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetEventDateTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ReturnablePackagingInventoryEventTValidationError{
					field:  "EventDateTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ReturnablePackagingInventoryEventTValidationError{
					field:  "EventDateTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetEventDateTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ReturnablePackagingInventoryEventTValidationError{
				field:  "EventDateTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ReturnablePackagingInventoryEventTMultiError(errors)
	}

	return nil
}

// ReturnablePackagingInventoryEventTMultiError is an error wrapping multiple
// validation errors returned by
// ReturnablePackagingInventoryEventT.ValidateAll() if the designated
// constraints aren't met.
type ReturnablePackagingInventoryEventTMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ReturnablePackagingInventoryEventTMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ReturnablePackagingInventoryEventTMultiError) AllErrors() []error { return m }

// ReturnablePackagingInventoryEventTValidationError is the validation error
// returned by ReturnablePackagingInventoryEventT.Validate if the designated
// constraints aren't met.
type ReturnablePackagingInventoryEventTValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ReturnablePackagingInventoryEventTValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ReturnablePackagingInventoryEventTValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ReturnablePackagingInventoryEventTValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ReturnablePackagingInventoryEventTValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ReturnablePackagingInventoryEventTValidationError) ErrorName() string {
	return "ReturnablePackagingInventoryEventTValidationError"
}

// Error satisfies the builtin error interface
func (e ReturnablePackagingInventoryEventTValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sReturnablePackagingInventoryEventT.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ReturnablePackagingInventoryEventTValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ReturnablePackagingInventoryEventTValidationError{}

// Validate checks the field values on
// CreateReturnablePackagingInventoryEventRequest with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *CreateReturnablePackagingInventoryEventRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on
// CreateReturnablePackagingInventoryEventRequest with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in
// CreateReturnablePackagingInventoryEventRequestMultiError, or nil if none found.
func (m *CreateReturnablePackagingInventoryEventRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateReturnablePackagingInventoryEventRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for EventDateTime

	// no validation rules for EventIdentifier

	// no validation rules for InventoryBusinessStepCode

	// no validation rules for InventoryEventReasonCode

	// no validation rules for InventoryMovementTypeCode

	// no validation rules for InventorySubLocationId

	// no validation rules for UserId

	// no validation rules for UserEmail

	// no validation rules for RequestId

	if len(errors) > 0 {
		return CreateReturnablePackagingInventoryEventRequestMultiError(errors)
	}

	return nil
}

// CreateReturnablePackagingInventoryEventRequestMultiError is an error
// wrapping multiple validation errors returned by
// CreateReturnablePackagingInventoryEventRequest.ValidateAll() if the
// designated constraints aren't met.
type CreateReturnablePackagingInventoryEventRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateReturnablePackagingInventoryEventRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateReturnablePackagingInventoryEventRequestMultiError) AllErrors() []error { return m }

// CreateReturnablePackagingInventoryEventRequestValidationError is the
// validation error returned by
// CreateReturnablePackagingInventoryEventRequest.Validate if the designated
// constraints aren't met.
type CreateReturnablePackagingInventoryEventRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateReturnablePackagingInventoryEventRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateReturnablePackagingInventoryEventRequestValidationError) Reason() string {
	return e.reason
}

// Cause function returns cause value.
func (e CreateReturnablePackagingInventoryEventRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateReturnablePackagingInventoryEventRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateReturnablePackagingInventoryEventRequestValidationError) ErrorName() string {
	return "CreateReturnablePackagingInventoryEventRequestValidationError"
}

// Error satisfies the builtin error interface
func (e CreateReturnablePackagingInventoryEventRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateReturnablePackagingInventoryEventRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateReturnablePackagingInventoryEventRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateReturnablePackagingInventoryEventRequestValidationError{}

// Validate checks the field values on
// CreateReturnablePackagingInventoryEventResponse with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *CreateReturnablePackagingInventoryEventResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on
// CreateReturnablePackagingInventoryEventResponse with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in
// CreateReturnablePackagingInventoryEventResponseMultiError, or nil if none found.
func (m *CreateReturnablePackagingInventoryEventResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateReturnablePackagingInventoryEventResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetReturnablePackagingInventoryEvent()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreateReturnablePackagingInventoryEventResponseValidationError{
					field:  "ReturnablePackagingInventoryEvent",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreateReturnablePackagingInventoryEventResponseValidationError{
					field:  "ReturnablePackagingInventoryEvent",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetReturnablePackagingInventoryEvent()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreateReturnablePackagingInventoryEventResponseValidationError{
				field:  "ReturnablePackagingInventoryEvent",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return CreateReturnablePackagingInventoryEventResponseMultiError(errors)
	}

	return nil
}

// CreateReturnablePackagingInventoryEventResponseMultiError is an error
// wrapping multiple validation errors returned by
// CreateReturnablePackagingInventoryEventResponse.ValidateAll() if the
// designated constraints aren't met.
type CreateReturnablePackagingInventoryEventResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateReturnablePackagingInventoryEventResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateReturnablePackagingInventoryEventResponseMultiError) AllErrors() []error { return m }

// CreateReturnablePackagingInventoryEventResponseValidationError is the
// validation error returned by
// CreateReturnablePackagingInventoryEventResponse.Validate if the designated
// constraints aren't met.
type CreateReturnablePackagingInventoryEventResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateReturnablePackagingInventoryEventResponseValidationError) Field() string {
	return e.field
}

// Reason function returns reason value.
func (e CreateReturnablePackagingInventoryEventResponseValidationError) Reason() string {
	return e.reason
}

// Cause function returns cause value.
func (e CreateReturnablePackagingInventoryEventResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateReturnablePackagingInventoryEventResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateReturnablePackagingInventoryEventResponseValidationError) ErrorName() string {
	return "CreateReturnablePackagingInventoryEventResponseValidationError"
}

// Error satisfies the builtin error interface
func (e CreateReturnablePackagingInventoryEventResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateReturnablePackagingInventoryEventResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateReturnablePackagingInventoryEventResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateReturnablePackagingInventoryEventResponseValidationError{}

// Validate checks the field values on TradeItemInventoryEvent with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *TradeItemInventoryEvent) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TradeItemInventoryEvent with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// TradeItemInventoryEventMultiError, or nil if none found.
func (m *TradeItemInventoryEvent) ValidateAll() error {
	return m.validate(true)
}

func (m *TradeItemInventoryEvent) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetTradeItemInventoryEventD()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, TradeItemInventoryEventValidationError{
					field:  "TradeItemInventoryEventD",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, TradeItemInventoryEventValidationError{
					field:  "TradeItemInventoryEventD",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTradeItemInventoryEventD()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return TradeItemInventoryEventValidationError{
				field:  "TradeItemInventoryEventD",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetTradeItemInventoryEventT()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, TradeItemInventoryEventValidationError{
					field:  "TradeItemInventoryEventT",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, TradeItemInventoryEventValidationError{
					field:  "TradeItemInventoryEventT",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTradeItemInventoryEventT()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return TradeItemInventoryEventValidationError{
				field:  "TradeItemInventoryEventT",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetCrUpdUser()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, TradeItemInventoryEventValidationError{
					field:  "CrUpdUser",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, TradeItemInventoryEventValidationError{
					field:  "CrUpdUser",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCrUpdUser()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return TradeItemInventoryEventValidationError{
				field:  "CrUpdUser",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetCrUpdTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, TradeItemInventoryEventValidationError{
					field:  "CrUpdTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, TradeItemInventoryEventValidationError{
					field:  "CrUpdTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCrUpdTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return TradeItemInventoryEventValidationError{
				field:  "CrUpdTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return TradeItemInventoryEventMultiError(errors)
	}

	return nil
}

// TradeItemInventoryEventMultiError is an error wrapping multiple validation
// errors returned by TradeItemInventoryEvent.ValidateAll() if the designated
// constraints aren't met.
type TradeItemInventoryEventMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TradeItemInventoryEventMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TradeItemInventoryEventMultiError) AllErrors() []error { return m }

// TradeItemInventoryEventValidationError is the validation error returned by
// TradeItemInventoryEvent.Validate if the designated constraints aren't met.
type TradeItemInventoryEventValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TradeItemInventoryEventValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TradeItemInventoryEventValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TradeItemInventoryEventValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TradeItemInventoryEventValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TradeItemInventoryEventValidationError) ErrorName() string {
	return "TradeItemInventoryEventValidationError"
}

// Error satisfies the builtin error interface
func (e TradeItemInventoryEventValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTradeItemInventoryEvent.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TradeItemInventoryEventValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TradeItemInventoryEventValidationError{}

// Validate checks the field values on TradeItemInventoryEventD with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *TradeItemInventoryEventD) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TradeItemInventoryEventD with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// TradeItemInventoryEventDMultiError, or nil if none found.
func (m *TradeItemInventoryEventD) ValidateAll() error {
	return m.validate(true)
}

func (m *TradeItemInventoryEventD) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for Uuid4

	// no validation rules for IdS

	// no validation rules for EventIdentifier

	// no validation rules for InventoryBusinessStepCode

	// no validation rules for InventoryDispositionCode

	// no validation rules for InventoryEventReasonCode

	// no validation rules for InventoryMovementTypeCode

	// no validation rules for InventorySubLocationId

	// no validation rules for LiableParty

	// no validation rules for LogisticsInventoryReportId

	if len(errors) > 0 {
		return TradeItemInventoryEventDMultiError(errors)
	}

	return nil
}

// TradeItemInventoryEventDMultiError is an error wrapping multiple validation
// errors returned by TradeItemInventoryEventD.ValidateAll() if the designated
// constraints aren't met.
type TradeItemInventoryEventDMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TradeItemInventoryEventDMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TradeItemInventoryEventDMultiError) AllErrors() []error { return m }

// TradeItemInventoryEventDValidationError is the validation error returned by
// TradeItemInventoryEventD.Validate if the designated constraints aren't met.
type TradeItemInventoryEventDValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TradeItemInventoryEventDValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TradeItemInventoryEventDValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TradeItemInventoryEventDValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TradeItemInventoryEventDValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TradeItemInventoryEventDValidationError) ErrorName() string {
	return "TradeItemInventoryEventDValidationError"
}

// Error satisfies the builtin error interface
func (e TradeItemInventoryEventDValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTradeItemInventoryEventD.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TradeItemInventoryEventDValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TradeItemInventoryEventDValidationError{}

// Validate checks the field values on TradeItemInventoryEventT with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *TradeItemInventoryEventT) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TradeItemInventoryEventT with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// TradeItemInventoryEventTMultiError, or nil if none found.
func (m *TradeItemInventoryEventT) ValidateAll() error {
	return m.validate(true)
}

func (m *TradeItemInventoryEventT) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetEventDateTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, TradeItemInventoryEventTValidationError{
					field:  "EventDateTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, TradeItemInventoryEventTValidationError{
					field:  "EventDateTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetEventDateTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return TradeItemInventoryEventTValidationError{
				field:  "EventDateTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return TradeItemInventoryEventTMultiError(errors)
	}

	return nil
}

// TradeItemInventoryEventTMultiError is an error wrapping multiple validation
// errors returned by TradeItemInventoryEventT.ValidateAll() if the designated
// constraints aren't met.
type TradeItemInventoryEventTMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TradeItemInventoryEventTMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TradeItemInventoryEventTMultiError) AllErrors() []error { return m }

// TradeItemInventoryEventTValidationError is the validation error returned by
// TradeItemInventoryEventT.Validate if the designated constraints aren't met.
type TradeItemInventoryEventTValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TradeItemInventoryEventTValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TradeItemInventoryEventTValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TradeItemInventoryEventTValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TradeItemInventoryEventTValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TradeItemInventoryEventTValidationError) ErrorName() string {
	return "TradeItemInventoryEventTValidationError"
}

// Error satisfies the builtin error interface
func (e TradeItemInventoryEventTValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTradeItemInventoryEventT.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TradeItemInventoryEventTValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TradeItemInventoryEventTValidationError{}

// Validate checks the field values on CreateTradeItemInventoryEventRequest
// with the rules defined in the proto definition for this message. If any
// rules are violated, the first error encountered is returned, or nil if
// there are no violations.
func (m *CreateTradeItemInventoryEventRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateTradeItemInventoryEventRequest
// with the rules defined in the proto definition for this message. If any
// rules are violated, the result is a list of violation errors wrapped in
// CreateTradeItemInventoryEventRequestMultiError, or nil if none found.
func (m *CreateTradeItemInventoryEventRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateTradeItemInventoryEventRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for EventDateTime

	// no validation rules for EventIdentifier

	// no validation rules for InventoryBusinessStepCode

	// no validation rules for InventoryDispositionCode

	// no validation rules for InventoryEventReasonCode

	// no validation rules for InventoryMovementTypeCode

	// no validation rules for InventorySubLocationId

	// no validation rules for LiableParty

	// no validation rules for LogisticsInventoryReportId

	// no validation rules for UserId

	// no validation rules for UserEmail

	// no validation rules for RequestId

	if len(errors) > 0 {
		return CreateTradeItemInventoryEventRequestMultiError(errors)
	}

	return nil
}

// CreateTradeItemInventoryEventRequestMultiError is an error wrapping multiple
// validation errors returned by
// CreateTradeItemInventoryEventRequest.ValidateAll() if the designated
// constraints aren't met.
type CreateTradeItemInventoryEventRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateTradeItemInventoryEventRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateTradeItemInventoryEventRequestMultiError) AllErrors() []error { return m }

// CreateTradeItemInventoryEventRequestValidationError is the validation error
// returned by CreateTradeItemInventoryEventRequest.Validate if the designated
// constraints aren't met.
type CreateTradeItemInventoryEventRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateTradeItemInventoryEventRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateTradeItemInventoryEventRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateTradeItemInventoryEventRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateTradeItemInventoryEventRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateTradeItemInventoryEventRequestValidationError) ErrorName() string {
	return "CreateTradeItemInventoryEventRequestValidationError"
}

// Error satisfies the builtin error interface
func (e CreateTradeItemInventoryEventRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateTradeItemInventoryEventRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateTradeItemInventoryEventRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateTradeItemInventoryEventRequestValidationError{}

// Validate checks the field values on CreateTradeItemInventoryEventResponse
// with the rules defined in the proto definition for this message. If any
// rules are violated, the first error encountered is returned, or nil if
// there are no violations.
func (m *CreateTradeItemInventoryEventResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateTradeItemInventoryEventResponse
// with the rules defined in the proto definition for this message. If any
// rules are violated, the result is a list of violation errors wrapped in
// CreateTradeItemInventoryEventResponseMultiError, or nil if none found.
func (m *CreateTradeItemInventoryEventResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateTradeItemInventoryEventResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetTradeItemInventoryEvent()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreateTradeItemInventoryEventResponseValidationError{
					field:  "TradeItemInventoryEvent",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreateTradeItemInventoryEventResponseValidationError{
					field:  "TradeItemInventoryEvent",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTradeItemInventoryEvent()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreateTradeItemInventoryEventResponseValidationError{
				field:  "TradeItemInventoryEvent",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return CreateTradeItemInventoryEventResponseMultiError(errors)
	}

	return nil
}

// CreateTradeItemInventoryEventResponseMultiError is an error wrapping
// multiple validation errors returned by
// CreateTradeItemInventoryEventResponse.ValidateAll() if the designated
// constraints aren't met.
type CreateTradeItemInventoryEventResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateTradeItemInventoryEventResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateTradeItemInventoryEventResponseMultiError) AllErrors() []error { return m }

// CreateTradeItemInventoryEventResponseValidationError is the validation error
// returned by CreateTradeItemInventoryEventResponse.Validate if the
// designated constraints aren't met.
type CreateTradeItemInventoryEventResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateTradeItemInventoryEventResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateTradeItemInventoryEventResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateTradeItemInventoryEventResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateTradeItemInventoryEventResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateTradeItemInventoryEventResponseValidationError) ErrorName() string {
	return "CreateTradeItemInventoryEventResponseValidationError"
}

// Error satisfies the builtin error interface
func (e CreateTradeItemInventoryEventResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateTradeItemInventoryEventResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateTradeItemInventoryEventResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateTradeItemInventoryEventResponseValidationError{}

// Validate checks the field values on TradeItemInventoryStatus with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *TradeItemInventoryStatus) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TradeItemInventoryStatus with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// TradeItemInventoryStatusMultiError, or nil if none found.
func (m *TradeItemInventoryStatus) ValidateAll() error {
	return m.validate(true)
}

func (m *TradeItemInventoryStatus) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetTradeItemInventoryStatusD()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, TradeItemInventoryStatusValidationError{
					field:  "TradeItemInventoryStatusD",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, TradeItemInventoryStatusValidationError{
					field:  "TradeItemInventoryStatusD",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTradeItemInventoryStatusD()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return TradeItemInventoryStatusValidationError{
				field:  "TradeItemInventoryStatusD",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetTradeItemInventoryStatusT()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, TradeItemInventoryStatusValidationError{
					field:  "TradeItemInventoryStatusT",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, TradeItemInventoryStatusValidationError{
					field:  "TradeItemInventoryStatusT",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTradeItemInventoryStatusT()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return TradeItemInventoryStatusValidationError{
				field:  "TradeItemInventoryStatusT",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return TradeItemInventoryStatusMultiError(errors)
	}

	return nil
}

// TradeItemInventoryStatusMultiError is an error wrapping multiple validation
// errors returned by TradeItemInventoryStatus.ValidateAll() if the designated
// constraints aren't met.
type TradeItemInventoryStatusMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TradeItemInventoryStatusMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TradeItemInventoryStatusMultiError) AllErrors() []error { return m }

// TradeItemInventoryStatusValidationError is the validation error returned by
// TradeItemInventoryStatus.Validate if the designated constraints aren't met.
type TradeItemInventoryStatusValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TradeItemInventoryStatusValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TradeItemInventoryStatusValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TradeItemInventoryStatusValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TradeItemInventoryStatusValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TradeItemInventoryStatusValidationError) ErrorName() string {
	return "TradeItemInventoryStatusValidationError"
}

// Error satisfies the builtin error interface
func (e TradeItemInventoryStatusValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTradeItemInventoryStatus.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TradeItemInventoryStatusValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TradeItemInventoryStatusValidationError{}

// Validate checks the field values on TradeItemInventoryStatusD with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *TradeItemInventoryStatusD) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TradeItemInventoryStatusD with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// TradeItemInventoryStatusDMultiError, or nil if none found.
func (m *TradeItemInventoryStatusD) ValidateAll() error {
	return m.validate(true)
}

func (m *TradeItemInventoryStatusD) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for InventoryDispositionCode

	// no validation rules for InventorySubLocationId

	// no validation rules for LogisticsInventoryReportId

	if len(errors) > 0 {
		return TradeItemInventoryStatusDMultiError(errors)
	}

	return nil
}

// TradeItemInventoryStatusDMultiError is an error wrapping multiple validation
// errors returned by TradeItemInventoryStatusD.ValidateAll() if the
// designated constraints aren't met.
type TradeItemInventoryStatusDMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TradeItemInventoryStatusDMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TradeItemInventoryStatusDMultiError) AllErrors() []error { return m }

// TradeItemInventoryStatusDValidationError is the validation error returned by
// TradeItemInventoryStatusD.Validate if the designated constraints aren't met.
type TradeItemInventoryStatusDValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TradeItemInventoryStatusDValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TradeItemInventoryStatusDValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TradeItemInventoryStatusDValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TradeItemInventoryStatusDValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TradeItemInventoryStatusDValidationError) ErrorName() string {
	return "TradeItemInventoryStatusDValidationError"
}

// Error satisfies the builtin error interface
func (e TradeItemInventoryStatusDValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTradeItemInventoryStatusD.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TradeItemInventoryStatusDValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TradeItemInventoryStatusDValidationError{}

// Validate checks the field values on TradeItemInventoryStatusT with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *TradeItemInventoryStatusT) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TradeItemInventoryStatusT with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// TradeItemInventoryStatusTMultiError, or nil if none found.
func (m *TradeItemInventoryStatusT) ValidateAll() error {
	return m.validate(true)
}

func (m *TradeItemInventoryStatusT) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetInventoryDateTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, TradeItemInventoryStatusTValidationError{
					field:  "InventoryDateTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, TradeItemInventoryStatusTValidationError{
					field:  "InventoryDateTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetInventoryDateTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return TradeItemInventoryStatusTValidationError{
				field:  "InventoryDateTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return TradeItemInventoryStatusTMultiError(errors)
	}

	return nil
}

// TradeItemInventoryStatusTMultiError is an error wrapping multiple validation
// errors returned by TradeItemInventoryStatusT.ValidateAll() if the
// designated constraints aren't met.
type TradeItemInventoryStatusTMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TradeItemInventoryStatusTMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TradeItemInventoryStatusTMultiError) AllErrors() []error { return m }

// TradeItemInventoryStatusTValidationError is the validation error returned by
// TradeItemInventoryStatusT.Validate if the designated constraints aren't met.
type TradeItemInventoryStatusTValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TradeItemInventoryStatusTValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TradeItemInventoryStatusTValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TradeItemInventoryStatusTValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TradeItemInventoryStatusTValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TradeItemInventoryStatusTValidationError) ErrorName() string {
	return "TradeItemInventoryStatusTValidationError"
}

// Error satisfies the builtin error interface
func (e TradeItemInventoryStatusTValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTradeItemInventoryStatusT.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TradeItemInventoryStatusTValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TradeItemInventoryStatusTValidationError{}

// Validate checks the field values on CreateTradeItemInventoryStatusRequest
// with the rules defined in the proto definition for this message. If any
// rules are violated, the first error encountered is returned, or nil if
// there are no violations.
func (m *CreateTradeItemInventoryStatusRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateTradeItemInventoryStatusRequest
// with the rules defined in the proto definition for this message. If any
// rules are violated, the result is a list of violation errors wrapped in
// CreateTradeItemInventoryStatusRequestMultiError, or nil if none found.
func (m *CreateTradeItemInventoryStatusRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateTradeItemInventoryStatusRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for InventoryDateTime

	// no validation rules for InventoryDispositionCode

	// no validation rules for InventorySubLocationId

	// no validation rules for LogisticsInventoryReportId

	// no validation rules for UserId

	// no validation rules for UserEmail

	// no validation rules for RequestId

	if len(errors) > 0 {
		return CreateTradeItemInventoryStatusRequestMultiError(errors)
	}

	return nil
}

// CreateTradeItemInventoryStatusRequestMultiError is an error wrapping
// multiple validation errors returned by
// CreateTradeItemInventoryStatusRequest.ValidateAll() if the designated
// constraints aren't met.
type CreateTradeItemInventoryStatusRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateTradeItemInventoryStatusRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateTradeItemInventoryStatusRequestMultiError) AllErrors() []error { return m }

// CreateTradeItemInventoryStatusRequestValidationError is the validation error
// returned by CreateTradeItemInventoryStatusRequest.Validate if the
// designated constraints aren't met.
type CreateTradeItemInventoryStatusRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateTradeItemInventoryStatusRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateTradeItemInventoryStatusRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateTradeItemInventoryStatusRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateTradeItemInventoryStatusRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateTradeItemInventoryStatusRequestValidationError) ErrorName() string {
	return "CreateTradeItemInventoryStatusRequestValidationError"
}

// Error satisfies the builtin error interface
func (e CreateTradeItemInventoryStatusRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateTradeItemInventoryStatusRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateTradeItemInventoryStatusRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateTradeItemInventoryStatusRequestValidationError{}

// Validate checks the field values on CreateTradeItemInventoryStatusResponse
// with the rules defined in the proto definition for this message. If any
// rules are violated, the first error encountered is returned, or nil if
// there are no violations.
func (m *CreateTradeItemInventoryStatusResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on
// CreateTradeItemInventoryStatusResponse with the rules defined in the proto
// definition for this message. If any rules are violated, the result is a
// list of violation errors wrapped in
// CreateTradeItemInventoryStatusResponseMultiError, or nil if none found.
func (m *CreateTradeItemInventoryStatusResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateTradeItemInventoryStatusResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetTradeItemInventoryStatus()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreateTradeItemInventoryStatusResponseValidationError{
					field:  "TradeItemInventoryStatus",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreateTradeItemInventoryStatusResponseValidationError{
					field:  "TradeItemInventoryStatus",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTradeItemInventoryStatus()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreateTradeItemInventoryStatusResponseValidationError{
				field:  "TradeItemInventoryStatus",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return CreateTradeItemInventoryStatusResponseMultiError(errors)
	}

	return nil
}

// CreateTradeItemInventoryStatusResponseMultiError is an error wrapping
// multiple validation errors returned by
// CreateTradeItemInventoryStatusResponse.ValidateAll() if the designated
// constraints aren't met.
type CreateTradeItemInventoryStatusResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateTradeItemInventoryStatusResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateTradeItemInventoryStatusResponseMultiError) AllErrors() []error { return m }

// CreateTradeItemInventoryStatusResponseValidationError is the validation
// error returned by CreateTradeItemInventoryStatusResponse.Validate if the
// designated constraints aren't met.
type CreateTradeItemInventoryStatusResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateTradeItemInventoryStatusResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateTradeItemInventoryStatusResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateTradeItemInventoryStatusResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateTradeItemInventoryStatusResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateTradeItemInventoryStatusResponseValidationError) ErrorName() string {
	return "CreateTradeItemInventoryStatusResponseValidationError"
}

// Error satisfies the builtin error interface
func (e CreateTradeItemInventoryStatusResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateTradeItemInventoryStatusResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateTradeItemInventoryStatusResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateTradeItemInventoryStatusResponseValidationError{}

// Validate checks the field values on TransactionalItemCertification with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *TransactionalItemCertification) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TransactionalItemCertification with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// TransactionalItemCertificationMultiError, or nil if none found.
func (m *TransactionalItemCertification) ValidateAll() error {
	return m.validate(true)
}

func (m *TransactionalItemCertification) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for ItemCertificationAgency

	// no validation rules for ItemCertificationStandard

	// no validation rules for ItemCertificationValue

	// no validation rules for OrganicCertificationId

	if len(errors) > 0 {
		return TransactionalItemCertificationMultiError(errors)
	}

	return nil
}

// TransactionalItemCertificationMultiError is an error wrapping multiple
// validation errors returned by TransactionalItemCertification.ValidateAll()
// if the designated constraints aren't met.
type TransactionalItemCertificationMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TransactionalItemCertificationMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TransactionalItemCertificationMultiError) AllErrors() []error { return m }

// TransactionalItemCertificationValidationError is the validation error
// returned by TransactionalItemCertification.Validate if the designated
// constraints aren't met.
type TransactionalItemCertificationValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TransactionalItemCertificationValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TransactionalItemCertificationValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TransactionalItemCertificationValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TransactionalItemCertificationValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TransactionalItemCertificationValidationError) ErrorName() string {
	return "TransactionalItemCertificationValidationError"
}

// Error satisfies the builtin error interface
func (e TransactionalItemCertificationValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTransactionalItemCertification.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TransactionalItemCertificationValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TransactionalItemCertificationValidationError{}

// Validate checks the field values on
// CreateTransactionalItemCertificationRequest with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *CreateTransactionalItemCertificationRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on
// CreateTransactionalItemCertificationRequest with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in
// CreateTransactionalItemCertificationRequestMultiError, or nil if none found.
func (m *CreateTransactionalItemCertificationRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateTransactionalItemCertificationRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ItemCertificationAgency

	// no validation rules for ItemCertificationStandard

	// no validation rules for ItemCertificationValue

	// no validation rules for OrganicCertificationId

	// no validation rules for UserId

	// no validation rules for UserEmail

	// no validation rules for RequestId

	if len(errors) > 0 {
		return CreateTransactionalItemCertificationRequestMultiError(errors)
	}

	return nil
}

// CreateTransactionalItemCertificationRequestMultiError is an error wrapping
// multiple validation errors returned by
// CreateTransactionalItemCertificationRequest.ValidateAll() if the designated
// constraints aren't met.
type CreateTransactionalItemCertificationRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateTransactionalItemCertificationRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateTransactionalItemCertificationRequestMultiError) AllErrors() []error { return m }

// CreateTransactionalItemCertificationRequestValidationError is the validation
// error returned by CreateTransactionalItemCertificationRequest.Validate if
// the designated constraints aren't met.
type CreateTransactionalItemCertificationRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateTransactionalItemCertificationRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateTransactionalItemCertificationRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateTransactionalItemCertificationRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateTransactionalItemCertificationRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateTransactionalItemCertificationRequestValidationError) ErrorName() string {
	return "CreateTransactionalItemCertificationRequestValidationError"
}

// Error satisfies the builtin error interface
func (e CreateTransactionalItemCertificationRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateTransactionalItemCertificationRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateTransactionalItemCertificationRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateTransactionalItemCertificationRequestValidationError{}

// Validate checks the field values on
// CreateTransactionalItemCertificationResponse with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *CreateTransactionalItemCertificationResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on
// CreateTransactionalItemCertificationResponse with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in
// CreateTransactionalItemCertificationResponseMultiError, or nil if none found.
func (m *CreateTransactionalItemCertificationResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateTransactionalItemCertificationResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetTransactionalItemCertification()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreateTransactionalItemCertificationResponseValidationError{
					field:  "TransactionalItemCertification",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreateTransactionalItemCertificationResponseValidationError{
					field:  "TransactionalItemCertification",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTransactionalItemCertification()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreateTransactionalItemCertificationResponseValidationError{
				field:  "TransactionalItemCertification",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return CreateTransactionalItemCertificationResponseMultiError(errors)
	}

	return nil
}

// CreateTransactionalItemCertificationResponseMultiError is an error wrapping
// multiple validation errors returned by
// CreateTransactionalItemCertificationResponse.ValidateAll() if the
// designated constraints aren't met.
type CreateTransactionalItemCertificationResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateTransactionalItemCertificationResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateTransactionalItemCertificationResponseMultiError) AllErrors() []error { return m }

// CreateTransactionalItemCertificationResponseValidationError is the
// validation error returned by
// CreateTransactionalItemCertificationResponse.Validate if the designated
// constraints aren't met.
type CreateTransactionalItemCertificationResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateTransactionalItemCertificationResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateTransactionalItemCertificationResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateTransactionalItemCertificationResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateTransactionalItemCertificationResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateTransactionalItemCertificationResponseValidationError) ErrorName() string {
	return "CreateTransactionalItemCertificationResponseValidationError"
}

// Error satisfies the builtin error interface
func (e CreateTransactionalItemCertificationResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateTransactionalItemCertificationResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateTransactionalItemCertificationResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateTransactionalItemCertificationResponseValidationError{}

// Validate checks the field values on TransactionalItemData with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *TransactionalItemData) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TransactionalItemData with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// TransactionalItemDataMultiError, or nil if none found.
func (m *TransactionalItemData) ValidateAll() error {
	return m.validate(true)
}

func (m *TransactionalItemData) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetTransactionalItemDataD()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, TransactionalItemDataValidationError{
					field:  "TransactionalItemDataD",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, TransactionalItemDataValidationError{
					field:  "TransactionalItemDataD",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTransactionalItemDataD()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return TransactionalItemDataValidationError{
				field:  "TransactionalItemDataD",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetTransactionalItemDataT()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, TransactionalItemDataValidationError{
					field:  "TransactionalItemDataT",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, TransactionalItemDataValidationError{
					field:  "TransactionalItemDataT",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTransactionalItemDataT()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return TransactionalItemDataValidationError{
				field:  "TransactionalItemDataT",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetCrUpdUser()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, TransactionalItemDataValidationError{
					field:  "CrUpdUser",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, TransactionalItemDataValidationError{
					field:  "CrUpdUser",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCrUpdUser()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return TransactionalItemDataValidationError{
				field:  "CrUpdUser",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetCrUpdTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, TransactionalItemDataValidationError{
					field:  "CrUpdTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, TransactionalItemDataValidationError{
					field:  "CrUpdTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCrUpdTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return TransactionalItemDataValidationError{
				field:  "CrUpdTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return TransactionalItemDataMultiError(errors)
	}

	return nil
}

// TransactionalItemDataMultiError is an error wrapping multiple validation
// errors returned by TransactionalItemData.ValidateAll() if the designated
// constraints aren't met.
type TransactionalItemDataMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TransactionalItemDataMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TransactionalItemDataMultiError) AllErrors() []error { return m }

// TransactionalItemDataValidationError is the validation error returned by
// TransactionalItemData.Validate if the designated constraints aren't met.
type TransactionalItemDataValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TransactionalItemDataValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TransactionalItemDataValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TransactionalItemDataValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TransactionalItemDataValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TransactionalItemDataValidationError) ErrorName() string {
	return "TransactionalItemDataValidationError"
}

// Error satisfies the builtin error interface
func (e TransactionalItemDataValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTransactionalItemData.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TransactionalItemDataValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TransactionalItemDataValidationError{}

// Validate checks the field values on TransactionalItemDataD with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *TransactionalItemDataD) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TransactionalItemDataD with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// TransactionalItemDataDMultiError, or nil if none found.
func (m *TransactionalItemDataD) ValidateAll() error {
	return m.validate(true)
}

func (m *TransactionalItemDataD) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for Uuid4

	// no validation rules for IdS

	// no validation rules for BatchNumber

	// no validation rules for CountryOfOrigin

	// no validation rules for ItemInContactWithFoodProduct

	// no validation rules for LotNumber

	// no validation rules for ProductQualityIndication

	// no validation rules for SerialNumber

	// no validation rules for ShelfLife

	// no validation rules for TradeItemQuantity

	// no validation rules for TradeItemInventoryStatusId

	if len(errors) > 0 {
		return TransactionalItemDataDMultiError(errors)
	}

	return nil
}

// TransactionalItemDataDMultiError is an error wrapping multiple validation
// errors returned by TransactionalItemDataD.ValidateAll() if the designated
// constraints aren't met.
type TransactionalItemDataDMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TransactionalItemDataDMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TransactionalItemDataDMultiError) AllErrors() []error { return m }

// TransactionalItemDataDValidationError is the validation error returned by
// TransactionalItemDataD.Validate if the designated constraints aren't met.
type TransactionalItemDataDValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TransactionalItemDataDValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TransactionalItemDataDValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TransactionalItemDataDValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TransactionalItemDataDValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TransactionalItemDataDValidationError) ErrorName() string {
	return "TransactionalItemDataDValidationError"
}

// Error satisfies the builtin error interface
func (e TransactionalItemDataDValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTransactionalItemDataD.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TransactionalItemDataDValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TransactionalItemDataDValidationError{}

// Validate checks the field values on TransactionalItemDataT with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *TransactionalItemDataT) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TransactionalItemDataT with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// TransactionalItemDataTMultiError, or nil if none found.
func (m *TransactionalItemDataT) ValidateAll() error {
	return m.validate(true)
}

func (m *TransactionalItemDataT) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetAvailableForSaleDate()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, TransactionalItemDataTValidationError{
					field:  "AvailableForSaleDate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, TransactionalItemDataTValidationError{
					field:  "AvailableForSaleDate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetAvailableForSaleDate()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return TransactionalItemDataTValidationError{
				field:  "AvailableForSaleDate",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetBestBeforeDate()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, TransactionalItemDataTValidationError{
					field:  "BestBeforeDate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, TransactionalItemDataTValidationError{
					field:  "BestBeforeDate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetBestBeforeDate()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return TransactionalItemDataTValidationError{
				field:  "BestBeforeDate",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetItemExpirationDate()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, TransactionalItemDataTValidationError{
					field:  "ItemExpirationDate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, TransactionalItemDataTValidationError{
					field:  "ItemExpirationDate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetItemExpirationDate()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return TransactionalItemDataTValidationError{
				field:  "ItemExpirationDate",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetPackagingDate()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, TransactionalItemDataTValidationError{
					field:  "PackagingDate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, TransactionalItemDataTValidationError{
					field:  "PackagingDate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetPackagingDate()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return TransactionalItemDataTValidationError{
				field:  "PackagingDate",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetProductionDate()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, TransactionalItemDataTValidationError{
					field:  "ProductionDate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, TransactionalItemDataTValidationError{
					field:  "ProductionDate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetProductionDate()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return TransactionalItemDataTValidationError{
				field:  "ProductionDate",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetSellByDate()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, TransactionalItemDataTValidationError{
					field:  "SellByDate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, TransactionalItemDataTValidationError{
					field:  "SellByDate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSellByDate()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return TransactionalItemDataTValidationError{
				field:  "SellByDate",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return TransactionalItemDataTMultiError(errors)
	}

	return nil
}

// TransactionalItemDataTMultiError is an error wrapping multiple validation
// errors returned by TransactionalItemDataT.ValidateAll() if the designated
// constraints aren't met.
type TransactionalItemDataTMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TransactionalItemDataTMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TransactionalItemDataTMultiError) AllErrors() []error { return m }

// TransactionalItemDataTValidationError is the validation error returned by
// TransactionalItemDataT.Validate if the designated constraints aren't met.
type TransactionalItemDataTValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TransactionalItemDataTValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TransactionalItemDataTValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TransactionalItemDataTValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TransactionalItemDataTValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TransactionalItemDataTValidationError) ErrorName() string {
	return "TransactionalItemDataTValidationError"
}

// Error satisfies the builtin error interface
func (e TransactionalItemDataTValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTransactionalItemDataT.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TransactionalItemDataTValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TransactionalItemDataTValidationError{}

// Validate checks the field values on CreateTransactionalItemDataRequest with
// the rules defined in the proto definition for this message. If any rules
// are violated, the first error encountered is returned, or nil if there are
// no violations.
func (m *CreateTransactionalItemDataRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateTransactionalItemDataRequest
// with the rules defined in the proto definition for this message. If any
// rules are violated, the result is a list of violation errors wrapped in
// CreateTransactionalItemDataRequestMultiError, or nil if none found.
func (m *CreateTransactionalItemDataRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateTransactionalItemDataRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for AvailableForSaleDate

	// no validation rules for BatchNumber

	// no validation rules for BestBeforeDate

	// no validation rules for CountryOfOrigin

	// no validation rules for ItemExpirationDate

	// no validation rules for ItemInContactWithFoodProduct

	// no validation rules for LotNumber

	// no validation rules for PackagingDate

	// no validation rules for ProductionDate

	// no validation rules for ProductQualityIndication

	// no validation rules for SellByDate

	// no validation rules for SerialNumber

	// no validation rules for ShelfLife

	// no validation rules for TradeItemQuantity

	// no validation rules for TradeItemInventoryStatusId

	// no validation rules for UserId

	// no validation rules for UserEmail

	// no validation rules for RequestId

	if len(errors) > 0 {
		return CreateTransactionalItemDataRequestMultiError(errors)
	}

	return nil
}

// CreateTransactionalItemDataRequestMultiError is an error wrapping multiple
// validation errors returned by
// CreateTransactionalItemDataRequest.ValidateAll() if the designated
// constraints aren't met.
type CreateTransactionalItemDataRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateTransactionalItemDataRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateTransactionalItemDataRequestMultiError) AllErrors() []error { return m }

// CreateTransactionalItemDataRequestValidationError is the validation error
// returned by CreateTransactionalItemDataRequest.Validate if the designated
// constraints aren't met.
type CreateTransactionalItemDataRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateTransactionalItemDataRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateTransactionalItemDataRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateTransactionalItemDataRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateTransactionalItemDataRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateTransactionalItemDataRequestValidationError) ErrorName() string {
	return "CreateTransactionalItemDataRequestValidationError"
}

// Error satisfies the builtin error interface
func (e CreateTransactionalItemDataRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateTransactionalItemDataRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateTransactionalItemDataRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateTransactionalItemDataRequestValidationError{}

// Validate checks the field values on CreateTransactionalItemDataResponse with
// the rules defined in the proto definition for this message. If any rules
// are violated, the first error encountered is returned, or nil if there are
// no violations.
func (m *CreateTransactionalItemDataResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateTransactionalItemDataResponse
// with the rules defined in the proto definition for this message. If any
// rules are violated, the result is a list of violation errors wrapped in
// CreateTransactionalItemDataResponseMultiError, or nil if none found.
func (m *CreateTransactionalItemDataResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateTransactionalItemDataResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetTransactionalItemData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreateTransactionalItemDataResponseValidationError{
					field:  "TransactionalItemData",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreateTransactionalItemDataResponseValidationError{
					field:  "TransactionalItemData",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTransactionalItemData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreateTransactionalItemDataResponseValidationError{
				field:  "TransactionalItemData",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return CreateTransactionalItemDataResponseMultiError(errors)
	}

	return nil
}

// CreateTransactionalItemDataResponseMultiError is an error wrapping multiple
// validation errors returned by
// CreateTransactionalItemDataResponse.ValidateAll() if the designated
// constraints aren't met.
type CreateTransactionalItemDataResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateTransactionalItemDataResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateTransactionalItemDataResponseMultiError) AllErrors() []error { return m }

// CreateTransactionalItemDataResponseValidationError is the validation error
// returned by CreateTransactionalItemDataResponse.Validate if the designated
// constraints aren't met.
type CreateTransactionalItemDataResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateTransactionalItemDataResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateTransactionalItemDataResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateTransactionalItemDataResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateTransactionalItemDataResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateTransactionalItemDataResponseValidationError) ErrorName() string {
	return "CreateTransactionalItemDataResponseValidationError"
}

// Error satisfies the builtin error interface
func (e CreateTransactionalItemDataResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateTransactionalItemDataResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateTransactionalItemDataResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateTransactionalItemDataResponseValidationError{}

// Validate checks the field values on
// TransactionalItemDataCarrierAndIdentification with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *TransactionalItemDataCarrierAndIdentification) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on
// TransactionalItemDataCarrierAndIdentification with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in
// TransactionalItemDataCarrierAndIdentificationMultiError, or nil if none found.
func (m *TransactionalItemDataCarrierAndIdentification) ValidateAll() error {
	return m.validate(true)
}

func (m *TransactionalItemDataCarrierAndIdentification) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for DataCarrier

	// no validation rules for Gs1TransactionalItemIdentificationKey

	// no validation rules for TransactionalItemDataId

	if len(errors) > 0 {
		return TransactionalItemDataCarrierAndIdentificationMultiError(errors)
	}

	return nil
}

// TransactionalItemDataCarrierAndIdentificationMultiError is an error wrapping
// multiple validation errors returned by
// TransactionalItemDataCarrierAndIdentification.ValidateAll() if the
// designated constraints aren't met.
type TransactionalItemDataCarrierAndIdentificationMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TransactionalItemDataCarrierAndIdentificationMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TransactionalItemDataCarrierAndIdentificationMultiError) AllErrors() []error { return m }

// TransactionalItemDataCarrierAndIdentificationValidationError is the
// validation error returned by
// TransactionalItemDataCarrierAndIdentification.Validate if the designated
// constraints aren't met.
type TransactionalItemDataCarrierAndIdentificationValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TransactionalItemDataCarrierAndIdentificationValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TransactionalItemDataCarrierAndIdentificationValidationError) Reason() string {
	return e.reason
}

// Cause function returns cause value.
func (e TransactionalItemDataCarrierAndIdentificationValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TransactionalItemDataCarrierAndIdentificationValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TransactionalItemDataCarrierAndIdentificationValidationError) ErrorName() string {
	return "TransactionalItemDataCarrierAndIdentificationValidationError"
}

// Error satisfies the builtin error interface
func (e TransactionalItemDataCarrierAndIdentificationValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTransactionalItemDataCarrierAndIdentification.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TransactionalItemDataCarrierAndIdentificationValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TransactionalItemDataCarrierAndIdentificationValidationError{}

// Validate checks the field values on
// CreateTransactionalItemDataCarrierAndIdentificationRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CreateTransactionalItemDataCarrierAndIdentificationRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on
// CreateTransactionalItemDataCarrierAndIdentificationRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreateTransactionalItemDataCarrierAndIdentificationRequestMultiError, or
// nil if none found.
func (m *CreateTransactionalItemDataCarrierAndIdentificationRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateTransactionalItemDataCarrierAndIdentificationRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for DataCarrier

	// no validation rules for Gs1TransactionalItemIdentificationKey

	// no validation rules for TransactionalItemDataId

	// no validation rules for UserId

	// no validation rules for UserEmail

	// no validation rules for RequestId

	if len(errors) > 0 {
		return CreateTransactionalItemDataCarrierAndIdentificationRequestMultiError(errors)
	}

	return nil
}

// CreateTransactionalItemDataCarrierAndIdentificationRequestMultiError is an
// error wrapping multiple validation errors returned by
// CreateTransactionalItemDataCarrierAndIdentificationRequest.ValidateAll() if
// the designated constraints aren't met.
type CreateTransactionalItemDataCarrierAndIdentificationRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateTransactionalItemDataCarrierAndIdentificationRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateTransactionalItemDataCarrierAndIdentificationRequestMultiError) AllErrors() []error {
	return m
}

// CreateTransactionalItemDataCarrierAndIdentificationRequestValidationError is
// the validation error returned by
// CreateTransactionalItemDataCarrierAndIdentificationRequest.Validate if the
// designated constraints aren't met.
type CreateTransactionalItemDataCarrierAndIdentificationRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateTransactionalItemDataCarrierAndIdentificationRequestValidationError) Field() string {
	return e.field
}

// Reason function returns reason value.
func (e CreateTransactionalItemDataCarrierAndIdentificationRequestValidationError) Reason() string {
	return e.reason
}

// Cause function returns cause value.
func (e CreateTransactionalItemDataCarrierAndIdentificationRequestValidationError) Cause() error {
	return e.cause
}

// Key function returns key value.
func (e CreateTransactionalItemDataCarrierAndIdentificationRequestValidationError) Key() bool {
	return e.key
}

// ErrorName returns error name.
func (e CreateTransactionalItemDataCarrierAndIdentificationRequestValidationError) ErrorName() string {
	return "CreateTransactionalItemDataCarrierAndIdentificationRequestValidationError"
}

// Error satisfies the builtin error interface
func (e CreateTransactionalItemDataCarrierAndIdentificationRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateTransactionalItemDataCarrierAndIdentificationRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateTransactionalItemDataCarrierAndIdentificationRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateTransactionalItemDataCarrierAndIdentificationRequestValidationError{}

// Validate checks the field values on
// CreateTransactionalItemDataCarrierAndIdentificationResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CreateTransactionalItemDataCarrierAndIdentificationResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on
// CreateTransactionalItemDataCarrierAndIdentificationResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreateTransactionalItemDataCarrierAndIdentificationResponseMultiError, or
// nil if none found.
func (m *CreateTransactionalItemDataCarrierAndIdentificationResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateTransactionalItemDataCarrierAndIdentificationResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetTransactionalItemDataCarrierAndIdentification()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreateTransactionalItemDataCarrierAndIdentificationResponseValidationError{
					field:  "TransactionalItemDataCarrierAndIdentification",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreateTransactionalItemDataCarrierAndIdentificationResponseValidationError{
					field:  "TransactionalItemDataCarrierAndIdentification",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTransactionalItemDataCarrierAndIdentification()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreateTransactionalItemDataCarrierAndIdentificationResponseValidationError{
				field:  "TransactionalItemDataCarrierAndIdentification",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return CreateTransactionalItemDataCarrierAndIdentificationResponseMultiError(errors)
	}

	return nil
}

// CreateTransactionalItemDataCarrierAndIdentificationResponseMultiError is an
// error wrapping multiple validation errors returned by
// CreateTransactionalItemDataCarrierAndIdentificationResponse.ValidateAll()
// if the designated constraints aren't met.
type CreateTransactionalItemDataCarrierAndIdentificationResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateTransactionalItemDataCarrierAndIdentificationResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateTransactionalItemDataCarrierAndIdentificationResponseMultiError) AllErrors() []error {
	return m
}

// CreateTransactionalItemDataCarrierAndIdentificationResponseValidationError
// is the validation error returned by
// CreateTransactionalItemDataCarrierAndIdentificationResponse.Validate if the
// designated constraints aren't met.
type CreateTransactionalItemDataCarrierAndIdentificationResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateTransactionalItemDataCarrierAndIdentificationResponseValidationError) Field() string {
	return e.field
}

// Reason function returns reason value.
func (e CreateTransactionalItemDataCarrierAndIdentificationResponseValidationError) Reason() string {
	return e.reason
}

// Cause function returns cause value.
func (e CreateTransactionalItemDataCarrierAndIdentificationResponseValidationError) Cause() error {
	return e.cause
}

// Key function returns key value.
func (e CreateTransactionalItemDataCarrierAndIdentificationResponseValidationError) Key() bool {
	return e.key
}

// ErrorName returns error name.
func (e CreateTransactionalItemDataCarrierAndIdentificationResponseValidationError) ErrorName() string {
	return "CreateTransactionalItemDataCarrierAndIdentificationResponseValidationError"
}

// Error satisfies the builtin error interface
func (e CreateTransactionalItemDataCarrierAndIdentificationResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateTransactionalItemDataCarrierAndIdentificationResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateTransactionalItemDataCarrierAndIdentificationResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateTransactionalItemDataCarrierAndIdentificationResponseValidationError{}

// Validate checks the field values on TransactionalItemLogisticUnitInformation
// with the rules defined in the proto definition for this message. If any
// rules are violated, the first error encountered is returned, or nil if
// there are no violations.
func (m *TransactionalItemLogisticUnitInformation) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on
// TransactionalItemLogisticUnitInformation with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in
// TransactionalItemLogisticUnitInformationMultiError, or nil if none found.
func (m *TransactionalItemLogisticUnitInformation) ValidateAll() error {
	return m.validate(true)
}

func (m *TransactionalItemLogisticUnitInformation) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetTransactionalItemLogisticUnitInformationD()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, TransactionalItemLogisticUnitInformationValidationError{
					field:  "TransactionalItemLogisticUnitInformationD",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, TransactionalItemLogisticUnitInformationValidationError{
					field:  "TransactionalItemLogisticUnitInformationD",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTransactionalItemLogisticUnitInformationD()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return TransactionalItemLogisticUnitInformationValidationError{
				field:  "TransactionalItemLogisticUnitInformationD",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetCrUpdUser()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, TransactionalItemLogisticUnitInformationValidationError{
					field:  "CrUpdUser",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, TransactionalItemLogisticUnitInformationValidationError{
					field:  "CrUpdUser",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCrUpdUser()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return TransactionalItemLogisticUnitInformationValidationError{
				field:  "CrUpdUser",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetCrUpdTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, TransactionalItemLogisticUnitInformationValidationError{
					field:  "CrUpdTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, TransactionalItemLogisticUnitInformationValidationError{
					field:  "CrUpdTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCrUpdTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return TransactionalItemLogisticUnitInformationValidationError{
				field:  "CrUpdTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return TransactionalItemLogisticUnitInformationMultiError(errors)
	}

	return nil
}

// TransactionalItemLogisticUnitInformationMultiError is an error wrapping
// multiple validation errors returned by
// TransactionalItemLogisticUnitInformation.ValidateAll() if the designated
// constraints aren't met.
type TransactionalItemLogisticUnitInformationMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TransactionalItemLogisticUnitInformationMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TransactionalItemLogisticUnitInformationMultiError) AllErrors() []error { return m }

// TransactionalItemLogisticUnitInformationValidationError is the validation
// error returned by TransactionalItemLogisticUnitInformation.Validate if the
// designated constraints aren't met.
type TransactionalItemLogisticUnitInformationValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TransactionalItemLogisticUnitInformationValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TransactionalItemLogisticUnitInformationValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TransactionalItemLogisticUnitInformationValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TransactionalItemLogisticUnitInformationValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TransactionalItemLogisticUnitInformationValidationError) ErrorName() string {
	return "TransactionalItemLogisticUnitInformationValidationError"
}

// Error satisfies the builtin error interface
func (e TransactionalItemLogisticUnitInformationValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTransactionalItemLogisticUnitInformation.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TransactionalItemLogisticUnitInformationValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TransactionalItemLogisticUnitInformationValidationError{}

// Validate checks the field values on
// TransactionalItemLogisticUnitInformationD with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *TransactionalItemLogisticUnitInformationD) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on
// TransactionalItemLogisticUnitInformationD with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in
// TransactionalItemLogisticUnitInformationDMultiError, or nil if none found.
func (m *TransactionalItemLogisticUnitInformationD) ValidateAll() error {
	return m.validate(true)
}

func (m *TransactionalItemLogisticUnitInformationD) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for Uuid4

	// no validation rules for IdS

	// no validation rules for MaximumStackingFactor

	// no validation rules for NumberOfLayers

	// no validation rules for NumberOfUnitsPerLayer

	// no validation rules for NumberOfUnitsPerPallet

	// no validation rules for PackageTypeCode

	// no validation rules for PackagingTerms

	// no validation rules for ReturnablePackageTransportCostPayment

	// no validation rules for TransactionalItemDataId

	if len(errors) > 0 {
		return TransactionalItemLogisticUnitInformationDMultiError(errors)
	}

	return nil
}

// TransactionalItemLogisticUnitInformationDMultiError is an error wrapping
// multiple validation errors returned by
// TransactionalItemLogisticUnitInformationD.ValidateAll() if the designated
// constraints aren't met.
type TransactionalItemLogisticUnitInformationDMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TransactionalItemLogisticUnitInformationDMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TransactionalItemLogisticUnitInformationDMultiError) AllErrors() []error { return m }

// TransactionalItemLogisticUnitInformationDValidationError is the validation
// error returned by TransactionalItemLogisticUnitInformationD.Validate if the
// designated constraints aren't met.
type TransactionalItemLogisticUnitInformationDValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TransactionalItemLogisticUnitInformationDValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TransactionalItemLogisticUnitInformationDValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TransactionalItemLogisticUnitInformationDValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TransactionalItemLogisticUnitInformationDValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TransactionalItemLogisticUnitInformationDValidationError) ErrorName() string {
	return "TransactionalItemLogisticUnitInformationDValidationError"
}

// Error satisfies the builtin error interface
func (e TransactionalItemLogisticUnitInformationDValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTransactionalItemLogisticUnitInformationD.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TransactionalItemLogisticUnitInformationDValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TransactionalItemLogisticUnitInformationDValidationError{}

// Validate checks the field values on
// CreateTransactionalItemLogisticUnitInformationRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CreateTransactionalItemLogisticUnitInformationRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on
// CreateTransactionalItemLogisticUnitInformationRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreateTransactionalItemLogisticUnitInformationRequestMultiError, or nil if
// none found.
func (m *CreateTransactionalItemLogisticUnitInformationRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateTransactionalItemLogisticUnitInformationRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for MaximumStackingFactor

	// no validation rules for NumberOfLayers

	// no validation rules for NumberOfUnitsPerLayer

	// no validation rules for NumberOfUnitsPerPallet

	// no validation rules for PackageTypeCode

	// no validation rules for PackagingTerms

	// no validation rules for ReturnablePackageTransportCostPayment

	// no validation rules for TransactionalItemDataId

	// no validation rules for UserId

	// no validation rules for UserEmail

	// no validation rules for RequestId

	if len(errors) > 0 {
		return CreateTransactionalItemLogisticUnitInformationRequestMultiError(errors)
	}

	return nil
}

// CreateTransactionalItemLogisticUnitInformationRequestMultiError is an error
// wrapping multiple validation errors returned by
// CreateTransactionalItemLogisticUnitInformationRequest.ValidateAll() if the
// designated constraints aren't met.
type CreateTransactionalItemLogisticUnitInformationRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateTransactionalItemLogisticUnitInformationRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateTransactionalItemLogisticUnitInformationRequestMultiError) AllErrors() []error {
	return m
}

// CreateTransactionalItemLogisticUnitInformationRequestValidationError is the
// validation error returned by
// CreateTransactionalItemLogisticUnitInformationRequest.Validate if the
// designated constraints aren't met.
type CreateTransactionalItemLogisticUnitInformationRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateTransactionalItemLogisticUnitInformationRequestValidationError) Field() string {
	return e.field
}

// Reason function returns reason value.
func (e CreateTransactionalItemLogisticUnitInformationRequestValidationError) Reason() string {
	return e.reason
}

// Cause function returns cause value.
func (e CreateTransactionalItemLogisticUnitInformationRequestValidationError) Cause() error {
	return e.cause
}

// Key function returns key value.
func (e CreateTransactionalItemLogisticUnitInformationRequestValidationError) Key() bool {
	return e.key
}

// ErrorName returns error name.
func (e CreateTransactionalItemLogisticUnitInformationRequestValidationError) ErrorName() string {
	return "CreateTransactionalItemLogisticUnitInformationRequestValidationError"
}

// Error satisfies the builtin error interface
func (e CreateTransactionalItemLogisticUnitInformationRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateTransactionalItemLogisticUnitInformationRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateTransactionalItemLogisticUnitInformationRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateTransactionalItemLogisticUnitInformationRequestValidationError{}

// Validate checks the field values on
// CreateTransactionalItemLogisticUnitInformationResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CreateTransactionalItemLogisticUnitInformationResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on
// CreateTransactionalItemLogisticUnitInformationResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreateTransactionalItemLogisticUnitInformationResponseMultiError, or nil if
// none found.
func (m *CreateTransactionalItemLogisticUnitInformationResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateTransactionalItemLogisticUnitInformationResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetTransactionalItemLogisticUnitInformation()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreateTransactionalItemLogisticUnitInformationResponseValidationError{
					field:  "TransactionalItemLogisticUnitInformation",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreateTransactionalItemLogisticUnitInformationResponseValidationError{
					field:  "TransactionalItemLogisticUnitInformation",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTransactionalItemLogisticUnitInformation()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreateTransactionalItemLogisticUnitInformationResponseValidationError{
				field:  "TransactionalItemLogisticUnitInformation",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return CreateTransactionalItemLogisticUnitInformationResponseMultiError(errors)
	}

	return nil
}

// CreateTransactionalItemLogisticUnitInformationResponseMultiError is an error
// wrapping multiple validation errors returned by
// CreateTransactionalItemLogisticUnitInformationResponse.ValidateAll() if the
// designated constraints aren't met.
type CreateTransactionalItemLogisticUnitInformationResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateTransactionalItemLogisticUnitInformationResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateTransactionalItemLogisticUnitInformationResponseMultiError) AllErrors() []error {
	return m
}

// CreateTransactionalItemLogisticUnitInformationResponseValidationError is the
// validation error returned by
// CreateTransactionalItemLogisticUnitInformationResponse.Validate if the
// designated constraints aren't met.
type CreateTransactionalItemLogisticUnitInformationResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateTransactionalItemLogisticUnitInformationResponseValidationError) Field() string {
	return e.field
}

// Reason function returns reason value.
func (e CreateTransactionalItemLogisticUnitInformationResponseValidationError) Reason() string {
	return e.reason
}

// Cause function returns cause value.
func (e CreateTransactionalItemLogisticUnitInformationResponseValidationError) Cause() error {
	return e.cause
}

// Key function returns key value.
func (e CreateTransactionalItemLogisticUnitInformationResponseValidationError) Key() bool {
	return e.key
}

// ErrorName returns error name.
func (e CreateTransactionalItemLogisticUnitInformationResponseValidationError) ErrorName() string {
	return "CreateTransactionalItemLogisticUnitInformationResponseValidationError"
}

// Error satisfies the builtin error interface
func (e CreateTransactionalItemLogisticUnitInformationResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateTransactionalItemLogisticUnitInformationResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateTransactionalItemLogisticUnitInformationResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateTransactionalItemLogisticUnitInformationResponseValidationError{}

// Validate checks the field values on TransactionalItemOrganicInformation with
// the rules defined in the proto definition for this message. If any rules
// are violated, the first error encountered is returned, or nil if there are
// no violations.
func (m *TransactionalItemOrganicInformation) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TransactionalItemOrganicInformation
// with the rules defined in the proto definition for this message. If any
// rules are violated, the result is a list of violation errors wrapped in
// TransactionalItemOrganicInformationMultiError, or nil if none found.
func (m *TransactionalItemOrganicInformation) ValidateAll() error {
	return m.validate(true)
}

func (m *TransactionalItemOrganicInformation) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for IsTradeItemOrganic

	// no validation rules for TransactionalItemDataId

	if len(errors) > 0 {
		return TransactionalItemOrganicInformationMultiError(errors)
	}

	return nil
}

// TransactionalItemOrganicInformationMultiError is an error wrapping multiple
// validation errors returned by
// TransactionalItemOrganicInformation.ValidateAll() if the designated
// constraints aren't met.
type TransactionalItemOrganicInformationMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TransactionalItemOrganicInformationMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TransactionalItemOrganicInformationMultiError) AllErrors() []error { return m }

// TransactionalItemOrganicInformationValidationError is the validation error
// returned by TransactionalItemOrganicInformation.Validate if the designated
// constraints aren't met.
type TransactionalItemOrganicInformationValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TransactionalItemOrganicInformationValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TransactionalItemOrganicInformationValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TransactionalItemOrganicInformationValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TransactionalItemOrganicInformationValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TransactionalItemOrganicInformationValidationError) ErrorName() string {
	return "TransactionalItemOrganicInformationValidationError"
}

// Error satisfies the builtin error interface
func (e TransactionalItemOrganicInformationValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTransactionalItemOrganicInformation.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TransactionalItemOrganicInformationValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TransactionalItemOrganicInformationValidationError{}

// Validate checks the field values on
// CreateTransactionalItemOrganicInformationRequest with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *CreateTransactionalItemOrganicInformationRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on
// CreateTransactionalItemOrganicInformationRequest with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in
// CreateTransactionalItemOrganicInformationRequestMultiError, or nil if none found.
func (m *CreateTransactionalItemOrganicInformationRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateTransactionalItemOrganicInformationRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for IsTradeItemOrganic

	// no validation rules for TransactionalItemDataId

	// no validation rules for UserId

	// no validation rules for UserEmail

	// no validation rules for RequestId

	if len(errors) > 0 {
		return CreateTransactionalItemOrganicInformationRequestMultiError(errors)
	}

	return nil
}

// CreateTransactionalItemOrganicInformationRequestMultiError is an error
// wrapping multiple validation errors returned by
// CreateTransactionalItemOrganicInformationRequest.ValidateAll() if the
// designated constraints aren't met.
type CreateTransactionalItemOrganicInformationRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateTransactionalItemOrganicInformationRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateTransactionalItemOrganicInformationRequestMultiError) AllErrors() []error { return m }

// CreateTransactionalItemOrganicInformationRequestValidationError is the
// validation error returned by
// CreateTransactionalItemOrganicInformationRequest.Validate if the designated
// constraints aren't met.
type CreateTransactionalItemOrganicInformationRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateTransactionalItemOrganicInformationRequestValidationError) Field() string {
	return e.field
}

// Reason function returns reason value.
func (e CreateTransactionalItemOrganicInformationRequestValidationError) Reason() string {
	return e.reason
}

// Cause function returns cause value.
func (e CreateTransactionalItemOrganicInformationRequestValidationError) Cause() error {
	return e.cause
}

// Key function returns key value.
func (e CreateTransactionalItemOrganicInformationRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateTransactionalItemOrganicInformationRequestValidationError) ErrorName() string {
	return "CreateTransactionalItemOrganicInformationRequestValidationError"
}

// Error satisfies the builtin error interface
func (e CreateTransactionalItemOrganicInformationRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateTransactionalItemOrganicInformationRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateTransactionalItemOrganicInformationRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateTransactionalItemOrganicInformationRequestValidationError{}

// Validate checks the field values on
// CreateTransactionalItemOrganicInformationResponse with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *CreateTransactionalItemOrganicInformationResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on
// CreateTransactionalItemOrganicInformationResponse with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in
// CreateTransactionalItemOrganicInformationResponseMultiError, or nil if none found.
func (m *CreateTransactionalItemOrganicInformationResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateTransactionalItemOrganicInformationResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetTransactionalItemOrganicInformation()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreateTransactionalItemOrganicInformationResponseValidationError{
					field:  "TransactionalItemOrganicInformation",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreateTransactionalItemOrganicInformationResponseValidationError{
					field:  "TransactionalItemOrganicInformation",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTransactionalItemOrganicInformation()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreateTransactionalItemOrganicInformationResponseValidationError{
				field:  "TransactionalItemOrganicInformation",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return CreateTransactionalItemOrganicInformationResponseMultiError(errors)
	}

	return nil
}

// CreateTransactionalItemOrganicInformationResponseMultiError is an error
// wrapping multiple validation errors returned by
// CreateTransactionalItemOrganicInformationResponse.ValidateAll() if the
// designated constraints aren't met.
type CreateTransactionalItemOrganicInformationResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateTransactionalItemOrganicInformationResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateTransactionalItemOrganicInformationResponseMultiError) AllErrors() []error { return m }

// CreateTransactionalItemOrganicInformationResponseValidationError is the
// validation error returned by
// CreateTransactionalItemOrganicInformationResponse.Validate if the
// designated constraints aren't met.
type CreateTransactionalItemOrganicInformationResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateTransactionalItemOrganicInformationResponseValidationError) Field() string {
	return e.field
}

// Reason function returns reason value.
func (e CreateTransactionalItemOrganicInformationResponseValidationError) Reason() string {
	return e.reason
}

// Cause function returns cause value.
func (e CreateTransactionalItemOrganicInformationResponseValidationError) Cause() error {
	return e.cause
}

// Key function returns key value.
func (e CreateTransactionalItemOrganicInformationResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateTransactionalItemOrganicInformationResponseValidationError) ErrorName() string {
	return "CreateTransactionalItemOrganicInformationResponseValidationError"
}

// Error satisfies the builtin error interface
func (e CreateTransactionalItemOrganicInformationResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateTransactionalItemOrganicInformationResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateTransactionalItemOrganicInformationResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateTransactionalItemOrganicInformationResponseValidationError{}

// Validate checks the field values on TransactionalReference with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *TransactionalReference) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TransactionalReference with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// TransactionalReferenceMultiError, or nil if none found.
func (m *TransactionalReference) ValidateAll() error {
	return m.validate(true)
}

func (m *TransactionalReference) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for TransactionalReferenceTypeCode

	// no validation rules for EcomDocumentReference

	if len(errors) > 0 {
		return TransactionalReferenceMultiError(errors)
	}

	return nil
}

// TransactionalReferenceMultiError is an error wrapping multiple validation
// errors returned by TransactionalReference.ValidateAll() if the designated
// constraints aren't met.
type TransactionalReferenceMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TransactionalReferenceMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TransactionalReferenceMultiError) AllErrors() []error { return m }

// TransactionalReferenceValidationError is the validation error returned by
// TransactionalReference.Validate if the designated constraints aren't met.
type TransactionalReferenceValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TransactionalReferenceValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TransactionalReferenceValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TransactionalReferenceValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TransactionalReferenceValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TransactionalReferenceValidationError) ErrorName() string {
	return "TransactionalReferenceValidationError"
}

// Error satisfies the builtin error interface
func (e TransactionalReferenceValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTransactionalReference.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TransactionalReferenceValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TransactionalReferenceValidationError{}

// Validate checks the field values on CreateTransactionalReferenceRequest with
// the rules defined in the proto definition for this message. If any rules
// are violated, the first error encountered is returned, or nil if there are
// no violations.
func (m *CreateTransactionalReferenceRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateTransactionalReferenceRequest
// with the rules defined in the proto definition for this message. If any
// rules are violated, the result is a list of violation errors wrapped in
// CreateTransactionalReferenceRequestMultiError, or nil if none found.
func (m *CreateTransactionalReferenceRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateTransactionalReferenceRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for TransactionalReferenceTypeCode

	// no validation rules for EcomDocumentReference

	// no validation rules for UserId

	// no validation rules for UserEmail

	// no validation rules for RequestId

	if len(errors) > 0 {
		return CreateTransactionalReferenceRequestMultiError(errors)
	}

	return nil
}

// CreateTransactionalReferenceRequestMultiError is an error wrapping multiple
// validation errors returned by
// CreateTransactionalReferenceRequest.ValidateAll() if the designated
// constraints aren't met.
type CreateTransactionalReferenceRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateTransactionalReferenceRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateTransactionalReferenceRequestMultiError) AllErrors() []error { return m }

// CreateTransactionalReferenceRequestValidationError is the validation error
// returned by CreateTransactionalReferenceRequest.Validate if the designated
// constraints aren't met.
type CreateTransactionalReferenceRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateTransactionalReferenceRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateTransactionalReferenceRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateTransactionalReferenceRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateTransactionalReferenceRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateTransactionalReferenceRequestValidationError) ErrorName() string {
	return "CreateTransactionalReferenceRequestValidationError"
}

// Error satisfies the builtin error interface
func (e CreateTransactionalReferenceRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateTransactionalReferenceRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateTransactionalReferenceRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateTransactionalReferenceRequestValidationError{}

// Validate checks the field values on CreateTransactionalReferenceResponse
// with the rules defined in the proto definition for this message. If any
// rules are violated, the first error encountered is returned, or nil if
// there are no violations.
func (m *CreateTransactionalReferenceResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateTransactionalReferenceResponse
// with the rules defined in the proto definition for this message. If any
// rules are violated, the result is a list of violation errors wrapped in
// CreateTransactionalReferenceResponseMultiError, or nil if none found.
func (m *CreateTransactionalReferenceResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateTransactionalReferenceResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetTransactionalReference()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreateTransactionalReferenceResponseValidationError{
					field:  "TransactionalReference",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreateTransactionalReferenceResponseValidationError{
					field:  "TransactionalReference",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTransactionalReference()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreateTransactionalReferenceResponseValidationError{
				field:  "TransactionalReference",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return CreateTransactionalReferenceResponseMultiError(errors)
	}

	return nil
}

// CreateTransactionalReferenceResponseMultiError is an error wrapping multiple
// validation errors returned by
// CreateTransactionalReferenceResponse.ValidateAll() if the designated
// constraints aren't met.
type CreateTransactionalReferenceResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateTransactionalReferenceResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateTransactionalReferenceResponseMultiError) AllErrors() []error { return m }

// CreateTransactionalReferenceResponseValidationError is the validation error
// returned by CreateTransactionalReferenceResponse.Validate if the designated
// constraints aren't met.
type CreateTransactionalReferenceResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateTransactionalReferenceResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateTransactionalReferenceResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateTransactionalReferenceResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateTransactionalReferenceResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateTransactionalReferenceResponseValidationError) ErrorName() string {
	return "CreateTransactionalReferenceResponseValidationError"
}

// Error satisfies the builtin error interface
func (e CreateTransactionalReferenceResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateTransactionalReferenceResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateTransactionalReferenceResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateTransactionalReferenceResponseValidationError{}

// Validate checks the field values on TransportEquipmentInventoryEvent with
// the rules defined in the proto definition for this message. If any rules
// are violated, the first error encountered is returned, or nil if there are
// no violations.
func (m *TransportEquipmentInventoryEvent) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TransportEquipmentInventoryEvent with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// TransportEquipmentInventoryEventMultiError, or nil if none found.
func (m *TransportEquipmentInventoryEvent) ValidateAll() error {
	return m.validate(true)
}

func (m *TransportEquipmentInventoryEvent) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetTransportEquipmentInventoryEventD()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, TransportEquipmentInventoryEventValidationError{
					field:  "TransportEquipmentInventoryEventD",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, TransportEquipmentInventoryEventValidationError{
					field:  "TransportEquipmentInventoryEventD",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTransportEquipmentInventoryEventD()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return TransportEquipmentInventoryEventValidationError{
				field:  "TransportEquipmentInventoryEventD",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetTransportEquipmentInventoryEventT()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, TransportEquipmentInventoryEventValidationError{
					field:  "TransportEquipmentInventoryEventT",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, TransportEquipmentInventoryEventValidationError{
					field:  "TransportEquipmentInventoryEventT",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTransportEquipmentInventoryEventT()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return TransportEquipmentInventoryEventValidationError{
				field:  "TransportEquipmentInventoryEventT",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetCrUpdUser()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, TransportEquipmentInventoryEventValidationError{
					field:  "CrUpdUser",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, TransportEquipmentInventoryEventValidationError{
					field:  "CrUpdUser",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCrUpdUser()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return TransportEquipmentInventoryEventValidationError{
				field:  "CrUpdUser",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetCrUpdTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, TransportEquipmentInventoryEventValidationError{
					field:  "CrUpdTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, TransportEquipmentInventoryEventValidationError{
					field:  "CrUpdTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCrUpdTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return TransportEquipmentInventoryEventValidationError{
				field:  "CrUpdTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return TransportEquipmentInventoryEventMultiError(errors)
	}

	return nil
}

// TransportEquipmentInventoryEventMultiError is an error wrapping multiple
// validation errors returned by
// TransportEquipmentInventoryEvent.ValidateAll() if the designated
// constraints aren't met.
type TransportEquipmentInventoryEventMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TransportEquipmentInventoryEventMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TransportEquipmentInventoryEventMultiError) AllErrors() []error { return m }

// TransportEquipmentInventoryEventValidationError is the validation error
// returned by TransportEquipmentInventoryEvent.Validate if the designated
// constraints aren't met.
type TransportEquipmentInventoryEventValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TransportEquipmentInventoryEventValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TransportEquipmentInventoryEventValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TransportEquipmentInventoryEventValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TransportEquipmentInventoryEventValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TransportEquipmentInventoryEventValidationError) ErrorName() string {
	return "TransportEquipmentInventoryEventValidationError"
}

// Error satisfies the builtin error interface
func (e TransportEquipmentInventoryEventValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTransportEquipmentInventoryEvent.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TransportEquipmentInventoryEventValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TransportEquipmentInventoryEventValidationError{}

// Validate checks the field values on TransportEquipmentInventoryEventD with
// the rules defined in the proto definition for this message. If any rules
// are violated, the first error encountered is returned, or nil if there are
// no violations.
func (m *TransportEquipmentInventoryEventD) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TransportEquipmentInventoryEventD
// with the rules defined in the proto definition for this message. If any
// rules are violated, the result is a list of violation errors wrapped in
// TransportEquipmentInventoryEventDMultiError, or nil if none found.
func (m *TransportEquipmentInventoryEventD) ValidateAll() error {
	return m.validate(true)
}

func (m *TransportEquipmentInventoryEventD) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for Uuid4

	// no validation rules for IdS

	// no validation rules for EventIdentifier

	// no validation rules for InventoryBusinessStepCode

	// no validation rules for InventoryDispositionCode

	// no validation rules for InventoryEventReasonCode

	// no validation rules for InventoryMovementTypeCode

	// no validation rules for NumberOfPiecesOfEquipment

	// no validation rules for InventorySubLocationId

	if len(errors) > 0 {
		return TransportEquipmentInventoryEventDMultiError(errors)
	}

	return nil
}

// TransportEquipmentInventoryEventDMultiError is an error wrapping multiple
// validation errors returned by
// TransportEquipmentInventoryEventD.ValidateAll() if the designated
// constraints aren't met.
type TransportEquipmentInventoryEventDMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TransportEquipmentInventoryEventDMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TransportEquipmentInventoryEventDMultiError) AllErrors() []error { return m }

// TransportEquipmentInventoryEventDValidationError is the validation error
// returned by TransportEquipmentInventoryEventD.Validate if the designated
// constraints aren't met.
type TransportEquipmentInventoryEventDValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TransportEquipmentInventoryEventDValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TransportEquipmentInventoryEventDValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TransportEquipmentInventoryEventDValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TransportEquipmentInventoryEventDValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TransportEquipmentInventoryEventDValidationError) ErrorName() string {
	return "TransportEquipmentInventoryEventDValidationError"
}

// Error satisfies the builtin error interface
func (e TransportEquipmentInventoryEventDValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTransportEquipmentInventoryEventD.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TransportEquipmentInventoryEventDValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TransportEquipmentInventoryEventDValidationError{}

// Validate checks the field values on TransportEquipmentInventoryEventT with
// the rules defined in the proto definition for this message. If any rules
// are violated, the first error encountered is returned, or nil if there are
// no violations.
func (m *TransportEquipmentInventoryEventT) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TransportEquipmentInventoryEventT
// with the rules defined in the proto definition for this message. If any
// rules are violated, the result is a list of violation errors wrapped in
// TransportEquipmentInventoryEventTMultiError, or nil if none found.
func (m *TransportEquipmentInventoryEventT) ValidateAll() error {
	return m.validate(true)
}

func (m *TransportEquipmentInventoryEventT) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetEventDateTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, TransportEquipmentInventoryEventTValidationError{
					field:  "EventDateTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, TransportEquipmentInventoryEventTValidationError{
					field:  "EventDateTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetEventDateTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return TransportEquipmentInventoryEventTValidationError{
				field:  "EventDateTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return TransportEquipmentInventoryEventTMultiError(errors)
	}

	return nil
}

// TransportEquipmentInventoryEventTMultiError is an error wrapping multiple
// validation errors returned by
// TransportEquipmentInventoryEventT.ValidateAll() if the designated
// constraints aren't met.
type TransportEquipmentInventoryEventTMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TransportEquipmentInventoryEventTMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TransportEquipmentInventoryEventTMultiError) AllErrors() []error { return m }

// TransportEquipmentInventoryEventTValidationError is the validation error
// returned by TransportEquipmentInventoryEventT.Validate if the designated
// constraints aren't met.
type TransportEquipmentInventoryEventTValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TransportEquipmentInventoryEventTValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TransportEquipmentInventoryEventTValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TransportEquipmentInventoryEventTValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TransportEquipmentInventoryEventTValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TransportEquipmentInventoryEventTValidationError) ErrorName() string {
	return "TransportEquipmentInventoryEventTValidationError"
}

// Error satisfies the builtin error interface
func (e TransportEquipmentInventoryEventTValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTransportEquipmentInventoryEventT.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TransportEquipmentInventoryEventTValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TransportEquipmentInventoryEventTValidationError{}

// Validate checks the field values on
// CreateTransportEquipmentInventoryEventRequest with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *CreateTransportEquipmentInventoryEventRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on
// CreateTransportEquipmentInventoryEventRequest with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in
// CreateTransportEquipmentInventoryEventRequestMultiError, or nil if none found.
func (m *CreateTransportEquipmentInventoryEventRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateTransportEquipmentInventoryEventRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for EventDateTime

	// no validation rules for EventIdentifier

	// no validation rules for InventoryBusinessStepCode

	// no validation rules for InventoryDispositionCode

	// no validation rules for InventoryEventReasonCode

	// no validation rules for InventoryMovementTypeCode

	// no validation rules for NumberOfPiecesOfEquipment

	// no validation rules for InventorySubLocationId

	// no validation rules for UserId

	// no validation rules for UserEmail

	// no validation rules for RequestId

	if len(errors) > 0 {
		return CreateTransportEquipmentInventoryEventRequestMultiError(errors)
	}

	return nil
}

// CreateTransportEquipmentInventoryEventRequestMultiError is an error wrapping
// multiple validation errors returned by
// CreateTransportEquipmentInventoryEventRequest.ValidateAll() if the
// designated constraints aren't met.
type CreateTransportEquipmentInventoryEventRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateTransportEquipmentInventoryEventRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateTransportEquipmentInventoryEventRequestMultiError) AllErrors() []error { return m }

// CreateTransportEquipmentInventoryEventRequestValidationError is the
// validation error returned by
// CreateTransportEquipmentInventoryEventRequest.Validate if the designated
// constraints aren't met.
type CreateTransportEquipmentInventoryEventRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateTransportEquipmentInventoryEventRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateTransportEquipmentInventoryEventRequestValidationError) Reason() string {
	return e.reason
}

// Cause function returns cause value.
func (e CreateTransportEquipmentInventoryEventRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateTransportEquipmentInventoryEventRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateTransportEquipmentInventoryEventRequestValidationError) ErrorName() string {
	return "CreateTransportEquipmentInventoryEventRequestValidationError"
}

// Error satisfies the builtin error interface
func (e CreateTransportEquipmentInventoryEventRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateTransportEquipmentInventoryEventRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateTransportEquipmentInventoryEventRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateTransportEquipmentInventoryEventRequestValidationError{}

// Validate checks the field values on
// CreateTransportEquipmentInventoryEventResponse with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *CreateTransportEquipmentInventoryEventResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on
// CreateTransportEquipmentInventoryEventResponse with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in
// CreateTransportEquipmentInventoryEventResponseMultiError, or nil if none found.
func (m *CreateTransportEquipmentInventoryEventResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateTransportEquipmentInventoryEventResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetTransportEquipmentInventoryEvent()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreateTransportEquipmentInventoryEventResponseValidationError{
					field:  "TransportEquipmentInventoryEvent",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreateTransportEquipmentInventoryEventResponseValidationError{
					field:  "TransportEquipmentInventoryEvent",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTransportEquipmentInventoryEvent()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreateTransportEquipmentInventoryEventResponseValidationError{
				field:  "TransportEquipmentInventoryEvent",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return CreateTransportEquipmentInventoryEventResponseMultiError(errors)
	}

	return nil
}

// CreateTransportEquipmentInventoryEventResponseMultiError is an error
// wrapping multiple validation errors returned by
// CreateTransportEquipmentInventoryEventResponse.ValidateAll() if the
// designated constraints aren't met.
type CreateTransportEquipmentInventoryEventResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateTransportEquipmentInventoryEventResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateTransportEquipmentInventoryEventResponseMultiError) AllErrors() []error { return m }

// CreateTransportEquipmentInventoryEventResponseValidationError is the
// validation error returned by
// CreateTransportEquipmentInventoryEventResponse.Validate if the designated
// constraints aren't met.
type CreateTransportEquipmentInventoryEventResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateTransportEquipmentInventoryEventResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateTransportEquipmentInventoryEventResponseValidationError) Reason() string {
	return e.reason
}

// Cause function returns cause value.
func (e CreateTransportEquipmentInventoryEventResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateTransportEquipmentInventoryEventResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateTransportEquipmentInventoryEventResponseValidationError) ErrorName() string {
	return "CreateTransportEquipmentInventoryEventResponseValidationError"
}

// Error satisfies the builtin error interface
func (e CreateTransportEquipmentInventoryEventResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateTransportEquipmentInventoryEventResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateTransportEquipmentInventoryEventResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateTransportEquipmentInventoryEventResponseValidationError{}

// Validate checks the field values on TransportEquipmentInventoryStatus with
// the rules defined in the proto definition for this message. If any rules
// are violated, the first error encountered is returned, or nil if there are
// no violations.
func (m *TransportEquipmentInventoryStatus) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TransportEquipmentInventoryStatus
// with the rules defined in the proto definition for this message. If any
// rules are violated, the result is a list of violation errors wrapped in
// TransportEquipmentInventoryStatusMultiError, or nil if none found.
func (m *TransportEquipmentInventoryStatus) ValidateAll() error {
	return m.validate(true)
}

func (m *TransportEquipmentInventoryStatus) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetTransportEquipmentInventoryStatusD()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, TransportEquipmentInventoryStatusValidationError{
					field:  "TransportEquipmentInventoryStatusD",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, TransportEquipmentInventoryStatusValidationError{
					field:  "TransportEquipmentInventoryStatusD",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTransportEquipmentInventoryStatusD()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return TransportEquipmentInventoryStatusValidationError{
				field:  "TransportEquipmentInventoryStatusD",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetTransportEquipmentInventoryStatusT()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, TransportEquipmentInventoryStatusValidationError{
					field:  "TransportEquipmentInventoryStatusT",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, TransportEquipmentInventoryStatusValidationError{
					field:  "TransportEquipmentInventoryStatusT",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTransportEquipmentInventoryStatusT()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return TransportEquipmentInventoryStatusValidationError{
				field:  "TransportEquipmentInventoryStatusT",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return TransportEquipmentInventoryStatusMultiError(errors)
	}

	return nil
}

// TransportEquipmentInventoryStatusMultiError is an error wrapping multiple
// validation errors returned by
// TransportEquipmentInventoryStatus.ValidateAll() if the designated
// constraints aren't met.
type TransportEquipmentInventoryStatusMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TransportEquipmentInventoryStatusMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TransportEquipmentInventoryStatusMultiError) AllErrors() []error { return m }

// TransportEquipmentInventoryStatusValidationError is the validation error
// returned by TransportEquipmentInventoryStatus.Validate if the designated
// constraints aren't met.
type TransportEquipmentInventoryStatusValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TransportEquipmentInventoryStatusValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TransportEquipmentInventoryStatusValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TransportEquipmentInventoryStatusValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TransportEquipmentInventoryStatusValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TransportEquipmentInventoryStatusValidationError) ErrorName() string {
	return "TransportEquipmentInventoryStatusValidationError"
}

// Error satisfies the builtin error interface
func (e TransportEquipmentInventoryStatusValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTransportEquipmentInventoryStatus.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TransportEquipmentInventoryStatusValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TransportEquipmentInventoryStatusValidationError{}

// Validate checks the field values on TransportEquipmentInventoryStatusD with
// the rules defined in the proto definition for this message. If any rules
// are violated, the first error encountered is returned, or nil if there are
// no violations.
func (m *TransportEquipmentInventoryStatusD) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TransportEquipmentInventoryStatusD
// with the rules defined in the proto definition for this message. If any
// rules are violated, the result is a list of violation errors wrapped in
// TransportEquipmentInventoryStatusDMultiError, or nil if none found.
func (m *TransportEquipmentInventoryStatusD) ValidateAll() error {
	return m.validate(true)
}

func (m *TransportEquipmentInventoryStatusD) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for InventoryDispositionCode

	// no validation rules for NumberOfPiecesOfEquipment

	// no validation rules for InventorySubLocationId

	if len(errors) > 0 {
		return TransportEquipmentInventoryStatusDMultiError(errors)
	}

	return nil
}

// TransportEquipmentInventoryStatusDMultiError is an error wrapping multiple
// validation errors returned by
// TransportEquipmentInventoryStatusD.ValidateAll() if the designated
// constraints aren't met.
type TransportEquipmentInventoryStatusDMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TransportEquipmentInventoryStatusDMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TransportEquipmentInventoryStatusDMultiError) AllErrors() []error { return m }

// TransportEquipmentInventoryStatusDValidationError is the validation error
// returned by TransportEquipmentInventoryStatusD.Validate if the designated
// constraints aren't met.
type TransportEquipmentInventoryStatusDValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TransportEquipmentInventoryStatusDValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TransportEquipmentInventoryStatusDValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TransportEquipmentInventoryStatusDValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TransportEquipmentInventoryStatusDValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TransportEquipmentInventoryStatusDValidationError) ErrorName() string {
	return "TransportEquipmentInventoryStatusDValidationError"
}

// Error satisfies the builtin error interface
func (e TransportEquipmentInventoryStatusDValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTransportEquipmentInventoryStatusD.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TransportEquipmentInventoryStatusDValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TransportEquipmentInventoryStatusDValidationError{}

// Validate checks the field values on TransportEquipmentInventoryStatusT with
// the rules defined in the proto definition for this message. If any rules
// are violated, the first error encountered is returned, or nil if there are
// no violations.
func (m *TransportEquipmentInventoryStatusT) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TransportEquipmentInventoryStatusT
// with the rules defined in the proto definition for this message. If any
// rules are violated, the result is a list of violation errors wrapped in
// TransportEquipmentInventoryStatusTMultiError, or nil if none found.
func (m *TransportEquipmentInventoryStatusT) ValidateAll() error {
	return m.validate(true)
}

func (m *TransportEquipmentInventoryStatusT) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetInventoryDateTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, TransportEquipmentInventoryStatusTValidationError{
					field:  "InventoryDateTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, TransportEquipmentInventoryStatusTValidationError{
					field:  "InventoryDateTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetInventoryDateTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return TransportEquipmentInventoryStatusTValidationError{
				field:  "InventoryDateTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return TransportEquipmentInventoryStatusTMultiError(errors)
	}

	return nil
}

// TransportEquipmentInventoryStatusTMultiError is an error wrapping multiple
// validation errors returned by
// TransportEquipmentInventoryStatusT.ValidateAll() if the designated
// constraints aren't met.
type TransportEquipmentInventoryStatusTMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TransportEquipmentInventoryStatusTMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TransportEquipmentInventoryStatusTMultiError) AllErrors() []error { return m }

// TransportEquipmentInventoryStatusTValidationError is the validation error
// returned by TransportEquipmentInventoryStatusT.Validate if the designated
// constraints aren't met.
type TransportEquipmentInventoryStatusTValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TransportEquipmentInventoryStatusTValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TransportEquipmentInventoryStatusTValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TransportEquipmentInventoryStatusTValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TransportEquipmentInventoryStatusTValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TransportEquipmentInventoryStatusTValidationError) ErrorName() string {
	return "TransportEquipmentInventoryStatusTValidationError"
}

// Error satisfies the builtin error interface
func (e TransportEquipmentInventoryStatusTValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTransportEquipmentInventoryStatusT.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TransportEquipmentInventoryStatusTValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TransportEquipmentInventoryStatusTValidationError{}

// Validate checks the field values on
// CreateTransportEquipmentInventoryStatusRequest with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *CreateTransportEquipmentInventoryStatusRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on
// CreateTransportEquipmentInventoryStatusRequest with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in
// CreateTransportEquipmentInventoryStatusRequestMultiError, or nil if none found.
func (m *CreateTransportEquipmentInventoryStatusRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateTransportEquipmentInventoryStatusRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for InventoryDateTime

	// no validation rules for InventoryDispositionCode

	// no validation rules for NumberOfPiecesOfEquipment

	// no validation rules for InventorySubLocationId

	// no validation rules for UserId

	// no validation rules for UserEmail

	// no validation rules for RequestId

	if len(errors) > 0 {
		return CreateTransportEquipmentInventoryStatusRequestMultiError(errors)
	}

	return nil
}

// CreateTransportEquipmentInventoryStatusRequestMultiError is an error
// wrapping multiple validation errors returned by
// CreateTransportEquipmentInventoryStatusRequest.ValidateAll() if the
// designated constraints aren't met.
type CreateTransportEquipmentInventoryStatusRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateTransportEquipmentInventoryStatusRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateTransportEquipmentInventoryStatusRequestMultiError) AllErrors() []error { return m }

// CreateTransportEquipmentInventoryStatusRequestValidationError is the
// validation error returned by
// CreateTransportEquipmentInventoryStatusRequest.Validate if the designated
// constraints aren't met.
type CreateTransportEquipmentInventoryStatusRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateTransportEquipmentInventoryStatusRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateTransportEquipmentInventoryStatusRequestValidationError) Reason() string {
	return e.reason
}

// Cause function returns cause value.
func (e CreateTransportEquipmentInventoryStatusRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateTransportEquipmentInventoryStatusRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateTransportEquipmentInventoryStatusRequestValidationError) ErrorName() string {
	return "CreateTransportEquipmentInventoryStatusRequestValidationError"
}

// Error satisfies the builtin error interface
func (e CreateTransportEquipmentInventoryStatusRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateTransportEquipmentInventoryStatusRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateTransportEquipmentInventoryStatusRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateTransportEquipmentInventoryStatusRequestValidationError{}

// Validate checks the field values on
// CreateTransportEquipmentInventoryStatusResponse with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *CreateTransportEquipmentInventoryStatusResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on
// CreateTransportEquipmentInventoryStatusResponse with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in
// CreateTransportEquipmentInventoryStatusResponseMultiError, or nil if none found.
func (m *CreateTransportEquipmentInventoryStatusResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateTransportEquipmentInventoryStatusResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetTransportEquipmentInventoryStatus()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreateTransportEquipmentInventoryStatusResponseValidationError{
					field:  "TransportEquipmentInventoryStatus",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreateTransportEquipmentInventoryStatusResponseValidationError{
					field:  "TransportEquipmentInventoryStatus",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTransportEquipmentInventoryStatus()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreateTransportEquipmentInventoryStatusResponseValidationError{
				field:  "TransportEquipmentInventoryStatus",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return CreateTransportEquipmentInventoryStatusResponseMultiError(errors)
	}

	return nil
}

// CreateTransportEquipmentInventoryStatusResponseMultiError is an error
// wrapping multiple validation errors returned by
// CreateTransportEquipmentInventoryStatusResponse.ValidateAll() if the
// designated constraints aren't met.
type CreateTransportEquipmentInventoryStatusResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateTransportEquipmentInventoryStatusResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateTransportEquipmentInventoryStatusResponseMultiError) AllErrors() []error { return m }

// CreateTransportEquipmentInventoryStatusResponseValidationError is the
// validation error returned by
// CreateTransportEquipmentInventoryStatusResponse.Validate if the designated
// constraints aren't met.
type CreateTransportEquipmentInventoryStatusResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateTransportEquipmentInventoryStatusResponseValidationError) Field() string {
	return e.field
}

// Reason function returns reason value.
func (e CreateTransportEquipmentInventoryStatusResponseValidationError) Reason() string {
	return e.reason
}

// Cause function returns cause value.
func (e CreateTransportEquipmentInventoryStatusResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateTransportEquipmentInventoryStatusResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateTransportEquipmentInventoryStatusResponseValidationError) ErrorName() string {
	return "CreateTransportEquipmentInventoryStatusResponseValidationError"
}

// Error satisfies the builtin error interface
func (e CreateTransportEquipmentInventoryStatusResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateTransportEquipmentInventoryStatusResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateTransportEquipmentInventoryStatusResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateTransportEquipmentInventoryStatusResponseValidationError{}
