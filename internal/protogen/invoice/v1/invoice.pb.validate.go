// Code generated by protoc-gen-validate. DO NOT EDIT.
// source: invoice/v1/invoice.proto

package v1

import (
	"bytes"
	"errors"
	"fmt"
	"net"
	"net/mail"
	"net/url"
	"regexp"
	"sort"
	"strings"
	"time"
	"unicode/utf8"

	"google.golang.org/protobuf/types/known/anypb"
)

// ensure the imports are used
var (
	_ = bytes.MinRead
	_ = errors.New("")
	_ = fmt.Print
	_ = utf8.UTFMax
	_ = (*regexp.Regexp)(nil)
	_ = (*strings.Reader)(nil)
	_ = net.IPv4len
	_ = time.Duration(0)
	_ = (*url.URL)(nil)
	_ = (*mail.Address)(nil)
	_ = anypb.Any{}
	_ = sort.Sort
)

// Validate checks the field values on Invoice with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Invoice) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Invoice with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in InvoiceMultiError, or nil if none found.
func (m *Invoice) ValidateAll() error {
	return m.validate(true)
}

func (m *Invoice) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetInvoiceD()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, InvoiceValidationError{
					field:  "InvoiceD",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, InvoiceValidationError{
					field:  "InvoiceD",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetInvoiceD()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return InvoiceValidationError{
				field:  "InvoiceD",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetInvoiceT()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, InvoiceValidationError{
					field:  "InvoiceT",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, InvoiceValidationError{
					field:  "InvoiceT",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetInvoiceT()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return InvoiceValidationError{
				field:  "InvoiceT",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetCrUpdUser()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, InvoiceValidationError{
					field:  "CrUpdUser",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, InvoiceValidationError{
					field:  "CrUpdUser",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCrUpdUser()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return InvoiceValidationError{
				field:  "CrUpdUser",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetCrUpdTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, InvoiceValidationError{
					field:  "CrUpdTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, InvoiceValidationError{
					field:  "CrUpdTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCrUpdTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return InvoiceValidationError{
				field:  "CrUpdTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return InvoiceMultiError(errors)
	}

	return nil
}

// InvoiceMultiError is an error wrapping multiple validation errors returned
// by Invoice.ValidateAll() if the designated constraints aren't met.
type InvoiceMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m InvoiceMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m InvoiceMultiError) AllErrors() []error { return m }

// InvoiceValidationError is the validation error returned by Invoice.Validate
// if the designated constraints aren't met.
type InvoiceValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e InvoiceValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e InvoiceValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e InvoiceValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e InvoiceValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e InvoiceValidationError) ErrorName() string { return "InvoiceValidationError" }

// Error satisfies the builtin error interface
func (e InvoiceValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sInvoice.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = InvoiceValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = InvoiceValidationError{}

// Validate checks the field values on InvoiceD with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *InvoiceD) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on InvoiceD with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in InvoiceDMultiError, or nil
// if none found.
func (m *InvoiceD) ValidateAll() error {
	return m.validate(true)
}

func (m *InvoiceD) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for Uuid4

	// no validation rules for IdS

	// no validation rules for CountryOfSupplyOfGoods

	// no validation rules for CreditReasonCode

	// no validation rules for DiscountAgreementTerms

	// no validation rules for InvoiceCurrencyCode

	// no validation rules for InvoiceType

	// no validation rules for IsBuyerBasedInEu

	// no validation rules for IsFirstSellerBasedInEu

	// no validation rules for SupplierAccountReceivable

	// no validation rules for BlanketOrder

	// no validation rules for Buyer

	// no validation rules for Contract

	// no validation rules for DeliveryNote

	// no validation rules for DespatchAdvice

	// no validation rules for DisputeNotice

	// no validation rules for InventoryLocation

	// no validation rules for InventoryReport

	// no validation rules for Invoice

	// no validation rules for InvoiceIdentification

	// no validation rules for Manifest

	// no validation rules for OrderResponse

	// no validation rules for Payee

	// no validation rules for Payer

	// no validation rules for PickupFrom

	// no validation rules for PriceList

	// no validation rules for PromotionalDeal

	// no validation rules for PurchaseOrder

	// no validation rules for ReceivingAdvice

	// no validation rules for RemitTo

	// no validation rules for ReturnsNotice

	// no validation rules for SalesOrder

	// no validation rules for SalesReport

	// no validation rules for Seller

	// no validation rules for ShipFrom

	// no validation rules for ShipTo

	// no validation rules for SupplierAgentRepresentative

	// no validation rules for SupplierCorporateOffice

	// no validation rules for TaxCurrencyInformation

	// no validation rules for TaxRepresentative

	// no validation rules for TradeAgreement

	// no validation rules for UltimateConsignee

	if len(errors) > 0 {
		return InvoiceDMultiError(errors)
	}

	return nil
}

// InvoiceDMultiError is an error wrapping multiple validation errors returned
// by InvoiceD.ValidateAll() if the designated constraints aren't met.
type InvoiceDMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m InvoiceDMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m InvoiceDMultiError) AllErrors() []error { return m }

// InvoiceDValidationError is the validation error returned by
// InvoiceD.Validate if the designated constraints aren't met.
type InvoiceDValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e InvoiceDValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e InvoiceDValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e InvoiceDValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e InvoiceDValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e InvoiceDValidationError) ErrorName() string { return "InvoiceDValidationError" }

// Error satisfies the builtin error interface
func (e InvoiceDValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sInvoiceD.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = InvoiceDValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = InvoiceDValidationError{}

// Validate checks the field values on InvoiceT with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *InvoiceT) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on InvoiceT with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in InvoiceTMultiError, or nil
// if none found.
func (m *InvoiceT) ValidateAll() error {
	return m.validate(true)
}

func (m *InvoiceT) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetActualDeliveryDate()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, InvoiceTValidationError{
					field:  "ActualDeliveryDate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, InvoiceTValidationError{
					field:  "ActualDeliveryDate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetActualDeliveryDate()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return InvoiceTValidationError{
				field:  "ActualDeliveryDate",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetInvoicingPeriodBegin()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, InvoiceTValidationError{
					field:  "InvoicingPeriodBegin",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, InvoiceTValidationError{
					field:  "InvoicingPeriodBegin",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetInvoicingPeriodBegin()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return InvoiceTValidationError{
				field:  "InvoicingPeriodBegin",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetInvoicingPeriodEnd()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, InvoiceTValidationError{
					field:  "InvoicingPeriodEnd",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, InvoiceTValidationError{
					field:  "InvoicingPeriodEnd",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetInvoicingPeriodEnd()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return InvoiceTValidationError{
				field:  "InvoicingPeriodEnd",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return InvoiceTMultiError(errors)
	}

	return nil
}

// InvoiceTMultiError is an error wrapping multiple validation errors returned
// by InvoiceT.ValidateAll() if the designated constraints aren't met.
type InvoiceTMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m InvoiceTMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m InvoiceTMultiError) AllErrors() []error { return m }

// InvoiceTValidationError is the validation error returned by
// InvoiceT.Validate if the designated constraints aren't met.
type InvoiceTValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e InvoiceTValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e InvoiceTValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e InvoiceTValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e InvoiceTValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e InvoiceTValidationError) ErrorName() string { return "InvoiceTValidationError" }

// Error satisfies the builtin error interface
func (e InvoiceTValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sInvoiceT.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = InvoiceTValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = InvoiceTValidationError{}

// Validate checks the field values on CreateInvoiceRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CreateInvoiceRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateInvoiceRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreateInvoiceRequestMultiError, or nil if none found.
func (m *CreateInvoiceRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateInvoiceRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for CountryOfSupplyOfGoods

	// no validation rules for CreditReasonCode

	// no validation rules for DiscountAgreementTerms

	// no validation rules for InvoiceCurrencyCode

	// no validation rules for InvoiceType

	// no validation rules for IsBuyerBasedInEu

	// no validation rules for IsFirstSellerBasedInEu

	// no validation rules for SupplierAccountReceivable

	// no validation rules for ActualDeliveryDate

	// no validation rules for BlanketOrder

	// no validation rules for Buyer

	// no validation rules for Contract

	// no validation rules for DeliveryNote

	// no validation rules for DespatchAdvice

	// no validation rules for DisputeNotice

	// no validation rules for InventoryLocation

	// no validation rules for InventoryReport

	// no validation rules for Invoice

	// no validation rules for InvoiceIdentification

	// no validation rules for InvoicingPeriodBegin

	// no validation rules for InvoicingPeriodEnd

	// no validation rules for Manifest

	// no validation rules for OrderResponse

	// no validation rules for Payee

	// no validation rules for Payer

	// no validation rules for PickupFrom

	// no validation rules for PriceList

	// no validation rules for PromotionalDeal

	// no validation rules for PurchaseOrder

	// no validation rules for ReceivingAdvice

	// no validation rules for RemitTo

	// no validation rules for ReturnsNotice

	// no validation rules for SalesOrder

	// no validation rules for SalesReport

	// no validation rules for Seller

	// no validation rules for ShipFrom

	// no validation rules for ShipTo

	// no validation rules for SupplierAgentRepresentative

	// no validation rules for SupplierCorporateOffice

	// no validation rules for TaxCurrencyInformation

	// no validation rules for TaxRepresentative

	// no validation rules for TradeAgreement

	// no validation rules for UltimateConsignee

	// no validation rules for UserId

	// no validation rules for UserEmail

	// no validation rules for RequestId

	for idx, item := range m.GetInvoiceLineItems() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, CreateInvoiceRequestValidationError{
						field:  fmt.Sprintf("InvoiceLineItems[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, CreateInvoiceRequestValidationError{
						field:  fmt.Sprintf("InvoiceLineItems[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return CreateInvoiceRequestValidationError{
					field:  fmt.Sprintf("InvoiceLineItems[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return CreateInvoiceRequestMultiError(errors)
	}

	return nil
}

// CreateInvoiceRequestMultiError is an error wrapping multiple validation
// errors returned by CreateInvoiceRequest.ValidateAll() if the designated
// constraints aren't met.
type CreateInvoiceRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateInvoiceRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateInvoiceRequestMultiError) AllErrors() []error { return m }

// CreateInvoiceRequestValidationError is the validation error returned by
// CreateInvoiceRequest.Validate if the designated constraints aren't met.
type CreateInvoiceRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateInvoiceRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateInvoiceRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateInvoiceRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateInvoiceRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateInvoiceRequestValidationError) ErrorName() string {
	return "CreateInvoiceRequestValidationError"
}

// Error satisfies the builtin error interface
func (e CreateInvoiceRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateInvoiceRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateInvoiceRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateInvoiceRequestValidationError{}

// Validate checks the field values on CreateInvoiceResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CreateInvoiceResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateInvoiceResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreateInvoiceResponseMultiError, or nil if none found.
func (m *CreateInvoiceResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateInvoiceResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetInvoice()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreateInvoiceResponseValidationError{
					field:  "Invoice",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreateInvoiceResponseValidationError{
					field:  "Invoice",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetInvoice()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreateInvoiceResponseValidationError{
				field:  "Invoice",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return CreateInvoiceResponseMultiError(errors)
	}

	return nil
}

// CreateInvoiceResponseMultiError is an error wrapping multiple validation
// errors returned by CreateInvoiceResponse.ValidateAll() if the designated
// constraints aren't met.
type CreateInvoiceResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateInvoiceResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateInvoiceResponseMultiError) AllErrors() []error { return m }

// CreateInvoiceResponseValidationError is the validation error returned by
// CreateInvoiceResponse.Validate if the designated constraints aren't met.
type CreateInvoiceResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateInvoiceResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateInvoiceResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateInvoiceResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateInvoiceResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateInvoiceResponseValidationError) ErrorName() string {
	return "CreateInvoiceResponseValidationError"
}

// Error satisfies the builtin error interface
func (e CreateInvoiceResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateInvoiceResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateInvoiceResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateInvoiceResponseValidationError{}

// Validate checks the field values on GetInvoiceRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *GetInvoiceRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetInvoiceRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetInvoiceRequestMultiError, or nil if none found.
func (m *GetInvoiceRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GetInvoiceRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetGetRequest()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetInvoiceRequestValidationError{
					field:  "GetRequest",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetInvoiceRequestValidationError{
					field:  "GetRequest",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetGetRequest()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetInvoiceRequestValidationError{
				field:  "GetRequest",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return GetInvoiceRequestMultiError(errors)
	}

	return nil
}

// GetInvoiceRequestMultiError is an error wrapping multiple validation errors
// returned by GetInvoiceRequest.ValidateAll() if the designated constraints
// aren't met.
type GetInvoiceRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetInvoiceRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetInvoiceRequestMultiError) AllErrors() []error { return m }

// GetInvoiceRequestValidationError is the validation error returned by
// GetInvoiceRequest.Validate if the designated constraints aren't met.
type GetInvoiceRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetInvoiceRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetInvoiceRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetInvoiceRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetInvoiceRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetInvoiceRequestValidationError) ErrorName() string {
	return "GetInvoiceRequestValidationError"
}

// Error satisfies the builtin error interface
func (e GetInvoiceRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetInvoiceRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetInvoiceRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetInvoiceRequestValidationError{}

// Validate checks the field values on GetInvoiceResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetInvoiceResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetInvoiceResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetInvoiceResponseMultiError, or nil if none found.
func (m *GetInvoiceResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *GetInvoiceResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetInvoice()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetInvoiceResponseValidationError{
					field:  "Invoice",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetInvoiceResponseValidationError{
					field:  "Invoice",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetInvoice()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetInvoiceResponseValidationError{
				field:  "Invoice",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return GetInvoiceResponseMultiError(errors)
	}

	return nil
}

// GetInvoiceResponseMultiError is an error wrapping multiple validation errors
// returned by GetInvoiceResponse.ValidateAll() if the designated constraints
// aren't met.
type GetInvoiceResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetInvoiceResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetInvoiceResponseMultiError) AllErrors() []error { return m }

// GetInvoiceResponseValidationError is the validation error returned by
// GetInvoiceResponse.Validate if the designated constraints aren't met.
type GetInvoiceResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetInvoiceResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetInvoiceResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetInvoiceResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetInvoiceResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetInvoiceResponseValidationError) ErrorName() string {
	return "GetInvoiceResponseValidationError"
}

// Error satisfies the builtin error interface
func (e GetInvoiceResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetInvoiceResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetInvoiceResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetInvoiceResponseValidationError{}

// Validate checks the field values on GetInvoiceByPkRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetInvoiceByPkRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetInvoiceByPkRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetInvoiceByPkRequestMultiError, or nil if none found.
func (m *GetInvoiceByPkRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GetInvoiceByPkRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetGetByIdRequest()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetInvoiceByPkRequestValidationError{
					field:  "GetByIdRequest",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetInvoiceByPkRequestValidationError{
					field:  "GetByIdRequest",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetGetByIdRequest()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetInvoiceByPkRequestValidationError{
				field:  "GetByIdRequest",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return GetInvoiceByPkRequestMultiError(errors)
	}

	return nil
}

// GetInvoiceByPkRequestMultiError is an error wrapping multiple validation
// errors returned by GetInvoiceByPkRequest.ValidateAll() if the designated
// constraints aren't met.
type GetInvoiceByPkRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetInvoiceByPkRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetInvoiceByPkRequestMultiError) AllErrors() []error { return m }

// GetInvoiceByPkRequestValidationError is the validation error returned by
// GetInvoiceByPkRequest.Validate if the designated constraints aren't met.
type GetInvoiceByPkRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetInvoiceByPkRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetInvoiceByPkRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetInvoiceByPkRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetInvoiceByPkRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetInvoiceByPkRequestValidationError) ErrorName() string {
	return "GetInvoiceByPkRequestValidationError"
}

// Error satisfies the builtin error interface
func (e GetInvoiceByPkRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetInvoiceByPkRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetInvoiceByPkRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetInvoiceByPkRequestValidationError{}

// Validate checks the field values on GetInvoiceByPkResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetInvoiceByPkResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetInvoiceByPkResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetInvoiceByPkResponseMultiError, or nil if none found.
func (m *GetInvoiceByPkResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *GetInvoiceByPkResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetInvoice()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetInvoiceByPkResponseValidationError{
					field:  "Invoice",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetInvoiceByPkResponseValidationError{
					field:  "Invoice",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetInvoice()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetInvoiceByPkResponseValidationError{
				field:  "Invoice",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return GetInvoiceByPkResponseMultiError(errors)
	}

	return nil
}

// GetInvoiceByPkResponseMultiError is an error wrapping multiple validation
// errors returned by GetInvoiceByPkResponse.ValidateAll() if the designated
// constraints aren't met.
type GetInvoiceByPkResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetInvoiceByPkResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetInvoiceByPkResponseMultiError) AllErrors() []error { return m }

// GetInvoiceByPkResponseValidationError is the validation error returned by
// GetInvoiceByPkResponse.Validate if the designated constraints aren't met.
type GetInvoiceByPkResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetInvoiceByPkResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetInvoiceByPkResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetInvoiceByPkResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetInvoiceByPkResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetInvoiceByPkResponseValidationError) ErrorName() string {
	return "GetInvoiceByPkResponseValidationError"
}

// Error satisfies the builtin error interface
func (e GetInvoiceByPkResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetInvoiceByPkResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetInvoiceByPkResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetInvoiceByPkResponseValidationError{}

// Validate checks the field values on GetInvoicesRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetInvoicesRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetInvoicesRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetInvoicesRequestMultiError, or nil if none found.
func (m *GetInvoicesRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GetInvoicesRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Limit

	// no validation rules for NextCursor

	// no validation rules for UserEmail

	// no validation rules for RequestId

	if len(errors) > 0 {
		return GetInvoicesRequestMultiError(errors)
	}

	return nil
}

// GetInvoicesRequestMultiError is an error wrapping multiple validation errors
// returned by GetInvoicesRequest.ValidateAll() if the designated constraints
// aren't met.
type GetInvoicesRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetInvoicesRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetInvoicesRequestMultiError) AllErrors() []error { return m }

// GetInvoicesRequestValidationError is the validation error returned by
// GetInvoicesRequest.Validate if the designated constraints aren't met.
type GetInvoicesRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetInvoicesRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetInvoicesRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetInvoicesRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetInvoicesRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetInvoicesRequestValidationError) ErrorName() string {
	return "GetInvoicesRequestValidationError"
}

// Error satisfies the builtin error interface
func (e GetInvoicesRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetInvoicesRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetInvoicesRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetInvoicesRequestValidationError{}

// Validate checks the field values on GetInvoicesResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetInvoicesResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetInvoicesResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetInvoicesResponseMultiError, or nil if none found.
func (m *GetInvoicesResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *GetInvoicesResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetInvoices() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, GetInvoicesResponseValidationError{
						field:  fmt.Sprintf("Invoices[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, GetInvoicesResponseValidationError{
						field:  fmt.Sprintf("Invoices[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return GetInvoicesResponseValidationError{
					field:  fmt.Sprintf("Invoices[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for NextCursor

	if len(errors) > 0 {
		return GetInvoicesResponseMultiError(errors)
	}

	return nil
}

// GetInvoicesResponseMultiError is an error wrapping multiple validation
// errors returned by GetInvoicesResponse.ValidateAll() if the designated
// constraints aren't met.
type GetInvoicesResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetInvoicesResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetInvoicesResponseMultiError) AllErrors() []error { return m }

// GetInvoicesResponseValidationError is the validation error returned by
// GetInvoicesResponse.Validate if the designated constraints aren't met.
type GetInvoicesResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetInvoicesResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetInvoicesResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetInvoicesResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetInvoicesResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetInvoicesResponseValidationError) ErrorName() string {
	return "GetInvoicesResponseValidationError"
}

// Error satisfies the builtin error interface
func (e GetInvoicesResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetInvoicesResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetInvoicesResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetInvoicesResponseValidationError{}

// Validate checks the field values on UpdateInvoiceRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UpdateInvoiceRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateInvoiceRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UpdateInvoiceRequestMultiError, or nil if none found.
func (m *UpdateInvoiceRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateInvoiceRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for CountryOfSupplyOfGoods

	// no validation rules for CreditReasonCode

	// no validation rules for DiscountAgreementTerms

	// no validation rules for InvoiceCurrencyCode

	// no validation rules for InvoiceType

	// no validation rules for SupplierAccountReceivable

	// no validation rules for Id

	// no validation rules for UserId

	// no validation rules for UserEmail

	// no validation rules for RequestId

	if len(errors) > 0 {
		return UpdateInvoiceRequestMultiError(errors)
	}

	return nil
}

// UpdateInvoiceRequestMultiError is an error wrapping multiple validation
// errors returned by UpdateInvoiceRequest.ValidateAll() if the designated
// constraints aren't met.
type UpdateInvoiceRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateInvoiceRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateInvoiceRequestMultiError) AllErrors() []error { return m }

// UpdateInvoiceRequestValidationError is the validation error returned by
// UpdateInvoiceRequest.Validate if the designated constraints aren't met.
type UpdateInvoiceRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateInvoiceRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateInvoiceRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateInvoiceRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateInvoiceRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateInvoiceRequestValidationError) ErrorName() string {
	return "UpdateInvoiceRequestValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateInvoiceRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateInvoiceRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateInvoiceRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateInvoiceRequestValidationError{}

// Validate checks the field values on UpdateInvoiceResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UpdateInvoiceResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateInvoiceResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UpdateInvoiceResponseMultiError, or nil if none found.
func (m *UpdateInvoiceResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateInvoiceResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return UpdateInvoiceResponseMultiError(errors)
	}

	return nil
}

// UpdateInvoiceResponseMultiError is an error wrapping multiple validation
// errors returned by UpdateInvoiceResponse.ValidateAll() if the designated
// constraints aren't met.
type UpdateInvoiceResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateInvoiceResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateInvoiceResponseMultiError) AllErrors() []error { return m }

// UpdateInvoiceResponseValidationError is the validation error returned by
// UpdateInvoiceResponse.Validate if the designated constraints aren't met.
type UpdateInvoiceResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateInvoiceResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateInvoiceResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateInvoiceResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateInvoiceResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateInvoiceResponseValidationError) ErrorName() string {
	return "UpdateInvoiceResponseValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateInvoiceResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateInvoiceResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateInvoiceResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateInvoiceResponseValidationError{}

// Validate checks the field values on InvoiceLineItem with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *InvoiceLineItem) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on InvoiceLineItem with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// InvoiceLineItemMultiError, or nil if none found.
func (m *InvoiceLineItem) ValidateAll() error {
	return m.validate(true)
}

func (m *InvoiceLineItem) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetInvoiceLineItemD()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, InvoiceLineItemValidationError{
					field:  "InvoiceLineItemD",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, InvoiceLineItemValidationError{
					field:  "InvoiceLineItemD",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetInvoiceLineItemD()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return InvoiceLineItemValidationError{
				field:  "InvoiceLineItemD",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetInvoiceLineItemT()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, InvoiceLineItemValidationError{
					field:  "InvoiceLineItemT",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, InvoiceLineItemValidationError{
					field:  "InvoiceLineItemT",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetInvoiceLineItemT()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return InvoiceLineItemValidationError{
				field:  "InvoiceLineItemT",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetCrUpdUser()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, InvoiceLineItemValidationError{
					field:  "CrUpdUser",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, InvoiceLineItemValidationError{
					field:  "CrUpdUser",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCrUpdUser()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return InvoiceLineItemValidationError{
				field:  "CrUpdUser",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetCrUpdTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, InvoiceLineItemValidationError{
					field:  "CrUpdTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, InvoiceLineItemValidationError{
					field:  "CrUpdTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCrUpdTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return InvoiceLineItemValidationError{
				field:  "CrUpdTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return InvoiceLineItemMultiError(errors)
	}

	return nil
}

// InvoiceLineItemMultiError is an error wrapping multiple validation errors
// returned by InvoiceLineItem.ValidateAll() if the designated constraints
// aren't met.
type InvoiceLineItemMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m InvoiceLineItemMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m InvoiceLineItemMultiError) AllErrors() []error { return m }

// InvoiceLineItemValidationError is the validation error returned by
// InvoiceLineItem.Validate if the designated constraints aren't met.
type InvoiceLineItemValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e InvoiceLineItemValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e InvoiceLineItemValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e InvoiceLineItemValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e InvoiceLineItemValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e InvoiceLineItemValidationError) ErrorName() string { return "InvoiceLineItemValidationError" }

// Error satisfies the builtin error interface
func (e InvoiceLineItemValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sInvoiceLineItem.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = InvoiceLineItemValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = InvoiceLineItemValidationError{}

// Validate checks the field values on InvoiceLineItemD with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *InvoiceLineItemD) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on InvoiceLineItemD with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// InvoiceLineItemDMultiError, or nil if none found.
func (m *InvoiceLineItemD) ValidateAll() error {
	return m.validate(true)
}

func (m *InvoiceLineItemD) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for Uuid4

	// no validation rules for IdS

	// no validation rules for AmountExclusiveAllowancesCharges

	// no validation rules for AeacCodeListVersion

	// no validation rules for AeacCurrencyCode

	// no validation rules for AmountInclusiveAllowancesCharges

	// no validation rules for AiacCodeListVersion

	// no validation rules for AiacCurrencyCode

	// no validation rules for CreditLineIndicator

	// no validation rules for CreditReason

	// no validation rules for DeliveredQuantity

	// no validation rules for DqMeasurementUnitCode

	// no validation rules for DqCodeListVersion

	// no validation rules for ExcludedFromPaymentDiscountIndicator

	// no validation rules for Extension

	// no validation rules for FreeGoodsQuantity

	// no validation rules for FgqMeasurementUnitCode

	// no validation rules for FgqCodeListVersion

	// no validation rules for InvoicedQuantity

	// no validation rules for IqMeasurementUnitCode

	// no validation rules for IqCodeListVersion

	// no validation rules for ItemPriceBaseQuantity

	// no validation rules for IpbqMeasurementUnitCode

	// no validation rules for IpbqCodeListVersion

	// no validation rules for ItemPriceExclusiveAllowancesCharges

	// no validation rules for IpeacCodeListVersion

	// no validation rules for IpeacCurrencyCode

	// no validation rules for ItemPriceInclusiveAllowancesCharges

	// no validation rules for IpiacCodeListVersion

	// no validation rules for IpiacCurrencyCode

	// no validation rules for LegallyFixedRetailPrice

	// no validation rules for LfrpCodeListVersion

	// no validation rules for LfrpCurrencyCode

	// no validation rules for LineItemNumber

	// no validation rules for MarginSchemeInformation

	// no validation rules for OwenrshipPriorToPayment

	// no validation rules for ParentLineItemNumber

	// no validation rules for RecommendedRetailPrice

	// no validation rules for RrpCodeListVersion

	// no validation rules for RrpCurrencyCode

	// no validation rules for RetailPriceExcludingExcise

	// no validation rules for RpeeCodeListVersion

	// no validation rules for RpeeCurrencyCode

	// no validation rules for TotalOrderedQuantity

	// no validation rules for ToqMeasurementUnitCode

	// no validation rules for ToqCodeListVersion

	// no validation rules for ConsumptionReport

	// no validation rules for Contract

	// no validation rules for DeliveryNote

	// no validation rules for DespatchAdvice

	// no validation rules for EnergyQuantity

	// no validation rules for InventoryLocationFrom

	// no validation rules for InventoryLocationTo

	// no validation rules for Invoice

	// no validation rules for PromotionalDeal

	// no validation rules for PurchaseConditions

	// no validation rules for PurchaseOrder

	// no validation rules for ReceivingAdvice

	// no validation rules for ReturnableAssetIdentification

	// no validation rules for SalesOrder

	// no validation rules for ShipFrom

	// no validation rules for ShipTo

	// no validation rules for TradeAgreement

	// no validation rules for InvoiceId

	if len(errors) > 0 {
		return InvoiceLineItemDMultiError(errors)
	}

	return nil
}

// InvoiceLineItemDMultiError is an error wrapping multiple validation errors
// returned by InvoiceLineItemD.ValidateAll() if the designated constraints
// aren't met.
type InvoiceLineItemDMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m InvoiceLineItemDMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m InvoiceLineItemDMultiError) AllErrors() []error { return m }

// InvoiceLineItemDValidationError is the validation error returned by
// InvoiceLineItemD.Validate if the designated constraints aren't met.
type InvoiceLineItemDValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e InvoiceLineItemDValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e InvoiceLineItemDValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e InvoiceLineItemDValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e InvoiceLineItemDValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e InvoiceLineItemDValidationError) ErrorName() string { return "InvoiceLineItemDValidationError" }

// Error satisfies the builtin error interface
func (e InvoiceLineItemDValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sInvoiceLineItemD.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = InvoiceLineItemDValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = InvoiceLineItemDValidationError{}

// Validate checks the field values on InvoiceLineItemT with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *InvoiceLineItemT) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on InvoiceLineItemT with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// InvoiceLineItemTMultiError, or nil if none found.
func (m *InvoiceLineItemT) ValidateAll() error {
	return m.validate(true)
}

func (m *InvoiceLineItemT) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetTransferOfOwnershipDate()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, InvoiceLineItemTValidationError{
					field:  "TransferOfOwnershipDate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, InvoiceLineItemTValidationError{
					field:  "TransferOfOwnershipDate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTransferOfOwnershipDate()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return InvoiceLineItemTValidationError{
				field:  "TransferOfOwnershipDate",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetActualDeliveryDate()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, InvoiceLineItemTValidationError{
					field:  "ActualDeliveryDate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, InvoiceLineItemTValidationError{
					field:  "ActualDeliveryDate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetActualDeliveryDate()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return InvoiceLineItemTValidationError{
				field:  "ActualDeliveryDate",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetServicetimePeriodLineLevelBegin()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, InvoiceLineItemTValidationError{
					field:  "ServicetimePeriodLineLevelBegin",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, InvoiceLineItemTValidationError{
					field:  "ServicetimePeriodLineLevelBegin",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetServicetimePeriodLineLevelBegin()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return InvoiceLineItemTValidationError{
				field:  "ServicetimePeriodLineLevelBegin",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetServicetimePeriodLineLevelEnd()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, InvoiceLineItemTValidationError{
					field:  "ServicetimePeriodLineLevelEnd",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, InvoiceLineItemTValidationError{
					field:  "ServicetimePeriodLineLevelEnd",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetServicetimePeriodLineLevelEnd()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return InvoiceLineItemTValidationError{
				field:  "ServicetimePeriodLineLevelEnd",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return InvoiceLineItemTMultiError(errors)
	}

	return nil
}

// InvoiceLineItemTMultiError is an error wrapping multiple validation errors
// returned by InvoiceLineItemT.ValidateAll() if the designated constraints
// aren't met.
type InvoiceLineItemTMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m InvoiceLineItemTMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m InvoiceLineItemTMultiError) AllErrors() []error { return m }

// InvoiceLineItemTValidationError is the validation error returned by
// InvoiceLineItemT.Validate if the designated constraints aren't met.
type InvoiceLineItemTValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e InvoiceLineItemTValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e InvoiceLineItemTValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e InvoiceLineItemTValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e InvoiceLineItemTValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e InvoiceLineItemTValidationError) ErrorName() string { return "InvoiceLineItemTValidationError" }

// Error satisfies the builtin error interface
func (e InvoiceLineItemTValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sInvoiceLineItemT.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = InvoiceLineItemTValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = InvoiceLineItemTValidationError{}

// Validate checks the field values on CreateInvoiceLineItemRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CreateInvoiceLineItemRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateInvoiceLineItemRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreateInvoiceLineItemRequestMultiError, or nil if none found.
func (m *CreateInvoiceLineItemRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateInvoiceLineItemRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for AmountExclusiveAllowancesCharges

	// no validation rules for AeacCodeListVersion

	// no validation rules for AeacCurrencyCode

	// no validation rules for AmountInclusiveAllowancesCharges

	// no validation rules for AiacCodeListVersion

	// no validation rules for AiacCurrencyCode

	// no validation rules for CreditLineIndicator

	// no validation rules for CreditReason

	// no validation rules for DeliveredQuantity

	// no validation rules for DqMeasurementUnitCode

	// no validation rules for DqCodeListVersion

	// no validation rules for ExcludedFromPaymentDiscountIndicator

	// no validation rules for Extension

	// no validation rules for FreeGoodsQuantity

	// no validation rules for FgqMeasurementUnitCode

	// no validation rules for FgqCodeListVersion

	// no validation rules for InvoicedQuantity

	// no validation rules for IqMeasurementUnitCode

	// no validation rules for IqCodeListVersion

	// no validation rules for ItemPriceBaseQuantity

	// no validation rules for IpbqMeasurementUnitCode

	// no validation rules for IpbqCodeListVersion

	// no validation rules for ItemPriceExclusiveAllowancesCharges

	// no validation rules for IpeacCodeListVersion

	// no validation rules for IpeacCurrencyCode

	// no validation rules for ItemPriceInclusiveAllowancesCharges

	// no validation rules for IpiacCodeListVersion

	// no validation rules for IpiacCurrencyCode

	// no validation rules for LegallyFixedRetailPrice

	// no validation rules for LfrpCodeListVersion

	// no validation rules for LfrpCurrencyCode

	// no validation rules for LineItemNumber

	// no validation rules for MarginSchemeInformation

	// no validation rules for OwenrshipPriorToPayment

	// no validation rules for ParentLineItemNumber

	// no validation rules for RecommendedRetailPrice

	// no validation rules for RrpCodeListVersion

	// no validation rules for RrpCurrencyCode

	// no validation rules for RetailPriceExcludingExcise

	// no validation rules for RpeeCodeListVersion

	// no validation rules for RpeeCurrencyCode

	// no validation rules for TotalOrderedQuantity

	// no validation rules for ToqMeasurementUnitCode

	// no validation rules for ToqCodeListVersion

	// no validation rules for TransferOfOwnershipDate

	// no validation rules for ActualDeliveryDate

	// no validation rules for ConsumptionReport

	// no validation rules for Contract

	// no validation rules for DeliveryNote

	// no validation rules for DespatchAdvice

	// no validation rules for EnergyQuantity

	// no validation rules for InventoryLocationFrom

	// no validation rules for InventoryLocationTo

	// no validation rules for Invoice

	// no validation rules for PromotionalDeal

	// no validation rules for PurchaseConditions

	// no validation rules for PurchaseOrder

	// no validation rules for ReceivingAdvice

	// no validation rules for ReturnableAssetIdentification

	// no validation rules for SalesOrder

	// no validation rules for ServicetimePeriodLineLevelBegin

	// no validation rules for ServicetimePeriodLineLevelEnd

	// no validation rules for ShipFrom

	// no validation rules for ShipTo

	// no validation rules for TradeAgreement

	// no validation rules for InvoiceId

	// no validation rules for UserId

	// no validation rules for UserEmail

	// no validation rules for RequestId

	if len(errors) > 0 {
		return CreateInvoiceLineItemRequestMultiError(errors)
	}

	return nil
}

// CreateInvoiceLineItemRequestMultiError is an error wrapping multiple
// validation errors returned by CreateInvoiceLineItemRequest.ValidateAll() if
// the designated constraints aren't met.
type CreateInvoiceLineItemRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateInvoiceLineItemRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateInvoiceLineItemRequestMultiError) AllErrors() []error { return m }

// CreateInvoiceLineItemRequestValidationError is the validation error returned
// by CreateInvoiceLineItemRequest.Validate if the designated constraints
// aren't met.
type CreateInvoiceLineItemRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateInvoiceLineItemRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateInvoiceLineItemRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateInvoiceLineItemRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateInvoiceLineItemRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateInvoiceLineItemRequestValidationError) ErrorName() string {
	return "CreateInvoiceLineItemRequestValidationError"
}

// Error satisfies the builtin error interface
func (e CreateInvoiceLineItemRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateInvoiceLineItemRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateInvoiceLineItemRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateInvoiceLineItemRequestValidationError{}

// Validate checks the field values on CreateInvoiceLineItemResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CreateInvoiceLineItemResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateInvoiceLineItemResponse with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// CreateInvoiceLineItemResponseMultiError, or nil if none found.
func (m *CreateInvoiceLineItemResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateInvoiceLineItemResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetInvoiceLineItem()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreateInvoiceLineItemResponseValidationError{
					field:  "InvoiceLineItem",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreateInvoiceLineItemResponseValidationError{
					field:  "InvoiceLineItem",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetInvoiceLineItem()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreateInvoiceLineItemResponseValidationError{
				field:  "InvoiceLineItem",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return CreateInvoiceLineItemResponseMultiError(errors)
	}

	return nil
}

// CreateInvoiceLineItemResponseMultiError is an error wrapping multiple
// validation errors returned by CreateInvoiceLineItemResponse.ValidateAll()
// if the designated constraints aren't met.
type CreateInvoiceLineItemResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateInvoiceLineItemResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateInvoiceLineItemResponseMultiError) AllErrors() []error { return m }

// CreateInvoiceLineItemResponseValidationError is the validation error
// returned by CreateInvoiceLineItemResponse.Validate if the designated
// constraints aren't met.
type CreateInvoiceLineItemResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateInvoiceLineItemResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateInvoiceLineItemResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateInvoiceLineItemResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateInvoiceLineItemResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateInvoiceLineItemResponseValidationError) ErrorName() string {
	return "CreateInvoiceLineItemResponseValidationError"
}

// Error satisfies the builtin error interface
func (e CreateInvoiceLineItemResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateInvoiceLineItemResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateInvoiceLineItemResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateInvoiceLineItemResponseValidationError{}

// Validate checks the field values on GetInvoiceLineItemsRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetInvoiceLineItemsRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetInvoiceLineItemsRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetInvoiceLineItemsRequestMultiError, or nil if none found.
func (m *GetInvoiceLineItemsRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GetInvoiceLineItemsRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetGetRequest()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetInvoiceLineItemsRequestValidationError{
					field:  "GetRequest",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetInvoiceLineItemsRequestValidationError{
					field:  "GetRequest",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetGetRequest()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetInvoiceLineItemsRequestValidationError{
				field:  "GetRequest",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return GetInvoiceLineItemsRequestMultiError(errors)
	}

	return nil
}

// GetInvoiceLineItemsRequestMultiError is an error wrapping multiple
// validation errors returned by GetInvoiceLineItemsRequest.ValidateAll() if
// the designated constraints aren't met.
type GetInvoiceLineItemsRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetInvoiceLineItemsRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetInvoiceLineItemsRequestMultiError) AllErrors() []error { return m }

// GetInvoiceLineItemsRequestValidationError is the validation error returned
// by GetInvoiceLineItemsRequest.Validate if the designated constraints aren't met.
type GetInvoiceLineItemsRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetInvoiceLineItemsRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetInvoiceLineItemsRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetInvoiceLineItemsRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetInvoiceLineItemsRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetInvoiceLineItemsRequestValidationError) ErrorName() string {
	return "GetInvoiceLineItemsRequestValidationError"
}

// Error satisfies the builtin error interface
func (e GetInvoiceLineItemsRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetInvoiceLineItemsRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetInvoiceLineItemsRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetInvoiceLineItemsRequestValidationError{}

// Validate checks the field values on GetInvoiceLineItemsResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetInvoiceLineItemsResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetInvoiceLineItemsResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetInvoiceLineItemsResponseMultiError, or nil if none found.
func (m *GetInvoiceLineItemsResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *GetInvoiceLineItemsResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetInvoiceLineItems() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, GetInvoiceLineItemsResponseValidationError{
						field:  fmt.Sprintf("InvoiceLineItems[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, GetInvoiceLineItemsResponseValidationError{
						field:  fmt.Sprintf("InvoiceLineItems[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return GetInvoiceLineItemsResponseValidationError{
					field:  fmt.Sprintf("InvoiceLineItems[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return GetInvoiceLineItemsResponseMultiError(errors)
	}

	return nil
}

// GetInvoiceLineItemsResponseMultiError is an error wrapping multiple
// validation errors returned by GetInvoiceLineItemsResponse.ValidateAll() if
// the designated constraints aren't met.
type GetInvoiceLineItemsResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetInvoiceLineItemsResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetInvoiceLineItemsResponseMultiError) AllErrors() []error { return m }

// GetInvoiceLineItemsResponseValidationError is the validation error returned
// by GetInvoiceLineItemsResponse.Validate if the designated constraints
// aren't met.
type GetInvoiceLineItemsResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetInvoiceLineItemsResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetInvoiceLineItemsResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetInvoiceLineItemsResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetInvoiceLineItemsResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetInvoiceLineItemsResponseValidationError) ErrorName() string {
	return "GetInvoiceLineItemsResponseValidationError"
}

// Error satisfies the builtin error interface
func (e GetInvoiceLineItemsResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetInvoiceLineItemsResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetInvoiceLineItemsResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetInvoiceLineItemsResponseValidationError{}

// Validate checks the field values on InvoiceLineItems with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *InvoiceLineItems) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on InvoiceLineItems with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// InvoiceLineItemsMultiError, or nil if none found.
func (m *InvoiceLineItems) ValidateAll() error {
	return m.validate(true)
}

func (m *InvoiceLineItems) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetInvoiceLineItems() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, InvoiceLineItemsValidationError{
						field:  fmt.Sprintf("InvoiceLineItems[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, InvoiceLineItemsValidationError{
						field:  fmt.Sprintf("InvoiceLineItems[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return InvoiceLineItemsValidationError{
					field:  fmt.Sprintf("InvoiceLineItems[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return InvoiceLineItemsMultiError(errors)
	}

	return nil
}

// InvoiceLineItemsMultiError is an error wrapping multiple validation errors
// returned by InvoiceLineItems.ValidateAll() if the designated constraints
// aren't met.
type InvoiceLineItemsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m InvoiceLineItemsMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m InvoiceLineItemsMultiError) AllErrors() []error { return m }

// InvoiceLineItemsValidationError is the validation error returned by
// InvoiceLineItems.Validate if the designated constraints aren't met.
type InvoiceLineItemsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e InvoiceLineItemsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e InvoiceLineItemsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e InvoiceLineItemsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e InvoiceLineItemsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e InvoiceLineItemsValidationError) ErrorName() string { return "InvoiceLineItemsValidationError" }

// Error satisfies the builtin error interface
func (e InvoiceLineItemsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sInvoiceLineItems.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = InvoiceLineItemsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = InvoiceLineItemsValidationError{}

// Validate checks the field values on InvoiceTotal with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *InvoiceTotal) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on InvoiceTotal with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in InvoiceTotalMultiError, or
// nil if none found.
func (m *InvoiceTotal) ValidateAll() error {
	return m.validate(true)
}

func (m *InvoiceTotal) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetInvoiceTotalD()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, InvoiceTotalValidationError{
					field:  "InvoiceTotalD",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, InvoiceTotalValidationError{
					field:  "InvoiceTotalD",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetInvoiceTotalD()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return InvoiceTotalValidationError{
				field:  "InvoiceTotalD",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetInvoiceTotalT()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, InvoiceTotalValidationError{
					field:  "InvoiceTotalT",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, InvoiceTotalValidationError{
					field:  "InvoiceTotalT",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetInvoiceTotalT()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return InvoiceTotalValidationError{
				field:  "InvoiceTotalT",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return InvoiceTotalMultiError(errors)
	}

	return nil
}

// InvoiceTotalMultiError is an error wrapping multiple validation errors
// returned by InvoiceTotal.ValidateAll() if the designated constraints aren't met.
type InvoiceTotalMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m InvoiceTotalMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m InvoiceTotalMultiError) AllErrors() []error { return m }

// InvoiceTotalValidationError is the validation error returned by
// InvoiceTotal.Validate if the designated constraints aren't met.
type InvoiceTotalValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e InvoiceTotalValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e InvoiceTotalValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e InvoiceTotalValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e InvoiceTotalValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e InvoiceTotalValidationError) ErrorName() string { return "InvoiceTotalValidationError" }

// Error satisfies the builtin error interface
func (e InvoiceTotalValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sInvoiceTotal.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = InvoiceTotalValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = InvoiceTotalValidationError{}

// Validate checks the field values on InvoiceTotalD with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *InvoiceTotalD) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on InvoiceTotalD with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in InvoiceTotalDMultiError, or
// nil if none found.
func (m *InvoiceTotalD) ValidateAll() error {
	return m.validate(true)
}

func (m *InvoiceTotalD) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for BaseAmount

	// no validation rules for BaCodeListVersion

	// no validation rules for BaCurrencyCode

	// no validation rules for PrepaidAmount

	// no validation rules for PaCodeListVersion

	// no validation rules for PaCurrencyCode

	// no validation rules for TaxAccountingCurrency

	// no validation rules for TotalAmountInvoiceAllowancesCharges

	// no validation rules for TaiacCodeListVersion

	// no validation rules for TaiacCurrencyCode

	// no validation rules for TotalAmountLineAllowancesCharges

	// no validation rules for TalacCodeListVersion

	// no validation rules for TalacCurrencyCode

	// no validation rules for TotalEconomicValue

	// no validation rules for TevCodeListVersion

	// no validation rules for TevCurrencyCode

	// no validation rules for TotalGoodsValue

	// no validation rules for TgvCodeListVersion

	// no validation rules for TgvCurrencyCode

	// no validation rules for TotalInvoiceAmount

	// no validation rules for TiaCodeListVersion

	// no validation rules for TiaCurrencyCode

	// no validation rules for TotalInvoiceAmountPayable

	// no validation rules for TiapCodeListVersion

	// no validation rules for TiapCurrencyCode

	// no validation rules for TotalLineAmountExclusiveAllowancesCharges

	// no validation rules for TlaeacCodeListVersion

	// no validation rules for TlaeacCurrencyCode

	// no validation rules for TotalLineAmountInclusiveAllowancesCharges

	// no validation rules for TlaiacCodeListVersion

	// no validation rules for TlaiacCurrencyCode

	// no validation rules for TotalPaymentDiscountBasisAmount

	// no validation rules for TpdbaCodeListVersion

	// no validation rules for TpdbaCurrencyCode

	// no validation rules for TotalRetailValue

	// no validation rules for TrvCodeListVersion

	// no validation rules for TrvCurrencyCode

	// no validation rules for TotalTaxAmount

	// no validation rules for TtaCodeListVersion

	// no validation rules for TtaCurrencyCode

	// no validation rules for TotalTaxBasisAmount

	// no validation rules for TtbaCodeListVersion

	// no validation rules for TtbaCurrencyCode

	// no validation rules for TotalVATAmount

	// no validation rules for TvaCodeListVersion

	// no validation rules for TvaCurrencyCode

	// no validation rules for InvoiceLineItemId

	// no validation rules for InvoiceId

	if len(errors) > 0 {
		return InvoiceTotalDMultiError(errors)
	}

	return nil
}

// InvoiceTotalDMultiError is an error wrapping multiple validation errors
// returned by InvoiceTotalD.ValidateAll() if the designated constraints
// aren't met.
type InvoiceTotalDMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m InvoiceTotalDMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m InvoiceTotalDMultiError) AllErrors() []error { return m }

// InvoiceTotalDValidationError is the validation error returned by
// InvoiceTotalD.Validate if the designated constraints aren't met.
type InvoiceTotalDValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e InvoiceTotalDValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e InvoiceTotalDValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e InvoiceTotalDValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e InvoiceTotalDValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e InvoiceTotalDValidationError) ErrorName() string { return "InvoiceTotalDValidationError" }

// Error satisfies the builtin error interface
func (e InvoiceTotalDValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sInvoiceTotalD.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = InvoiceTotalDValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = InvoiceTotalDValidationError{}

// Validate checks the field values on InvoiceTotalT with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *InvoiceTotalT) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on InvoiceTotalT with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in InvoiceTotalTMultiError, or
// nil if none found.
func (m *InvoiceTotalT) ValidateAll() error {
	return m.validate(true)
}

func (m *InvoiceTotalT) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetPrepaidAmountDate()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, InvoiceTotalTValidationError{
					field:  "PrepaidAmountDate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, InvoiceTotalTValidationError{
					field:  "PrepaidAmountDate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetPrepaidAmountDate()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return InvoiceTotalTValidationError{
				field:  "PrepaidAmountDate",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return InvoiceTotalTMultiError(errors)
	}

	return nil
}

// InvoiceTotalTMultiError is an error wrapping multiple validation errors
// returned by InvoiceTotalT.ValidateAll() if the designated constraints
// aren't met.
type InvoiceTotalTMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m InvoiceTotalTMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m InvoiceTotalTMultiError) AllErrors() []error { return m }

// InvoiceTotalTValidationError is the validation error returned by
// InvoiceTotalT.Validate if the designated constraints aren't met.
type InvoiceTotalTValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e InvoiceTotalTValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e InvoiceTotalTValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e InvoiceTotalTValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e InvoiceTotalTValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e InvoiceTotalTValidationError) ErrorName() string { return "InvoiceTotalTValidationError" }

// Error satisfies the builtin error interface
func (e InvoiceTotalTValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sInvoiceTotalT.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = InvoiceTotalTValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = InvoiceTotalTValidationError{}

// Validate checks the field values on CreateInvoiceTotalRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CreateInvoiceTotalRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateInvoiceTotalRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreateInvoiceTotalRequestMultiError, or nil if none found.
func (m *CreateInvoiceTotalRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateInvoiceTotalRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for BaseAmount

	// no validation rules for BaCodeListVersion

	// no validation rules for BaCurrencyCode

	// no validation rules for PrepaidAmount

	// no validation rules for PaCodeListVersion

	// no validation rules for PaCurrencyCode

	// no validation rules for TaxAccountingCurrency

	// no validation rules for TotalAmountInvoiceAllowancesCharges

	// no validation rules for TaiacCodeListVersion

	// no validation rules for TaiacCurrencyCode

	// no validation rules for TotalAmountLineAllowancesCharges

	// no validation rules for TalacCodeListVersion

	// no validation rules for TalacCurrencyCode

	// no validation rules for TotalEconomicValue

	// no validation rules for TevCodeListVersion

	// no validation rules for TevCurrencyCode

	// no validation rules for TotalGoodsValue

	// no validation rules for TgvCodeListVersion

	// no validation rules for TgvCurrencyCode

	// no validation rules for TotalInvoiceAmount

	// no validation rules for TiaCodeListVersion

	// no validation rules for TiaCurrencyCode

	// no validation rules for TotalInvoiceAmountPayable

	// no validation rules for TiapCodeListVersion

	// no validation rules for TiapCurrencyCode

	// no validation rules for TotalLineAmountExclusiveAllowancesCharges

	// no validation rules for TlaeacCodeListVersion

	// no validation rules for TlaeacCurrencyCode

	// no validation rules for TotalLineAmountInclusiveAllowancesCharges

	// no validation rules for TlaiacCodeListVersion

	// no validation rules for TlaiacCurrencyCode

	// no validation rules for TotalPaymentDiscountBasisAmount

	// no validation rules for TpdbaCodeListVersion

	// no validation rules for TpdbaCurrencyCode

	// no validation rules for TotalRetailValue

	// no validation rules for TrvCodeListVersion

	// no validation rules for TrvCurrencyCode

	// no validation rules for TotalTaxAmount

	// no validation rules for TtaCodeListVersion

	// no validation rules for TtaCurrencyCode

	// no validation rules for TotalTaxBasisAmount

	// no validation rules for TtbaCodeListVersion

	// no validation rules for TtbaCurrencyCode

	// no validation rules for TotalVATAmount

	// no validation rules for TvaCodeListVersion

	// no validation rules for TvaCurrencyCode

	// no validation rules for InvoiceLineItemId

	// no validation rules for InvoiceId

	// no validation rules for PrepaidAmountDate

	// no validation rules for UserId

	// no validation rules for UserEmail

	// no validation rules for RequestId

	if len(errors) > 0 {
		return CreateInvoiceTotalRequestMultiError(errors)
	}

	return nil
}

// CreateInvoiceTotalRequestMultiError is an error wrapping multiple validation
// errors returned by CreateInvoiceTotalRequest.ValidateAll() if the
// designated constraints aren't met.
type CreateInvoiceTotalRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateInvoiceTotalRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateInvoiceTotalRequestMultiError) AllErrors() []error { return m }

// CreateInvoiceTotalRequestValidationError is the validation error returned by
// CreateInvoiceTotalRequest.Validate if the designated constraints aren't met.
type CreateInvoiceTotalRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateInvoiceTotalRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateInvoiceTotalRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateInvoiceTotalRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateInvoiceTotalRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateInvoiceTotalRequestValidationError) ErrorName() string {
	return "CreateInvoiceTotalRequestValidationError"
}

// Error satisfies the builtin error interface
func (e CreateInvoiceTotalRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateInvoiceTotalRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateInvoiceTotalRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateInvoiceTotalRequestValidationError{}

// Validate checks the field values on CreateInvoiceTotalResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CreateInvoiceTotalResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateInvoiceTotalResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreateInvoiceTotalResponseMultiError, or nil if none found.
func (m *CreateInvoiceTotalResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateInvoiceTotalResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetInvoiceTotal()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreateInvoiceTotalResponseValidationError{
					field:  "InvoiceTotal",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreateInvoiceTotalResponseValidationError{
					field:  "InvoiceTotal",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetInvoiceTotal()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreateInvoiceTotalResponseValidationError{
				field:  "InvoiceTotal",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return CreateInvoiceTotalResponseMultiError(errors)
	}

	return nil
}

// CreateInvoiceTotalResponseMultiError is an error wrapping multiple
// validation errors returned by CreateInvoiceTotalResponse.ValidateAll() if
// the designated constraints aren't met.
type CreateInvoiceTotalResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateInvoiceTotalResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateInvoiceTotalResponseMultiError) AllErrors() []error { return m }

// CreateInvoiceTotalResponseValidationError is the validation error returned
// by CreateInvoiceTotalResponse.Validate if the designated constraints aren't met.
type CreateInvoiceTotalResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateInvoiceTotalResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateInvoiceTotalResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateInvoiceTotalResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateInvoiceTotalResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateInvoiceTotalResponseValidationError) ErrorName() string {
	return "CreateInvoiceTotalResponseValidationError"
}

// Error satisfies the builtin error interface
func (e CreateInvoiceTotalResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateInvoiceTotalResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateInvoiceTotalResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateInvoiceTotalResponseValidationError{}

// Validate checks the field values on InvoiceLineItemInformationAfterTaxes
// with the rules defined in the proto definition for this message. If any
// rules are violated, the first error encountered is returned, or nil if
// there are no violations.
func (m *InvoiceLineItemInformationAfterTaxes) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on InvoiceLineItemInformationAfterTaxes
// with the rules defined in the proto definition for this message. If any
// rules are violated, the result is a list of violation errors wrapped in
// InvoiceLineItemInformationAfterTaxesMultiError, or nil if none found.
func (m *InvoiceLineItemInformationAfterTaxes) ValidateAll() error {
	return m.validate(true)
}

func (m *InvoiceLineItemInformationAfterTaxes) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for AmountExclusiveAllowancesCharges

	// no validation rules for AeacCodeListVersion

	// no validation rules for AeacCurrencyCode

	// no validation rules for AmountInclusiveAllowancesCharges

	// no validation rules for AiacCodeListVersion

	// no validation rules for AiacCurrencyCode

	// no validation rules for InvoiceId

	// no validation rules for InvoiceLineItemId

	if len(errors) > 0 {
		return InvoiceLineItemInformationAfterTaxesMultiError(errors)
	}

	return nil
}

// InvoiceLineItemInformationAfterTaxesMultiError is an error wrapping multiple
// validation errors returned by
// InvoiceLineItemInformationAfterTaxes.ValidateAll() if the designated
// constraints aren't met.
type InvoiceLineItemInformationAfterTaxesMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m InvoiceLineItemInformationAfterTaxesMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m InvoiceLineItemInformationAfterTaxesMultiError) AllErrors() []error { return m }

// InvoiceLineItemInformationAfterTaxesValidationError is the validation error
// returned by InvoiceLineItemInformationAfterTaxes.Validate if the designated
// constraints aren't met.
type InvoiceLineItemInformationAfterTaxesValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e InvoiceLineItemInformationAfterTaxesValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e InvoiceLineItemInformationAfterTaxesValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e InvoiceLineItemInformationAfterTaxesValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e InvoiceLineItemInformationAfterTaxesValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e InvoiceLineItemInformationAfterTaxesValidationError) ErrorName() string {
	return "InvoiceLineItemInformationAfterTaxesValidationError"
}

// Error satisfies the builtin error interface
func (e InvoiceLineItemInformationAfterTaxesValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sInvoiceLineItemInformationAfterTaxes.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = InvoiceLineItemInformationAfterTaxesValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = InvoiceLineItemInformationAfterTaxesValidationError{}

// Validate checks the field values on
// CreateInvoiceLineItemInformationAfterTaxesRequest with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *CreateInvoiceLineItemInformationAfterTaxesRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on
// CreateInvoiceLineItemInformationAfterTaxesRequest with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in
// CreateInvoiceLineItemInformationAfterTaxesRequestMultiError, or nil if none found.
func (m *CreateInvoiceLineItemInformationAfterTaxesRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateInvoiceLineItemInformationAfterTaxesRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for AmountExclusiveAllowancesCharges

	// no validation rules for AeacCodeListVersion

	// no validation rules for AeacCurrencyCode

	// no validation rules for AmountInclusiveAllowancesCharges

	// no validation rules for AiacCodeListVersion

	// no validation rules for AiacCurrencyCode

	// no validation rules for InvoiceId

	// no validation rules for InvoiceLineItemId

	// no validation rules for UserId

	// no validation rules for UserEmail

	// no validation rules for RequestId

	if len(errors) > 0 {
		return CreateInvoiceLineItemInformationAfterTaxesRequestMultiError(errors)
	}

	return nil
}

// CreateInvoiceLineItemInformationAfterTaxesRequestMultiError is an error
// wrapping multiple validation errors returned by
// CreateInvoiceLineItemInformationAfterTaxesRequest.ValidateAll() if the
// designated constraints aren't met.
type CreateInvoiceLineItemInformationAfterTaxesRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateInvoiceLineItemInformationAfterTaxesRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateInvoiceLineItemInformationAfterTaxesRequestMultiError) AllErrors() []error { return m }

// CreateInvoiceLineItemInformationAfterTaxesRequestValidationError is the
// validation error returned by
// CreateInvoiceLineItemInformationAfterTaxesRequest.Validate if the
// designated constraints aren't met.
type CreateInvoiceLineItemInformationAfterTaxesRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateInvoiceLineItemInformationAfterTaxesRequestValidationError) Field() string {
	return e.field
}

// Reason function returns reason value.
func (e CreateInvoiceLineItemInformationAfterTaxesRequestValidationError) Reason() string {
	return e.reason
}

// Cause function returns cause value.
func (e CreateInvoiceLineItemInformationAfterTaxesRequestValidationError) Cause() error {
	return e.cause
}

// Key function returns key value.
func (e CreateInvoiceLineItemInformationAfterTaxesRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateInvoiceLineItemInformationAfterTaxesRequestValidationError) ErrorName() string {
	return "CreateInvoiceLineItemInformationAfterTaxesRequestValidationError"
}

// Error satisfies the builtin error interface
func (e CreateInvoiceLineItemInformationAfterTaxesRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateInvoiceLineItemInformationAfterTaxesRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateInvoiceLineItemInformationAfterTaxesRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateInvoiceLineItemInformationAfterTaxesRequestValidationError{}

// Validate checks the field values on
// CreateInvoiceLineItemInformationAfterTaxesResponse with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *CreateInvoiceLineItemInformationAfterTaxesResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on
// CreateInvoiceLineItemInformationAfterTaxesResponse with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in
// CreateInvoiceLineItemInformationAfterTaxesResponseMultiError, or nil if
// none found.
func (m *CreateInvoiceLineItemInformationAfterTaxesResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateInvoiceLineItemInformationAfterTaxesResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetInvoiceLineItemInformationAfterTaxes()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreateInvoiceLineItemInformationAfterTaxesResponseValidationError{
					field:  "InvoiceLineItemInformationAfterTaxes",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreateInvoiceLineItemInformationAfterTaxesResponseValidationError{
					field:  "InvoiceLineItemInformationAfterTaxes",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetInvoiceLineItemInformationAfterTaxes()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreateInvoiceLineItemInformationAfterTaxesResponseValidationError{
				field:  "InvoiceLineItemInformationAfterTaxes",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return CreateInvoiceLineItemInformationAfterTaxesResponseMultiError(errors)
	}

	return nil
}

// CreateInvoiceLineItemInformationAfterTaxesResponseMultiError is an error
// wrapping multiple validation errors returned by
// CreateInvoiceLineItemInformationAfterTaxesResponse.ValidateAll() if the
// designated constraints aren't met.
type CreateInvoiceLineItemInformationAfterTaxesResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateInvoiceLineItemInformationAfterTaxesResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateInvoiceLineItemInformationAfterTaxesResponseMultiError) AllErrors() []error { return m }

// CreateInvoiceLineItemInformationAfterTaxesResponseValidationError is the
// validation error returned by
// CreateInvoiceLineItemInformationAfterTaxesResponse.Validate if the
// designated constraints aren't met.
type CreateInvoiceLineItemInformationAfterTaxesResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateInvoiceLineItemInformationAfterTaxesResponseValidationError) Field() string {
	return e.field
}

// Reason function returns reason value.
func (e CreateInvoiceLineItemInformationAfterTaxesResponseValidationError) Reason() string {
	return e.reason
}

// Cause function returns cause value.
func (e CreateInvoiceLineItemInformationAfterTaxesResponseValidationError) Cause() error {
	return e.cause
}

// Key function returns key value.
func (e CreateInvoiceLineItemInformationAfterTaxesResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateInvoiceLineItemInformationAfterTaxesResponseValidationError) ErrorName() string {
	return "CreateInvoiceLineItemInformationAfterTaxesResponseValidationError"
}

// Error satisfies the builtin error interface
func (e CreateInvoiceLineItemInformationAfterTaxesResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateInvoiceLineItemInformationAfterTaxesResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateInvoiceLineItemInformationAfterTaxesResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateInvoiceLineItemInformationAfterTaxesResponseValidationError{}

// Validate checks the field values on InvoiceAllowanceCharge with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *InvoiceAllowanceCharge) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on InvoiceAllowanceCharge with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// InvoiceAllowanceChargeMultiError, or nil if none found.
func (m *InvoiceAllowanceCharge) ValidateAll() error {
	return m.validate(true)
}

func (m *InvoiceAllowanceCharge) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for LeviedDutyFeeTax

	// no validation rules for AllowanceCharge

	// no validation rules for InvoiceId

	if len(errors) > 0 {
		return InvoiceAllowanceChargeMultiError(errors)
	}

	return nil
}

// InvoiceAllowanceChargeMultiError is an error wrapping multiple validation
// errors returned by InvoiceAllowanceCharge.ValidateAll() if the designated
// constraints aren't met.
type InvoiceAllowanceChargeMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m InvoiceAllowanceChargeMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m InvoiceAllowanceChargeMultiError) AllErrors() []error { return m }

// InvoiceAllowanceChargeValidationError is the validation error returned by
// InvoiceAllowanceCharge.Validate if the designated constraints aren't met.
type InvoiceAllowanceChargeValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e InvoiceAllowanceChargeValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e InvoiceAllowanceChargeValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e InvoiceAllowanceChargeValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e InvoiceAllowanceChargeValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e InvoiceAllowanceChargeValidationError) ErrorName() string {
	return "InvoiceAllowanceChargeValidationError"
}

// Error satisfies the builtin error interface
func (e InvoiceAllowanceChargeValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sInvoiceAllowanceCharge.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = InvoiceAllowanceChargeValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = InvoiceAllowanceChargeValidationError{}

// Validate checks the field values on CreateInvoiceAllowanceChargeRequest with
// the rules defined in the proto definition for this message. If any rules
// are violated, the first error encountered is returned, or nil if there are
// no violations.
func (m *CreateInvoiceAllowanceChargeRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateInvoiceAllowanceChargeRequest
// with the rules defined in the proto definition for this message. If any
// rules are violated, the result is a list of violation errors wrapped in
// CreateInvoiceAllowanceChargeRequestMultiError, or nil if none found.
func (m *CreateInvoiceAllowanceChargeRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateInvoiceAllowanceChargeRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for LeviedDutyFeeTax

	// no validation rules for AllowanceCharge

	// no validation rules for InvoiceId

	// no validation rules for UserId

	// no validation rules for UserEmail

	// no validation rules for RequestId

	if len(errors) > 0 {
		return CreateInvoiceAllowanceChargeRequestMultiError(errors)
	}

	return nil
}

// CreateInvoiceAllowanceChargeRequestMultiError is an error wrapping multiple
// validation errors returned by
// CreateInvoiceAllowanceChargeRequest.ValidateAll() if the designated
// constraints aren't met.
type CreateInvoiceAllowanceChargeRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateInvoiceAllowanceChargeRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateInvoiceAllowanceChargeRequestMultiError) AllErrors() []error { return m }

// CreateInvoiceAllowanceChargeRequestValidationError is the validation error
// returned by CreateInvoiceAllowanceChargeRequest.Validate if the designated
// constraints aren't met.
type CreateInvoiceAllowanceChargeRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateInvoiceAllowanceChargeRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateInvoiceAllowanceChargeRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateInvoiceAllowanceChargeRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateInvoiceAllowanceChargeRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateInvoiceAllowanceChargeRequestValidationError) ErrorName() string {
	return "CreateInvoiceAllowanceChargeRequestValidationError"
}

// Error satisfies the builtin error interface
func (e CreateInvoiceAllowanceChargeRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateInvoiceAllowanceChargeRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateInvoiceAllowanceChargeRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateInvoiceAllowanceChargeRequestValidationError{}

// Validate checks the field values on CreateInvoiceAllowanceChargeResponse
// with the rules defined in the proto definition for this message. If any
// rules are violated, the first error encountered is returned, or nil if
// there are no violations.
func (m *CreateInvoiceAllowanceChargeResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateInvoiceAllowanceChargeResponse
// with the rules defined in the proto definition for this message. If any
// rules are violated, the result is a list of violation errors wrapped in
// CreateInvoiceAllowanceChargeResponseMultiError, or nil if none found.
func (m *CreateInvoiceAllowanceChargeResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateInvoiceAllowanceChargeResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetInvoiceAllowanceCharge()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreateInvoiceAllowanceChargeResponseValidationError{
					field:  "InvoiceAllowanceCharge",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreateInvoiceAllowanceChargeResponseValidationError{
					field:  "InvoiceAllowanceCharge",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetInvoiceAllowanceCharge()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreateInvoiceAllowanceChargeResponseValidationError{
				field:  "InvoiceAllowanceCharge",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return CreateInvoiceAllowanceChargeResponseMultiError(errors)
	}

	return nil
}

// CreateInvoiceAllowanceChargeResponseMultiError is an error wrapping multiple
// validation errors returned by
// CreateInvoiceAllowanceChargeResponse.ValidateAll() if the designated
// constraints aren't met.
type CreateInvoiceAllowanceChargeResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateInvoiceAllowanceChargeResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateInvoiceAllowanceChargeResponseMultiError) AllErrors() []error { return m }

// CreateInvoiceAllowanceChargeResponseValidationError is the validation error
// returned by CreateInvoiceAllowanceChargeResponse.Validate if the designated
// constraints aren't met.
type CreateInvoiceAllowanceChargeResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateInvoiceAllowanceChargeResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateInvoiceAllowanceChargeResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateInvoiceAllowanceChargeResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateInvoiceAllowanceChargeResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateInvoiceAllowanceChargeResponseValidationError) ErrorName() string {
	return "CreateInvoiceAllowanceChargeResponseValidationError"
}

// Error satisfies the builtin error interface
func (e CreateInvoiceAllowanceChargeResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateInvoiceAllowanceChargeResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateInvoiceAllowanceChargeResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateInvoiceAllowanceChargeResponseValidationError{}

// Validate checks the field values on LeviedDutyFeeTax with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *LeviedDutyFeeTax) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on LeviedDutyFeeTax with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// LeviedDutyFeeTaxMultiError, or nil if none found.
func (m *LeviedDutyFeeTax) ValidateAll() error {
	return m.validate(true)
}

func (m *LeviedDutyFeeTax) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetLeviedDutyFeeTaxD()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, LeviedDutyFeeTaxValidationError{
					field:  "LeviedDutyFeeTaxD",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, LeviedDutyFeeTaxValidationError{
					field:  "LeviedDutyFeeTaxD",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetLeviedDutyFeeTaxD()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return LeviedDutyFeeTaxValidationError{
				field:  "LeviedDutyFeeTaxD",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetLeviedDutyFeeTaxT()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, LeviedDutyFeeTaxValidationError{
					field:  "LeviedDutyFeeTaxT",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, LeviedDutyFeeTaxValidationError{
					field:  "LeviedDutyFeeTaxT",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetLeviedDutyFeeTaxT()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return LeviedDutyFeeTaxValidationError{
				field:  "LeviedDutyFeeTaxT",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return LeviedDutyFeeTaxMultiError(errors)
	}

	return nil
}

// LeviedDutyFeeTaxMultiError is an error wrapping multiple validation errors
// returned by LeviedDutyFeeTax.ValidateAll() if the designated constraints
// aren't met.
type LeviedDutyFeeTaxMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m LeviedDutyFeeTaxMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m LeviedDutyFeeTaxMultiError) AllErrors() []error { return m }

// LeviedDutyFeeTaxValidationError is the validation error returned by
// LeviedDutyFeeTax.Validate if the designated constraints aren't met.
type LeviedDutyFeeTaxValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e LeviedDutyFeeTaxValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e LeviedDutyFeeTaxValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e LeviedDutyFeeTaxValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e LeviedDutyFeeTaxValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e LeviedDutyFeeTaxValidationError) ErrorName() string { return "LeviedDutyFeeTaxValidationError" }

// Error satisfies the builtin error interface
func (e LeviedDutyFeeTaxValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sLeviedDutyFeeTax.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = LeviedDutyFeeTaxValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = LeviedDutyFeeTaxValidationError{}

// Validate checks the field values on LeviedDutyFeeTaxD with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *LeviedDutyFeeTaxD) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on LeviedDutyFeeTaxD with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// LeviedDutyFeeTaxDMultiError, or nil if none found.
func (m *LeviedDutyFeeTaxD) ValidateAll() error {
	return m.validate(true)
}

func (m *LeviedDutyFeeTaxD) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for DutyFeeTaxAccountingCurrency

	// no validation rules for DutyFeeTaxAgencyName

	// no validation rules for DutyFeeTaxAmount

	// no validation rules for DftaCodeListVersion

	// no validation rules for DftaCurrencyCode

	// no validation rules for DutyFeeTaxAmountInAccountingCurrency

	// no validation rules for DftaiacCodeListVersion

	// no validation rules for DftaiacCurrencyCode

	// no validation rules for DutyFeeTaxBasisAmount

	// no validation rules for DftbaCodeListVersion

	// no validation rules for DftbaCurrencyCode

	// no validation rules for DutyFeeTaxBasisAmountInAccountingCurrency

	// no validation rules for DftbaiacCodeListVersion

	// no validation rules for DftbaiacCurrencyCode

	// no validation rules for DutyFeeTaxCategoryCode

	// no validation rules for DutyFeeTaxDescription

	// no validation rules for DutyFeeTaxExemptionDescription

	// no validation rules for DutyFeeTaxExemptionReason

	// no validation rules for DutyFeeTaxPercentage

	// no validation rules for DutyFeeTaxTypeCode

	// no validation rules for Extension

	// no validation rules for OrderLineItemId

	// no validation rules for InvoiceLineItemId

	// no validation rules for InvoiceId

	if len(errors) > 0 {
		return LeviedDutyFeeTaxDMultiError(errors)
	}

	return nil
}

// LeviedDutyFeeTaxDMultiError is an error wrapping multiple validation errors
// returned by LeviedDutyFeeTaxD.ValidateAll() if the designated constraints
// aren't met.
type LeviedDutyFeeTaxDMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m LeviedDutyFeeTaxDMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m LeviedDutyFeeTaxDMultiError) AllErrors() []error { return m }

// LeviedDutyFeeTaxDValidationError is the validation error returned by
// LeviedDutyFeeTaxD.Validate if the designated constraints aren't met.
type LeviedDutyFeeTaxDValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e LeviedDutyFeeTaxDValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e LeviedDutyFeeTaxDValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e LeviedDutyFeeTaxDValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e LeviedDutyFeeTaxDValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e LeviedDutyFeeTaxDValidationError) ErrorName() string {
	return "LeviedDutyFeeTaxDValidationError"
}

// Error satisfies the builtin error interface
func (e LeviedDutyFeeTaxDValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sLeviedDutyFeeTaxD.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = LeviedDutyFeeTaxDValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = LeviedDutyFeeTaxDValidationError{}

// Validate checks the field values on LeviedDutyFeeTaxT with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *LeviedDutyFeeTaxT) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on LeviedDutyFeeTaxT with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// LeviedDutyFeeTaxTMultiError, or nil if none found.
func (m *LeviedDutyFeeTaxT) ValidateAll() error {
	return m.validate(true)
}

func (m *LeviedDutyFeeTaxT) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetDutyFeeTaxPointDate()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, LeviedDutyFeeTaxTValidationError{
					field:  "DutyFeeTaxPointDate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, LeviedDutyFeeTaxTValidationError{
					field:  "DutyFeeTaxPointDate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDutyFeeTaxPointDate()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return LeviedDutyFeeTaxTValidationError{
				field:  "DutyFeeTaxPointDate",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return LeviedDutyFeeTaxTMultiError(errors)
	}

	return nil
}

// LeviedDutyFeeTaxTMultiError is an error wrapping multiple validation errors
// returned by LeviedDutyFeeTaxT.ValidateAll() if the designated constraints
// aren't met.
type LeviedDutyFeeTaxTMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m LeviedDutyFeeTaxTMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m LeviedDutyFeeTaxTMultiError) AllErrors() []error { return m }

// LeviedDutyFeeTaxTValidationError is the validation error returned by
// LeviedDutyFeeTaxT.Validate if the designated constraints aren't met.
type LeviedDutyFeeTaxTValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e LeviedDutyFeeTaxTValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e LeviedDutyFeeTaxTValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e LeviedDutyFeeTaxTValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e LeviedDutyFeeTaxTValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e LeviedDutyFeeTaxTValidationError) ErrorName() string {
	return "LeviedDutyFeeTaxTValidationError"
}

// Error satisfies the builtin error interface
func (e LeviedDutyFeeTaxTValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sLeviedDutyFeeTaxT.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = LeviedDutyFeeTaxTValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = LeviedDutyFeeTaxTValidationError{}

// Validate checks the field values on CreateLeviedDutyFeeTaxRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CreateLeviedDutyFeeTaxRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateLeviedDutyFeeTaxRequest with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// CreateLeviedDutyFeeTaxRequestMultiError, or nil if none found.
func (m *CreateLeviedDutyFeeTaxRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateLeviedDutyFeeTaxRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for DutyFeeTaxAccountingCurrency

	// no validation rules for DutyFeeTaxAgencyName

	// no validation rules for DutyFeeTaxAmount

	// no validation rules for DftaCodeListVersion

	// no validation rules for DftaCurrencyCode

	// no validation rules for DutyFeeTaxAmountInAccountingCurrency

	// no validation rules for DftaiacCodeListVersion

	// no validation rules for DftaiacCurrencyCode

	// no validation rules for DutyFeeTaxBasisAmount

	// no validation rules for DftbaCodeListVersion

	// no validation rules for DftbaCurrencyCode

	// no validation rules for DutyFeeTaxBasisAmountInAccountingCurrency

	// no validation rules for DftbaiacCodeListVersion

	// no validation rules for DftbaiacCurrencyCode

	// no validation rules for DutyFeeTaxCategoryCode

	// no validation rules for DutyFeeTaxDescription

	// no validation rules for DutyFeeTaxExemptionDescription

	// no validation rules for DutyFeeTaxExemptionReason

	// no validation rules for DutyFeeTaxPercentage

	// no validation rules for DutyFeeTaxTypeCode

	// no validation rules for Extension

	// no validation rules for OrderLineItemId

	// no validation rules for InvoiceLineItemId

	// no validation rules for InvoiceId

	// no validation rules for DutyFeeTaxPointDate

	// no validation rules for UserId

	// no validation rules for UserEmail

	// no validation rules for RequestId

	if len(errors) > 0 {
		return CreateLeviedDutyFeeTaxRequestMultiError(errors)
	}

	return nil
}

// CreateLeviedDutyFeeTaxRequestMultiError is an error wrapping multiple
// validation errors returned by CreateLeviedDutyFeeTaxRequest.ValidateAll()
// if the designated constraints aren't met.
type CreateLeviedDutyFeeTaxRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateLeviedDutyFeeTaxRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateLeviedDutyFeeTaxRequestMultiError) AllErrors() []error { return m }

// CreateLeviedDutyFeeTaxRequestValidationError is the validation error
// returned by CreateLeviedDutyFeeTaxRequest.Validate if the designated
// constraints aren't met.
type CreateLeviedDutyFeeTaxRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateLeviedDutyFeeTaxRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateLeviedDutyFeeTaxRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateLeviedDutyFeeTaxRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateLeviedDutyFeeTaxRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateLeviedDutyFeeTaxRequestValidationError) ErrorName() string {
	return "CreateLeviedDutyFeeTaxRequestValidationError"
}

// Error satisfies the builtin error interface
func (e CreateLeviedDutyFeeTaxRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateLeviedDutyFeeTaxRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateLeviedDutyFeeTaxRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateLeviedDutyFeeTaxRequestValidationError{}

// Validate checks the field values on CreateLeviedDutyFeeTaxResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CreateLeviedDutyFeeTaxResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateLeviedDutyFeeTaxResponse with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// CreateLeviedDutyFeeTaxResponseMultiError, or nil if none found.
func (m *CreateLeviedDutyFeeTaxResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateLeviedDutyFeeTaxResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetLeviedDutyFeeTax()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreateLeviedDutyFeeTaxResponseValidationError{
					field:  "LeviedDutyFeeTax",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreateLeviedDutyFeeTaxResponseValidationError{
					field:  "LeviedDutyFeeTax",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetLeviedDutyFeeTax()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreateLeviedDutyFeeTaxResponseValidationError{
				field:  "LeviedDutyFeeTax",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return CreateLeviedDutyFeeTaxResponseMultiError(errors)
	}

	return nil
}

// CreateLeviedDutyFeeTaxResponseMultiError is an error wrapping multiple
// validation errors returned by CreateLeviedDutyFeeTaxResponse.ValidateAll()
// if the designated constraints aren't met.
type CreateLeviedDutyFeeTaxResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateLeviedDutyFeeTaxResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateLeviedDutyFeeTaxResponseMultiError) AllErrors() []error { return m }

// CreateLeviedDutyFeeTaxResponseValidationError is the validation error
// returned by CreateLeviedDutyFeeTaxResponse.Validate if the designated
// constraints aren't met.
type CreateLeviedDutyFeeTaxResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateLeviedDutyFeeTaxResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateLeviedDutyFeeTaxResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateLeviedDutyFeeTaxResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateLeviedDutyFeeTaxResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateLeviedDutyFeeTaxResponseValidationError) ErrorName() string {
	return "CreateLeviedDutyFeeTaxResponseValidationError"
}

// Error satisfies the builtin error interface
func (e CreateLeviedDutyFeeTaxResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateLeviedDutyFeeTaxResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateLeviedDutyFeeTaxResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateLeviedDutyFeeTaxResponseValidationError{}
