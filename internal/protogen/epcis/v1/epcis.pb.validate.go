// Code generated by protoc-gen-validate. DO NOT EDIT.
// source: epcis/v1/epcis.proto

package v1

import (
	"bytes"
	"errors"
	"fmt"
	"net"
	"net/mail"
	"net/url"
	"regexp"
	"sort"
	"strings"
	"time"
	"unicode/utf8"

	"google.golang.org/protobuf/types/known/anypb"
)

// ensure the imports are used
var (
	_ = bytes.MinRead
	_ = errors.New("")
	_ = fmt.Print
	_ = utf8.UTFMax
	_ = (*regexp.Regexp)(nil)
	_ = (*strings.Reader)(nil)
	_ = net.IPv4len
	_ = time.Duration(0)
	_ = (*url.URL)(nil)
	_ = (*mail.Address)(nil)
	_ = anypb.Any{}
	_ = sort.Sort
)

// Validate checks the field values on ObjectEvent with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ObjectEvent) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ObjectEvent with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ObjectEventMultiError, or
// nil if none found.
func (m *ObjectEvent) ValidateAll() error {
	return m.validate(true)
}

func (m *ObjectEvent) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetEpcisEventD()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ObjectEventValidationError{
					field:  "EpcisEventD",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ObjectEventValidationError{
					field:  "EpcisEventD",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetEpcisEventD()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ObjectEventValidationError{
				field:  "EpcisEventD",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetEpcisEventT()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ObjectEventValidationError{
					field:  "EpcisEventT",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ObjectEventValidationError{
					field:  "EpcisEventT",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetEpcisEventT()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ObjectEventValidationError{
				field:  "EpcisEventT",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetErrorDeclarationD()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ObjectEventValidationError{
					field:  "ErrorDeclarationD",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ObjectEventValidationError{
					field:  "ErrorDeclarationD",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetErrorDeclarationD()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ObjectEventValidationError{
				field:  "ErrorDeclarationD",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetErrorDeclarationT()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ObjectEventValidationError{
					field:  "ErrorDeclarationT",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ObjectEventValidationError{
					field:  "ErrorDeclarationT",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetErrorDeclarationT()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ObjectEventValidationError{
				field:  "ErrorDeclarationT",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetObjectEventD()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ObjectEventValidationError{
					field:  "ObjectEventD",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ObjectEventValidationError{
					field:  "ObjectEventD",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetObjectEventD()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ObjectEventValidationError{
				field:  "ObjectEventD",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetCrUpdUser()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ObjectEventValidationError{
					field:  "CrUpdUser",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ObjectEventValidationError{
					field:  "CrUpdUser",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCrUpdUser()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ObjectEventValidationError{
				field:  "CrUpdUser",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	for idx, item := range m.GetPersistentDispositions() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ObjectEventValidationError{
						field:  fmt.Sprintf("PersistentDispositions[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ObjectEventValidationError{
						field:  fmt.Sprintf("PersistentDispositions[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ObjectEventValidationError{
					field:  fmt.Sprintf("PersistentDispositions[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetEpcList() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ObjectEventValidationError{
						field:  fmt.Sprintf("EpcList[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ObjectEventValidationError{
						field:  fmt.Sprintf("EpcList[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ObjectEventValidationError{
					field:  fmt.Sprintf("EpcList[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetBizTransactionList() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ObjectEventValidationError{
						field:  fmt.Sprintf("BizTransactionList[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ObjectEventValidationError{
						field:  fmt.Sprintf("BizTransactionList[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ObjectEventValidationError{
					field:  fmt.Sprintf("BizTransactionList[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetQuantityList() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ObjectEventValidationError{
						field:  fmt.Sprintf("QuantityList[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ObjectEventValidationError{
						field:  fmt.Sprintf("QuantityList[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ObjectEventValidationError{
					field:  fmt.Sprintf("QuantityList[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetSourceList() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ObjectEventValidationError{
						field:  fmt.Sprintf("SourceList[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ObjectEventValidationError{
						field:  fmt.Sprintf("SourceList[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ObjectEventValidationError{
					field:  fmt.Sprintf("SourceList[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetDestinationList() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ObjectEventValidationError{
						field:  fmt.Sprintf("DestinationList[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ObjectEventValidationError{
						field:  fmt.Sprintf("DestinationList[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ObjectEventValidationError{
					field:  fmt.Sprintf("DestinationList[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetSensorElementList() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ObjectEventValidationError{
						field:  fmt.Sprintf("SensorElementList[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ObjectEventValidationError{
						field:  fmt.Sprintf("SensorElementList[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ObjectEventValidationError{
					field:  fmt.Sprintf("SensorElementList[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ObjectEventMultiError(errors)
	}

	return nil
}

// ObjectEventMultiError is an error wrapping multiple validation errors
// returned by ObjectEvent.ValidateAll() if the designated constraints aren't met.
type ObjectEventMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ObjectEventMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ObjectEventMultiError) AllErrors() []error { return m }

// ObjectEventValidationError is the validation error returned by
// ObjectEvent.Validate if the designated constraints aren't met.
type ObjectEventValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ObjectEventValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ObjectEventValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ObjectEventValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ObjectEventValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ObjectEventValidationError) ErrorName() string { return "ObjectEventValidationError" }

// Error satisfies the builtin error interface
func (e ObjectEventValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sObjectEvent.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ObjectEventValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ObjectEventValidationError{}

// Validate checks the field values on ObjectEventD with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ObjectEventD) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ObjectEventD with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ObjectEventDMultiError, or
// nil if none found.
func (m *ObjectEventD) ValidateAll() error {
	return m.validate(true)
}

func (m *ObjectEventD) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for Uuid4

	// no validation rules for IdS

	// no validation rules for Action

	// no validation rules for BizStep

	// no validation rules for Disposition

	// no validation rules for ReadPoint

	// no validation rules for BizLocation

	// no validation rules for Ilmd

	if len(errors) > 0 {
		return ObjectEventDMultiError(errors)
	}

	return nil
}

// ObjectEventDMultiError is an error wrapping multiple validation errors
// returned by ObjectEventD.ValidateAll() if the designated constraints aren't met.
type ObjectEventDMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ObjectEventDMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ObjectEventDMultiError) AllErrors() []error { return m }

// ObjectEventDValidationError is the validation error returned by
// ObjectEventD.Validate if the designated constraints aren't met.
type ObjectEventDValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ObjectEventDValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ObjectEventDValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ObjectEventDValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ObjectEventDValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ObjectEventDValidationError) ErrorName() string { return "ObjectEventDValidationError" }

// Error satisfies the builtin error interface
func (e ObjectEventDValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sObjectEventD.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ObjectEventDValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ObjectEventDValidationError{}

// Validate checks the field values on CreateObjectEventRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CreateObjectEventRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateObjectEventRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreateObjectEventRequestMultiError, or nil if none found.
func (m *CreateObjectEventRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateObjectEventRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for EventId

	// no validation rules for EventTimeZoneOffset

	// no validation rules for Certification

	// no validation rules for EventTime

	// no validation rules for Reason

	// no validation rules for DeclarationTime

	// no validation rules for Action

	// no validation rules for BizStep

	// no validation rules for Disposition

	// no validation rules for ReadPoint

	// no validation rules for BizLocation

	// no validation rules for Ilmd

	// no validation rules for UserId

	// no validation rules for UserEmail

	// no validation rules for RequestId

	for idx, item := range m.GetPersistentDispositions() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, CreateObjectEventRequestValidationError{
						field:  fmt.Sprintf("PersistentDispositions[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, CreateObjectEventRequestValidationError{
						field:  fmt.Sprintf("PersistentDispositions[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return CreateObjectEventRequestValidationError{
					field:  fmt.Sprintf("PersistentDispositions[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetEpcList() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, CreateObjectEventRequestValidationError{
						field:  fmt.Sprintf("EpcList[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, CreateObjectEventRequestValidationError{
						field:  fmt.Sprintf("EpcList[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return CreateObjectEventRequestValidationError{
					field:  fmt.Sprintf("EpcList[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetBizTransactionList() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, CreateObjectEventRequestValidationError{
						field:  fmt.Sprintf("BizTransactionList[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, CreateObjectEventRequestValidationError{
						field:  fmt.Sprintf("BizTransactionList[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return CreateObjectEventRequestValidationError{
					field:  fmt.Sprintf("BizTransactionList[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetQuantityList() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, CreateObjectEventRequestValidationError{
						field:  fmt.Sprintf("QuantityList[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, CreateObjectEventRequestValidationError{
						field:  fmt.Sprintf("QuantityList[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return CreateObjectEventRequestValidationError{
					field:  fmt.Sprintf("QuantityList[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetSourceList() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, CreateObjectEventRequestValidationError{
						field:  fmt.Sprintf("SourceList[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, CreateObjectEventRequestValidationError{
						field:  fmt.Sprintf("SourceList[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return CreateObjectEventRequestValidationError{
					field:  fmt.Sprintf("SourceList[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetDestinationList() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, CreateObjectEventRequestValidationError{
						field:  fmt.Sprintf("DestinationList[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, CreateObjectEventRequestValidationError{
						field:  fmt.Sprintf("DestinationList[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return CreateObjectEventRequestValidationError{
					field:  fmt.Sprintf("DestinationList[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetSensorElementList() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, CreateObjectEventRequestValidationError{
						field:  fmt.Sprintf("SensorElementList[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, CreateObjectEventRequestValidationError{
						field:  fmt.Sprintf("SensorElementList[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return CreateObjectEventRequestValidationError{
					field:  fmt.Sprintf("SensorElementList[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return CreateObjectEventRequestMultiError(errors)
	}

	return nil
}

// CreateObjectEventRequestMultiError is an error wrapping multiple validation
// errors returned by CreateObjectEventRequest.ValidateAll() if the designated
// constraints aren't met.
type CreateObjectEventRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateObjectEventRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateObjectEventRequestMultiError) AllErrors() []error { return m }

// CreateObjectEventRequestValidationError is the validation error returned by
// CreateObjectEventRequest.Validate if the designated constraints aren't met.
type CreateObjectEventRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateObjectEventRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateObjectEventRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateObjectEventRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateObjectEventRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateObjectEventRequestValidationError) ErrorName() string {
	return "CreateObjectEventRequestValidationError"
}

// Error satisfies the builtin error interface
func (e CreateObjectEventRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateObjectEventRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateObjectEventRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateObjectEventRequestValidationError{}

// Validate checks the field values on CreateObjectEventResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CreateObjectEventResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateObjectEventResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreateObjectEventResponseMultiError, or nil if none found.
func (m *CreateObjectEventResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateObjectEventResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetObjectEvent()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreateObjectEventResponseValidationError{
					field:  "ObjectEvent",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreateObjectEventResponseValidationError{
					field:  "ObjectEvent",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetObjectEvent()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreateObjectEventResponseValidationError{
				field:  "ObjectEvent",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return CreateObjectEventResponseMultiError(errors)
	}

	return nil
}

// CreateObjectEventResponseMultiError is an error wrapping multiple validation
// errors returned by CreateObjectEventResponse.ValidateAll() if the
// designated constraints aren't met.
type CreateObjectEventResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateObjectEventResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateObjectEventResponseMultiError) AllErrors() []error { return m }

// CreateObjectEventResponseValidationError is the validation error returned by
// CreateObjectEventResponse.Validate if the designated constraints aren't met.
type CreateObjectEventResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateObjectEventResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateObjectEventResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateObjectEventResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateObjectEventResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateObjectEventResponseValidationError) ErrorName() string {
	return "CreateObjectEventResponseValidationError"
}

// Error satisfies the builtin error interface
func (e CreateObjectEventResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateObjectEventResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateObjectEventResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateObjectEventResponseValidationError{}

// Validate checks the field values on GetObjectEventRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetObjectEventRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetObjectEventRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetObjectEventRequestMultiError, or nil if none found.
func (m *GetObjectEventRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GetObjectEventRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetGetRequest()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetObjectEventRequestValidationError{
					field:  "GetRequest",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetObjectEventRequestValidationError{
					field:  "GetRequest",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetGetRequest()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetObjectEventRequestValidationError{
				field:  "GetRequest",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return GetObjectEventRequestMultiError(errors)
	}

	return nil
}

// GetObjectEventRequestMultiError is an error wrapping multiple validation
// errors returned by GetObjectEventRequest.ValidateAll() if the designated
// constraints aren't met.
type GetObjectEventRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetObjectEventRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetObjectEventRequestMultiError) AllErrors() []error { return m }

// GetObjectEventRequestValidationError is the validation error returned by
// GetObjectEventRequest.Validate if the designated constraints aren't met.
type GetObjectEventRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetObjectEventRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetObjectEventRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetObjectEventRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetObjectEventRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetObjectEventRequestValidationError) ErrorName() string {
	return "GetObjectEventRequestValidationError"
}

// Error satisfies the builtin error interface
func (e GetObjectEventRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetObjectEventRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetObjectEventRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetObjectEventRequestValidationError{}

// Validate checks the field values on GetObjectEventResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetObjectEventResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetObjectEventResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetObjectEventResponseMultiError, or nil if none found.
func (m *GetObjectEventResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *GetObjectEventResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetObjectEvent()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetObjectEventResponseValidationError{
					field:  "ObjectEvent",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetObjectEventResponseValidationError{
					field:  "ObjectEvent",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetObjectEvent()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetObjectEventResponseValidationError{
				field:  "ObjectEvent",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return GetObjectEventResponseMultiError(errors)
	}

	return nil
}

// GetObjectEventResponseMultiError is an error wrapping multiple validation
// errors returned by GetObjectEventResponse.ValidateAll() if the designated
// constraints aren't met.
type GetObjectEventResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetObjectEventResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetObjectEventResponseMultiError) AllErrors() []error { return m }

// GetObjectEventResponseValidationError is the validation error returned by
// GetObjectEventResponse.Validate if the designated constraints aren't met.
type GetObjectEventResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetObjectEventResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetObjectEventResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetObjectEventResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetObjectEventResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetObjectEventResponseValidationError) ErrorName() string {
	return "GetObjectEventResponseValidationError"
}

// Error satisfies the builtin error interface
func (e GetObjectEventResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetObjectEventResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetObjectEventResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetObjectEventResponseValidationError{}

// Validate checks the field values on GetObjectEventsRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetObjectEventsRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetObjectEventsRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetObjectEventsRequestMultiError, or nil if none found.
func (m *GetObjectEventsRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GetObjectEventsRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Limit

	// no validation rules for NextCursor

	// no validation rules for UserEmail

	// no validation rules for RequestId

	if len(errors) > 0 {
		return GetObjectEventsRequestMultiError(errors)
	}

	return nil
}

// GetObjectEventsRequestMultiError is an error wrapping multiple validation
// errors returned by GetObjectEventsRequest.ValidateAll() if the designated
// constraints aren't met.
type GetObjectEventsRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetObjectEventsRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetObjectEventsRequestMultiError) AllErrors() []error { return m }

// GetObjectEventsRequestValidationError is the validation error returned by
// GetObjectEventsRequest.Validate if the designated constraints aren't met.
type GetObjectEventsRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetObjectEventsRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetObjectEventsRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetObjectEventsRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetObjectEventsRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetObjectEventsRequestValidationError) ErrorName() string {
	return "GetObjectEventsRequestValidationError"
}

// Error satisfies the builtin error interface
func (e GetObjectEventsRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetObjectEventsRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetObjectEventsRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetObjectEventsRequestValidationError{}

// Validate checks the field values on GetObjectEventsResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetObjectEventsResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetObjectEventsResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetObjectEventsResponseMultiError, or nil if none found.
func (m *GetObjectEventsResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *GetObjectEventsResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetObjectEvents() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, GetObjectEventsResponseValidationError{
						field:  fmt.Sprintf("ObjectEvents[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, GetObjectEventsResponseValidationError{
						field:  fmt.Sprintf("ObjectEvents[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return GetObjectEventsResponseValidationError{
					field:  fmt.Sprintf("ObjectEvents[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for NextCursor

	if len(errors) > 0 {
		return GetObjectEventsResponseMultiError(errors)
	}

	return nil
}

// GetObjectEventsResponseMultiError is an error wrapping multiple validation
// errors returned by GetObjectEventsResponse.ValidateAll() if the designated
// constraints aren't met.
type GetObjectEventsResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetObjectEventsResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetObjectEventsResponseMultiError) AllErrors() []error { return m }

// GetObjectEventsResponseValidationError is the validation error returned by
// GetObjectEventsResponse.Validate if the designated constraints aren't met.
type GetObjectEventsResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetObjectEventsResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetObjectEventsResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetObjectEventsResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetObjectEventsResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetObjectEventsResponseValidationError) ErrorName() string {
	return "GetObjectEventsResponseValidationError"
}

// Error satisfies the builtin error interface
func (e GetObjectEventsResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetObjectEventsResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetObjectEventsResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetObjectEventsResponseValidationError{}

// Validate checks the field values on AggregationEvent with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *AggregationEvent) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on AggregationEvent with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// AggregationEventMultiError, or nil if none found.
func (m *AggregationEvent) ValidateAll() error {
	return m.validate(true)
}

func (m *AggregationEvent) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetEpcisEventD()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, AggregationEventValidationError{
					field:  "EpcisEventD",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, AggregationEventValidationError{
					field:  "EpcisEventD",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetEpcisEventD()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return AggregationEventValidationError{
				field:  "EpcisEventD",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetEpcisEventT()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, AggregationEventValidationError{
					field:  "EpcisEventT",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, AggregationEventValidationError{
					field:  "EpcisEventT",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetEpcisEventT()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return AggregationEventValidationError{
				field:  "EpcisEventT",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetErrorDeclarationD()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, AggregationEventValidationError{
					field:  "ErrorDeclarationD",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, AggregationEventValidationError{
					field:  "ErrorDeclarationD",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetErrorDeclarationD()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return AggregationEventValidationError{
				field:  "ErrorDeclarationD",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetErrorDeclarationT()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, AggregationEventValidationError{
					field:  "ErrorDeclarationT",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, AggregationEventValidationError{
					field:  "ErrorDeclarationT",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetErrorDeclarationT()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return AggregationEventValidationError{
				field:  "ErrorDeclarationT",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetAggregationEventD()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, AggregationEventValidationError{
					field:  "AggregationEventD",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, AggregationEventValidationError{
					field:  "AggregationEventD",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetAggregationEventD()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return AggregationEventValidationError{
				field:  "AggregationEventD",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetCrUpdUser()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, AggregationEventValidationError{
					field:  "CrUpdUser",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, AggregationEventValidationError{
					field:  "CrUpdUser",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCrUpdUser()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return AggregationEventValidationError{
				field:  "CrUpdUser",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	for idx, item := range m.GetPersistentDispositions() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, AggregationEventValidationError{
						field:  fmt.Sprintf("PersistentDispositions[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, AggregationEventValidationError{
						field:  fmt.Sprintf("PersistentDispositions[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return AggregationEventValidationError{
					field:  fmt.Sprintf("PersistentDispositions[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetChildEpcs() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, AggregationEventValidationError{
						field:  fmt.Sprintf("ChildEpcs[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, AggregationEventValidationError{
						field:  fmt.Sprintf("ChildEpcs[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return AggregationEventValidationError{
					field:  fmt.Sprintf("ChildEpcs[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetBizTransactionList() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, AggregationEventValidationError{
						field:  fmt.Sprintf("BizTransactionList[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, AggregationEventValidationError{
						field:  fmt.Sprintf("BizTransactionList[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return AggregationEventValidationError{
					field:  fmt.Sprintf("BizTransactionList[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetChildQuantityList() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, AggregationEventValidationError{
						field:  fmt.Sprintf("ChildQuantityList[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, AggregationEventValidationError{
						field:  fmt.Sprintf("ChildQuantityList[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return AggregationEventValidationError{
					field:  fmt.Sprintf("ChildQuantityList[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetSourceList() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, AggregationEventValidationError{
						field:  fmt.Sprintf("SourceList[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, AggregationEventValidationError{
						field:  fmt.Sprintf("SourceList[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return AggregationEventValidationError{
					field:  fmt.Sprintf("SourceList[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetDestinationList() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, AggregationEventValidationError{
						field:  fmt.Sprintf("DestinationList[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, AggregationEventValidationError{
						field:  fmt.Sprintf("DestinationList[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return AggregationEventValidationError{
					field:  fmt.Sprintf("DestinationList[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetSensorElementList() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, AggregationEventValidationError{
						field:  fmt.Sprintf("SensorElementList[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, AggregationEventValidationError{
						field:  fmt.Sprintf("SensorElementList[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return AggregationEventValidationError{
					field:  fmt.Sprintf("SensorElementList[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return AggregationEventMultiError(errors)
	}

	return nil
}

// AggregationEventMultiError is an error wrapping multiple validation errors
// returned by AggregationEvent.ValidateAll() if the designated constraints
// aren't met.
type AggregationEventMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AggregationEventMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AggregationEventMultiError) AllErrors() []error { return m }

// AggregationEventValidationError is the validation error returned by
// AggregationEvent.Validate if the designated constraints aren't met.
type AggregationEventValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AggregationEventValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AggregationEventValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AggregationEventValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AggregationEventValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AggregationEventValidationError) ErrorName() string { return "AggregationEventValidationError" }

// Error satisfies the builtin error interface
func (e AggregationEventValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAggregationEvent.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AggregationEventValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AggregationEventValidationError{}

// Validate checks the field values on AggregationEventD with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *AggregationEventD) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on AggregationEventD with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// AggregationEventDMultiError, or nil if none found.
func (m *AggregationEventD) ValidateAll() error {
	return m.validate(true)
}

func (m *AggregationEventD) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for Uuid4

	// no validation rules for IdS

	// no validation rules for ParentId

	// no validation rules for Action

	// no validation rules for BizStep

	// no validation rules for Disposition

	// no validation rules for ReadPoint

	// no validation rules for BizLocation

	if len(errors) > 0 {
		return AggregationEventDMultiError(errors)
	}

	return nil
}

// AggregationEventDMultiError is an error wrapping multiple validation errors
// returned by AggregationEventD.ValidateAll() if the designated constraints
// aren't met.
type AggregationEventDMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AggregationEventDMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AggregationEventDMultiError) AllErrors() []error { return m }

// AggregationEventDValidationError is the validation error returned by
// AggregationEventD.Validate if the designated constraints aren't met.
type AggregationEventDValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AggregationEventDValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AggregationEventDValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AggregationEventDValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AggregationEventDValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AggregationEventDValidationError) ErrorName() string {
	return "AggregationEventDValidationError"
}

// Error satisfies the builtin error interface
func (e AggregationEventDValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAggregationEventD.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AggregationEventDValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AggregationEventDValidationError{}

// Validate checks the field values on CreateAggregationEventRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CreateAggregationEventRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateAggregationEventRequest with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// CreateAggregationEventRequestMultiError, or nil if none found.
func (m *CreateAggregationEventRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateAggregationEventRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for EventId

	// no validation rules for EventTimeZoneOffset

	// no validation rules for Certification

	// no validation rules for EventTime

	// no validation rules for Reason

	// no validation rules for DeclarationTime

	// no validation rules for ParentId

	// no validation rules for Action

	// no validation rules for BizStep

	// no validation rules for Disposition

	// no validation rules for ReadPoint

	// no validation rules for BizLocation

	// no validation rules for UserId

	// no validation rules for UserEmail

	// no validation rules for RequestId

	for idx, item := range m.GetPersistentDispositions() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, CreateAggregationEventRequestValidationError{
						field:  fmt.Sprintf("PersistentDispositions[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, CreateAggregationEventRequestValidationError{
						field:  fmt.Sprintf("PersistentDispositions[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return CreateAggregationEventRequestValidationError{
					field:  fmt.Sprintf("PersistentDispositions[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetChildEpcs() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, CreateAggregationEventRequestValidationError{
						field:  fmt.Sprintf("ChildEpcs[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, CreateAggregationEventRequestValidationError{
						field:  fmt.Sprintf("ChildEpcs[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return CreateAggregationEventRequestValidationError{
					field:  fmt.Sprintf("ChildEpcs[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetBizTransactionList() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, CreateAggregationEventRequestValidationError{
						field:  fmt.Sprintf("BizTransactionList[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, CreateAggregationEventRequestValidationError{
						field:  fmt.Sprintf("BizTransactionList[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return CreateAggregationEventRequestValidationError{
					field:  fmt.Sprintf("BizTransactionList[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetChildQuantityList() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, CreateAggregationEventRequestValidationError{
						field:  fmt.Sprintf("ChildQuantityList[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, CreateAggregationEventRequestValidationError{
						field:  fmt.Sprintf("ChildQuantityList[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return CreateAggregationEventRequestValidationError{
					field:  fmt.Sprintf("ChildQuantityList[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetSourceList() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, CreateAggregationEventRequestValidationError{
						field:  fmt.Sprintf("SourceList[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, CreateAggregationEventRequestValidationError{
						field:  fmt.Sprintf("SourceList[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return CreateAggregationEventRequestValidationError{
					field:  fmt.Sprintf("SourceList[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetDestinationList() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, CreateAggregationEventRequestValidationError{
						field:  fmt.Sprintf("DestinationList[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, CreateAggregationEventRequestValidationError{
						field:  fmt.Sprintf("DestinationList[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return CreateAggregationEventRequestValidationError{
					field:  fmt.Sprintf("DestinationList[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetSensorElementList() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, CreateAggregationEventRequestValidationError{
						field:  fmt.Sprintf("SensorElementList[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, CreateAggregationEventRequestValidationError{
						field:  fmt.Sprintf("SensorElementList[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return CreateAggregationEventRequestValidationError{
					field:  fmt.Sprintf("SensorElementList[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return CreateAggregationEventRequestMultiError(errors)
	}

	return nil
}

// CreateAggregationEventRequestMultiError is an error wrapping multiple
// validation errors returned by CreateAggregationEventRequest.ValidateAll()
// if the designated constraints aren't met.
type CreateAggregationEventRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateAggregationEventRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateAggregationEventRequestMultiError) AllErrors() []error { return m }

// CreateAggregationEventRequestValidationError is the validation error
// returned by CreateAggregationEventRequest.Validate if the designated
// constraints aren't met.
type CreateAggregationEventRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateAggregationEventRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateAggregationEventRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateAggregationEventRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateAggregationEventRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateAggregationEventRequestValidationError) ErrorName() string {
	return "CreateAggregationEventRequestValidationError"
}

// Error satisfies the builtin error interface
func (e CreateAggregationEventRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateAggregationEventRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateAggregationEventRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateAggregationEventRequestValidationError{}

// Validate checks the field values on CreateAggregationEventResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CreateAggregationEventResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateAggregationEventResponse with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// CreateAggregationEventResponseMultiError, or nil if none found.
func (m *CreateAggregationEventResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateAggregationEventResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetAggregationEvent()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreateAggregationEventResponseValidationError{
					field:  "AggregationEvent",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreateAggregationEventResponseValidationError{
					field:  "AggregationEvent",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetAggregationEvent()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreateAggregationEventResponseValidationError{
				field:  "AggregationEvent",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return CreateAggregationEventResponseMultiError(errors)
	}

	return nil
}

// CreateAggregationEventResponseMultiError is an error wrapping multiple
// validation errors returned by CreateAggregationEventResponse.ValidateAll()
// if the designated constraints aren't met.
type CreateAggregationEventResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateAggregationEventResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateAggregationEventResponseMultiError) AllErrors() []error { return m }

// CreateAggregationEventResponseValidationError is the validation error
// returned by CreateAggregationEventResponse.Validate if the designated
// constraints aren't met.
type CreateAggregationEventResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateAggregationEventResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateAggregationEventResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateAggregationEventResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateAggregationEventResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateAggregationEventResponseValidationError) ErrorName() string {
	return "CreateAggregationEventResponseValidationError"
}

// Error satisfies the builtin error interface
func (e CreateAggregationEventResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateAggregationEventResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateAggregationEventResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateAggregationEventResponseValidationError{}

// Validate checks the field values on GetAggregationEventRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetAggregationEventRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetAggregationEventRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetAggregationEventRequestMultiError, or nil if none found.
func (m *GetAggregationEventRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GetAggregationEventRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetGetRequest()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetAggregationEventRequestValidationError{
					field:  "GetRequest",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetAggregationEventRequestValidationError{
					field:  "GetRequest",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetGetRequest()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetAggregationEventRequestValidationError{
				field:  "GetRequest",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return GetAggregationEventRequestMultiError(errors)
	}

	return nil
}

// GetAggregationEventRequestMultiError is an error wrapping multiple
// validation errors returned by GetAggregationEventRequest.ValidateAll() if
// the designated constraints aren't met.
type GetAggregationEventRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetAggregationEventRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetAggregationEventRequestMultiError) AllErrors() []error { return m }

// GetAggregationEventRequestValidationError is the validation error returned
// by GetAggregationEventRequest.Validate if the designated constraints aren't met.
type GetAggregationEventRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetAggregationEventRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetAggregationEventRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetAggregationEventRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetAggregationEventRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetAggregationEventRequestValidationError) ErrorName() string {
	return "GetAggregationEventRequestValidationError"
}

// Error satisfies the builtin error interface
func (e GetAggregationEventRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetAggregationEventRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetAggregationEventRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetAggregationEventRequestValidationError{}

// Validate checks the field values on GetAggregationEventResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetAggregationEventResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetAggregationEventResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetAggregationEventResponseMultiError, or nil if none found.
func (m *GetAggregationEventResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *GetAggregationEventResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetAggregationEvent()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetAggregationEventResponseValidationError{
					field:  "AggregationEvent",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetAggregationEventResponseValidationError{
					field:  "AggregationEvent",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetAggregationEvent()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetAggregationEventResponseValidationError{
				field:  "AggregationEvent",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return GetAggregationEventResponseMultiError(errors)
	}

	return nil
}

// GetAggregationEventResponseMultiError is an error wrapping multiple
// validation errors returned by GetAggregationEventResponse.ValidateAll() if
// the designated constraints aren't met.
type GetAggregationEventResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetAggregationEventResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetAggregationEventResponseMultiError) AllErrors() []error { return m }

// GetAggregationEventResponseValidationError is the validation error returned
// by GetAggregationEventResponse.Validate if the designated constraints
// aren't met.
type GetAggregationEventResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetAggregationEventResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetAggregationEventResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetAggregationEventResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetAggregationEventResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetAggregationEventResponseValidationError) ErrorName() string {
	return "GetAggregationEventResponseValidationError"
}

// Error satisfies the builtin error interface
func (e GetAggregationEventResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetAggregationEventResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetAggregationEventResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetAggregationEventResponseValidationError{}

// Validate checks the field values on GetAggregationEventsRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetAggregationEventsRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetAggregationEventsRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetAggregationEventsRequestMultiError, or nil if none found.
func (m *GetAggregationEventsRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GetAggregationEventsRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Limit

	// no validation rules for NextCursor

	// no validation rules for UserEmail

	// no validation rules for RequestId

	if len(errors) > 0 {
		return GetAggregationEventsRequestMultiError(errors)
	}

	return nil
}

// GetAggregationEventsRequestMultiError is an error wrapping multiple
// validation errors returned by GetAggregationEventsRequest.ValidateAll() if
// the designated constraints aren't met.
type GetAggregationEventsRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetAggregationEventsRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetAggregationEventsRequestMultiError) AllErrors() []error { return m }

// GetAggregationEventsRequestValidationError is the validation error returned
// by GetAggregationEventsRequest.Validate if the designated constraints
// aren't met.
type GetAggregationEventsRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetAggregationEventsRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetAggregationEventsRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetAggregationEventsRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetAggregationEventsRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetAggregationEventsRequestValidationError) ErrorName() string {
	return "GetAggregationEventsRequestValidationError"
}

// Error satisfies the builtin error interface
func (e GetAggregationEventsRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetAggregationEventsRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetAggregationEventsRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetAggregationEventsRequestValidationError{}

// Validate checks the field values on GetAggregationEventsResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetAggregationEventsResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetAggregationEventsResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetAggregationEventsResponseMultiError, or nil if none found.
func (m *GetAggregationEventsResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *GetAggregationEventsResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetAggregationEvents() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, GetAggregationEventsResponseValidationError{
						field:  fmt.Sprintf("AggregationEvents[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, GetAggregationEventsResponseValidationError{
						field:  fmt.Sprintf("AggregationEvents[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return GetAggregationEventsResponseValidationError{
					field:  fmt.Sprintf("AggregationEvents[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for NextCursor

	if len(errors) > 0 {
		return GetAggregationEventsResponseMultiError(errors)
	}

	return nil
}

// GetAggregationEventsResponseMultiError is an error wrapping multiple
// validation errors returned by GetAggregationEventsResponse.ValidateAll() if
// the designated constraints aren't met.
type GetAggregationEventsResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetAggregationEventsResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetAggregationEventsResponseMultiError) AllErrors() []error { return m }

// GetAggregationEventsResponseValidationError is the validation error returned
// by GetAggregationEventsResponse.Validate if the designated constraints
// aren't met.
type GetAggregationEventsResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetAggregationEventsResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetAggregationEventsResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetAggregationEventsResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetAggregationEventsResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetAggregationEventsResponseValidationError) ErrorName() string {
	return "GetAggregationEventsResponseValidationError"
}

// Error satisfies the builtin error interface
func (e GetAggregationEventsResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetAggregationEventsResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetAggregationEventsResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetAggregationEventsResponseValidationError{}

// Validate checks the field values on AssociationEvent with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *AssociationEvent) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on AssociationEvent with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// AssociationEventMultiError, or nil if none found.
func (m *AssociationEvent) ValidateAll() error {
	return m.validate(true)
}

func (m *AssociationEvent) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetEpcisEventD()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, AssociationEventValidationError{
					field:  "EpcisEventD",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, AssociationEventValidationError{
					field:  "EpcisEventD",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetEpcisEventD()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return AssociationEventValidationError{
				field:  "EpcisEventD",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetEpcisEventT()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, AssociationEventValidationError{
					field:  "EpcisEventT",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, AssociationEventValidationError{
					field:  "EpcisEventT",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetEpcisEventT()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return AssociationEventValidationError{
				field:  "EpcisEventT",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetErrorDeclarationD()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, AssociationEventValidationError{
					field:  "ErrorDeclarationD",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, AssociationEventValidationError{
					field:  "ErrorDeclarationD",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetErrorDeclarationD()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return AssociationEventValidationError{
				field:  "ErrorDeclarationD",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetErrorDeclarationT()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, AssociationEventValidationError{
					field:  "ErrorDeclarationT",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, AssociationEventValidationError{
					field:  "ErrorDeclarationT",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetErrorDeclarationT()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return AssociationEventValidationError{
				field:  "ErrorDeclarationT",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetAssociationEventD()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, AssociationEventValidationError{
					field:  "AssociationEventD",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, AssociationEventValidationError{
					field:  "AssociationEventD",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetAssociationEventD()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return AssociationEventValidationError{
				field:  "AssociationEventD",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetCrUpdUser()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, AssociationEventValidationError{
					field:  "CrUpdUser",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, AssociationEventValidationError{
					field:  "CrUpdUser",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCrUpdUser()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return AssociationEventValidationError{
				field:  "CrUpdUser",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	for idx, item := range m.GetPersistentDispositions() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, AssociationEventValidationError{
						field:  fmt.Sprintf("PersistentDispositions[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, AssociationEventValidationError{
						field:  fmt.Sprintf("PersistentDispositions[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return AssociationEventValidationError{
					field:  fmt.Sprintf("PersistentDispositions[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetChildEpcs() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, AssociationEventValidationError{
						field:  fmt.Sprintf("ChildEpcs[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, AssociationEventValidationError{
						field:  fmt.Sprintf("ChildEpcs[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return AssociationEventValidationError{
					field:  fmt.Sprintf("ChildEpcs[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetBizTransactionList() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, AssociationEventValidationError{
						field:  fmt.Sprintf("BizTransactionList[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, AssociationEventValidationError{
						field:  fmt.Sprintf("BizTransactionList[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return AssociationEventValidationError{
					field:  fmt.Sprintf("BizTransactionList[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetChildQuantityList() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, AssociationEventValidationError{
						field:  fmt.Sprintf("ChildQuantityList[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, AssociationEventValidationError{
						field:  fmt.Sprintf("ChildQuantityList[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return AssociationEventValidationError{
					field:  fmt.Sprintf("ChildQuantityList[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetSourceList() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, AssociationEventValidationError{
						field:  fmt.Sprintf("SourceList[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, AssociationEventValidationError{
						field:  fmt.Sprintf("SourceList[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return AssociationEventValidationError{
					field:  fmt.Sprintf("SourceList[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetDestinationList() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, AssociationEventValidationError{
						field:  fmt.Sprintf("DestinationList[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, AssociationEventValidationError{
						field:  fmt.Sprintf("DestinationList[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return AssociationEventValidationError{
					field:  fmt.Sprintf("DestinationList[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetSensorElementList() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, AssociationEventValidationError{
						field:  fmt.Sprintf("SensorElementList[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, AssociationEventValidationError{
						field:  fmt.Sprintf("SensorElementList[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return AssociationEventValidationError{
					field:  fmt.Sprintf("SensorElementList[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return AssociationEventMultiError(errors)
	}

	return nil
}

// AssociationEventMultiError is an error wrapping multiple validation errors
// returned by AssociationEvent.ValidateAll() if the designated constraints
// aren't met.
type AssociationEventMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AssociationEventMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AssociationEventMultiError) AllErrors() []error { return m }

// AssociationEventValidationError is the validation error returned by
// AssociationEvent.Validate if the designated constraints aren't met.
type AssociationEventValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AssociationEventValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AssociationEventValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AssociationEventValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AssociationEventValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AssociationEventValidationError) ErrorName() string { return "AssociationEventValidationError" }

// Error satisfies the builtin error interface
func (e AssociationEventValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAssociationEvent.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AssociationEventValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AssociationEventValidationError{}

// Validate checks the field values on AssociationEventD with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *AssociationEventD) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on AssociationEventD with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// AssociationEventDMultiError, or nil if none found.
func (m *AssociationEventD) ValidateAll() error {
	return m.validate(true)
}

func (m *AssociationEventD) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for Uuid4

	// no validation rules for IdS

	// no validation rules for ParentId

	// no validation rules for Action

	// no validation rules for BizStep

	// no validation rules for Disposition

	// no validation rules for ReadPoint

	// no validation rules for BizLocation

	if len(errors) > 0 {
		return AssociationEventDMultiError(errors)
	}

	return nil
}

// AssociationEventDMultiError is an error wrapping multiple validation errors
// returned by AssociationEventD.ValidateAll() if the designated constraints
// aren't met.
type AssociationEventDMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AssociationEventDMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AssociationEventDMultiError) AllErrors() []error { return m }

// AssociationEventDValidationError is the validation error returned by
// AssociationEventD.Validate if the designated constraints aren't met.
type AssociationEventDValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AssociationEventDValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AssociationEventDValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AssociationEventDValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AssociationEventDValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AssociationEventDValidationError) ErrorName() string {
	return "AssociationEventDValidationError"
}

// Error satisfies the builtin error interface
func (e AssociationEventDValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAssociationEventD.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AssociationEventDValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AssociationEventDValidationError{}

// Validate checks the field values on CreateAssociationEventRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CreateAssociationEventRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateAssociationEventRequest with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// CreateAssociationEventRequestMultiError, or nil if none found.
func (m *CreateAssociationEventRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateAssociationEventRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for EventId

	// no validation rules for EventTimeZoneOffset

	// no validation rules for Certification

	// no validation rules for EventTime

	// no validation rules for Reason

	// no validation rules for DeclarationTime

	// no validation rules for ParentId

	// no validation rules for Action

	// no validation rules for BizStep

	// no validation rules for Disposition

	// no validation rules for ReadPoint

	// no validation rules for BizLocation

	// no validation rules for UserId

	// no validation rules for UserEmail

	// no validation rules for RequestId

	for idx, item := range m.GetPersistentDispositions() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, CreateAssociationEventRequestValidationError{
						field:  fmt.Sprintf("PersistentDispositions[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, CreateAssociationEventRequestValidationError{
						field:  fmt.Sprintf("PersistentDispositions[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return CreateAssociationEventRequestValidationError{
					field:  fmt.Sprintf("PersistentDispositions[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetChildEpcs() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, CreateAssociationEventRequestValidationError{
						field:  fmt.Sprintf("ChildEpcs[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, CreateAssociationEventRequestValidationError{
						field:  fmt.Sprintf("ChildEpcs[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return CreateAssociationEventRequestValidationError{
					field:  fmt.Sprintf("ChildEpcs[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetBizTransactionList() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, CreateAssociationEventRequestValidationError{
						field:  fmt.Sprintf("BizTransactionList[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, CreateAssociationEventRequestValidationError{
						field:  fmt.Sprintf("BizTransactionList[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return CreateAssociationEventRequestValidationError{
					field:  fmt.Sprintf("BizTransactionList[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetChildQuantityList() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, CreateAssociationEventRequestValidationError{
						field:  fmt.Sprintf("ChildQuantityList[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, CreateAssociationEventRequestValidationError{
						field:  fmt.Sprintf("ChildQuantityList[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return CreateAssociationEventRequestValidationError{
					field:  fmt.Sprintf("ChildQuantityList[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetSourceList() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, CreateAssociationEventRequestValidationError{
						field:  fmt.Sprintf("SourceList[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, CreateAssociationEventRequestValidationError{
						field:  fmt.Sprintf("SourceList[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return CreateAssociationEventRequestValidationError{
					field:  fmt.Sprintf("SourceList[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetDestinationList() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, CreateAssociationEventRequestValidationError{
						field:  fmt.Sprintf("DestinationList[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, CreateAssociationEventRequestValidationError{
						field:  fmt.Sprintf("DestinationList[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return CreateAssociationEventRequestValidationError{
					field:  fmt.Sprintf("DestinationList[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetSensorElementList() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, CreateAssociationEventRequestValidationError{
						field:  fmt.Sprintf("SensorElementList[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, CreateAssociationEventRequestValidationError{
						field:  fmt.Sprintf("SensorElementList[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return CreateAssociationEventRequestValidationError{
					field:  fmt.Sprintf("SensorElementList[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return CreateAssociationEventRequestMultiError(errors)
	}

	return nil
}

// CreateAssociationEventRequestMultiError is an error wrapping multiple
// validation errors returned by CreateAssociationEventRequest.ValidateAll()
// if the designated constraints aren't met.
type CreateAssociationEventRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateAssociationEventRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateAssociationEventRequestMultiError) AllErrors() []error { return m }

// CreateAssociationEventRequestValidationError is the validation error
// returned by CreateAssociationEventRequest.Validate if the designated
// constraints aren't met.
type CreateAssociationEventRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateAssociationEventRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateAssociationEventRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateAssociationEventRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateAssociationEventRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateAssociationEventRequestValidationError) ErrorName() string {
	return "CreateAssociationEventRequestValidationError"
}

// Error satisfies the builtin error interface
func (e CreateAssociationEventRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateAssociationEventRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateAssociationEventRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateAssociationEventRequestValidationError{}

// Validate checks the field values on CreateAssociationEventResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CreateAssociationEventResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateAssociationEventResponse with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// CreateAssociationEventResponseMultiError, or nil if none found.
func (m *CreateAssociationEventResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateAssociationEventResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetAssociationEvent()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreateAssociationEventResponseValidationError{
					field:  "AssociationEvent",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreateAssociationEventResponseValidationError{
					field:  "AssociationEvent",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetAssociationEvent()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreateAssociationEventResponseValidationError{
				field:  "AssociationEvent",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return CreateAssociationEventResponseMultiError(errors)
	}

	return nil
}

// CreateAssociationEventResponseMultiError is an error wrapping multiple
// validation errors returned by CreateAssociationEventResponse.ValidateAll()
// if the designated constraints aren't met.
type CreateAssociationEventResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateAssociationEventResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateAssociationEventResponseMultiError) AllErrors() []error { return m }

// CreateAssociationEventResponseValidationError is the validation error
// returned by CreateAssociationEventResponse.Validate if the designated
// constraints aren't met.
type CreateAssociationEventResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateAssociationEventResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateAssociationEventResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateAssociationEventResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateAssociationEventResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateAssociationEventResponseValidationError) ErrorName() string {
	return "CreateAssociationEventResponseValidationError"
}

// Error satisfies the builtin error interface
func (e CreateAssociationEventResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateAssociationEventResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateAssociationEventResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateAssociationEventResponseValidationError{}

// Validate checks the field values on GetAssociationEventRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetAssociationEventRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetAssociationEventRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetAssociationEventRequestMultiError, or nil if none found.
func (m *GetAssociationEventRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GetAssociationEventRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetGetRequest()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetAssociationEventRequestValidationError{
					field:  "GetRequest",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetAssociationEventRequestValidationError{
					field:  "GetRequest",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetGetRequest()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetAssociationEventRequestValidationError{
				field:  "GetRequest",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return GetAssociationEventRequestMultiError(errors)
	}

	return nil
}

// GetAssociationEventRequestMultiError is an error wrapping multiple
// validation errors returned by GetAssociationEventRequest.ValidateAll() if
// the designated constraints aren't met.
type GetAssociationEventRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetAssociationEventRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetAssociationEventRequestMultiError) AllErrors() []error { return m }

// GetAssociationEventRequestValidationError is the validation error returned
// by GetAssociationEventRequest.Validate if the designated constraints aren't met.
type GetAssociationEventRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetAssociationEventRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetAssociationEventRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetAssociationEventRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetAssociationEventRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetAssociationEventRequestValidationError) ErrorName() string {
	return "GetAssociationEventRequestValidationError"
}

// Error satisfies the builtin error interface
func (e GetAssociationEventRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetAssociationEventRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetAssociationEventRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetAssociationEventRequestValidationError{}

// Validate checks the field values on GetAssociationEventResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetAssociationEventResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetAssociationEventResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetAssociationEventResponseMultiError, or nil if none found.
func (m *GetAssociationEventResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *GetAssociationEventResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetAssociationEvent()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetAssociationEventResponseValidationError{
					field:  "AssociationEvent",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetAssociationEventResponseValidationError{
					field:  "AssociationEvent",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetAssociationEvent()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetAssociationEventResponseValidationError{
				field:  "AssociationEvent",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return GetAssociationEventResponseMultiError(errors)
	}

	return nil
}

// GetAssociationEventResponseMultiError is an error wrapping multiple
// validation errors returned by GetAssociationEventResponse.ValidateAll() if
// the designated constraints aren't met.
type GetAssociationEventResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetAssociationEventResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetAssociationEventResponseMultiError) AllErrors() []error { return m }

// GetAssociationEventResponseValidationError is the validation error returned
// by GetAssociationEventResponse.Validate if the designated constraints
// aren't met.
type GetAssociationEventResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetAssociationEventResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetAssociationEventResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetAssociationEventResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetAssociationEventResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetAssociationEventResponseValidationError) ErrorName() string {
	return "GetAssociationEventResponseValidationError"
}

// Error satisfies the builtin error interface
func (e GetAssociationEventResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetAssociationEventResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetAssociationEventResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetAssociationEventResponseValidationError{}

// Validate checks the field values on GetAssociationEventsRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetAssociationEventsRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetAssociationEventsRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetAssociationEventsRequestMultiError, or nil if none found.
func (m *GetAssociationEventsRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GetAssociationEventsRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Limit

	// no validation rules for NextCursor

	// no validation rules for UserEmail

	// no validation rules for RequestId

	if len(errors) > 0 {
		return GetAssociationEventsRequestMultiError(errors)
	}

	return nil
}

// GetAssociationEventsRequestMultiError is an error wrapping multiple
// validation errors returned by GetAssociationEventsRequest.ValidateAll() if
// the designated constraints aren't met.
type GetAssociationEventsRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetAssociationEventsRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetAssociationEventsRequestMultiError) AllErrors() []error { return m }

// GetAssociationEventsRequestValidationError is the validation error returned
// by GetAssociationEventsRequest.Validate if the designated constraints
// aren't met.
type GetAssociationEventsRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetAssociationEventsRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetAssociationEventsRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetAssociationEventsRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetAssociationEventsRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetAssociationEventsRequestValidationError) ErrorName() string {
	return "GetAssociationEventsRequestValidationError"
}

// Error satisfies the builtin error interface
func (e GetAssociationEventsRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetAssociationEventsRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetAssociationEventsRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetAssociationEventsRequestValidationError{}

// Validate checks the field values on GetAssociationEventsResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetAssociationEventsResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetAssociationEventsResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetAssociationEventsResponseMultiError, or nil if none found.
func (m *GetAssociationEventsResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *GetAssociationEventsResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetAssociationEvents() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, GetAssociationEventsResponseValidationError{
						field:  fmt.Sprintf("AssociationEvents[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, GetAssociationEventsResponseValidationError{
						field:  fmt.Sprintf("AssociationEvents[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return GetAssociationEventsResponseValidationError{
					field:  fmt.Sprintf("AssociationEvents[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for NextCursor

	if len(errors) > 0 {
		return GetAssociationEventsResponseMultiError(errors)
	}

	return nil
}

// GetAssociationEventsResponseMultiError is an error wrapping multiple
// validation errors returned by GetAssociationEventsResponse.ValidateAll() if
// the designated constraints aren't met.
type GetAssociationEventsResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetAssociationEventsResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetAssociationEventsResponseMultiError) AllErrors() []error { return m }

// GetAssociationEventsResponseValidationError is the validation error returned
// by GetAssociationEventsResponse.Validate if the designated constraints
// aren't met.
type GetAssociationEventsResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetAssociationEventsResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetAssociationEventsResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetAssociationEventsResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetAssociationEventsResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetAssociationEventsResponseValidationError) ErrorName() string {
	return "GetAssociationEventsResponseValidationError"
}

// Error satisfies the builtin error interface
func (e GetAssociationEventsResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetAssociationEventsResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetAssociationEventsResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetAssociationEventsResponseValidationError{}

// Validate checks the field values on TransactionEvent with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *TransactionEvent) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TransactionEvent with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// TransactionEventMultiError, or nil if none found.
func (m *TransactionEvent) ValidateAll() error {
	return m.validate(true)
}

func (m *TransactionEvent) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetEpcisEventD()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, TransactionEventValidationError{
					field:  "EpcisEventD",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, TransactionEventValidationError{
					field:  "EpcisEventD",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetEpcisEventD()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return TransactionEventValidationError{
				field:  "EpcisEventD",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetEpcisEventT()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, TransactionEventValidationError{
					field:  "EpcisEventT",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, TransactionEventValidationError{
					field:  "EpcisEventT",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetEpcisEventT()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return TransactionEventValidationError{
				field:  "EpcisEventT",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetErrorDeclarationD()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, TransactionEventValidationError{
					field:  "ErrorDeclarationD",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, TransactionEventValidationError{
					field:  "ErrorDeclarationD",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetErrorDeclarationD()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return TransactionEventValidationError{
				field:  "ErrorDeclarationD",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetErrorDeclarationT()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, TransactionEventValidationError{
					field:  "ErrorDeclarationT",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, TransactionEventValidationError{
					field:  "ErrorDeclarationT",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetErrorDeclarationT()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return TransactionEventValidationError{
				field:  "ErrorDeclarationT",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetTransactionEventD()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, TransactionEventValidationError{
					field:  "TransactionEventD",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, TransactionEventValidationError{
					field:  "TransactionEventD",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTransactionEventD()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return TransactionEventValidationError{
				field:  "TransactionEventD",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetCrUpdUser()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, TransactionEventValidationError{
					field:  "CrUpdUser",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, TransactionEventValidationError{
					field:  "CrUpdUser",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCrUpdUser()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return TransactionEventValidationError{
				field:  "CrUpdUser",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	for idx, item := range m.GetPersistentDispositions() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, TransactionEventValidationError{
						field:  fmt.Sprintf("PersistentDispositions[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, TransactionEventValidationError{
						field:  fmt.Sprintf("PersistentDispositions[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return TransactionEventValidationError{
					field:  fmt.Sprintf("PersistentDispositions[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetEpcList() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, TransactionEventValidationError{
						field:  fmt.Sprintf("EpcList[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, TransactionEventValidationError{
						field:  fmt.Sprintf("EpcList[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return TransactionEventValidationError{
					field:  fmt.Sprintf("EpcList[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetBizTransactionList() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, TransactionEventValidationError{
						field:  fmt.Sprintf("BizTransactionList[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, TransactionEventValidationError{
						field:  fmt.Sprintf("BizTransactionList[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return TransactionEventValidationError{
					field:  fmt.Sprintf("BizTransactionList[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetQuantityList() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, TransactionEventValidationError{
						field:  fmt.Sprintf("QuantityList[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, TransactionEventValidationError{
						field:  fmt.Sprintf("QuantityList[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return TransactionEventValidationError{
					field:  fmt.Sprintf("QuantityList[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetSourceList() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, TransactionEventValidationError{
						field:  fmt.Sprintf("SourceList[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, TransactionEventValidationError{
						field:  fmt.Sprintf("SourceList[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return TransactionEventValidationError{
					field:  fmt.Sprintf("SourceList[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetDestinationList() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, TransactionEventValidationError{
						field:  fmt.Sprintf("DestinationList[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, TransactionEventValidationError{
						field:  fmt.Sprintf("DestinationList[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return TransactionEventValidationError{
					field:  fmt.Sprintf("DestinationList[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetSensorElementList() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, TransactionEventValidationError{
						field:  fmt.Sprintf("SensorElementList[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, TransactionEventValidationError{
						field:  fmt.Sprintf("SensorElementList[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return TransactionEventValidationError{
					field:  fmt.Sprintf("SensorElementList[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return TransactionEventMultiError(errors)
	}

	return nil
}

// TransactionEventMultiError is an error wrapping multiple validation errors
// returned by TransactionEvent.ValidateAll() if the designated constraints
// aren't met.
type TransactionEventMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TransactionEventMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TransactionEventMultiError) AllErrors() []error { return m }

// TransactionEventValidationError is the validation error returned by
// TransactionEvent.Validate if the designated constraints aren't met.
type TransactionEventValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TransactionEventValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TransactionEventValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TransactionEventValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TransactionEventValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TransactionEventValidationError) ErrorName() string { return "TransactionEventValidationError" }

// Error satisfies the builtin error interface
func (e TransactionEventValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTransactionEvent.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TransactionEventValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TransactionEventValidationError{}

// Validate checks the field values on TransactionEventD with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *TransactionEventD) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TransactionEventD with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// TransactionEventDMultiError, or nil if none found.
func (m *TransactionEventD) ValidateAll() error {
	return m.validate(true)
}

func (m *TransactionEventD) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for Uuid4

	// no validation rules for IdS

	// no validation rules for ParentId

	// no validation rules for Action

	// no validation rules for BizStep

	// no validation rules for Disposition

	// no validation rules for ReadPoint

	// no validation rules for BizLocation

	if len(errors) > 0 {
		return TransactionEventDMultiError(errors)
	}

	return nil
}

// TransactionEventDMultiError is an error wrapping multiple validation errors
// returned by TransactionEventD.ValidateAll() if the designated constraints
// aren't met.
type TransactionEventDMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TransactionEventDMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TransactionEventDMultiError) AllErrors() []error { return m }

// TransactionEventDValidationError is the validation error returned by
// TransactionEventD.Validate if the designated constraints aren't met.
type TransactionEventDValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TransactionEventDValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TransactionEventDValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TransactionEventDValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TransactionEventDValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TransactionEventDValidationError) ErrorName() string {
	return "TransactionEventDValidationError"
}

// Error satisfies the builtin error interface
func (e TransactionEventDValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTransactionEventD.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TransactionEventDValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TransactionEventDValidationError{}

// Validate checks the field values on CreateTransactionEventRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CreateTransactionEventRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateTransactionEventRequest with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// CreateTransactionEventRequestMultiError, or nil if none found.
func (m *CreateTransactionEventRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateTransactionEventRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for EventId

	// no validation rules for EventTimeZoneOffset

	// no validation rules for Certification

	// no validation rules for EventTime

	// no validation rules for Reason

	// no validation rules for DeclarationTime

	// no validation rules for ParentId

	// no validation rules for Action

	// no validation rules for BizStep

	// no validation rules for Disposition

	// no validation rules for ReadPoint

	// no validation rules for BizLocation

	// no validation rules for UserId

	// no validation rules for UserEmail

	// no validation rules for RequestId

	for idx, item := range m.GetPersistentDispositions() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, CreateTransactionEventRequestValidationError{
						field:  fmt.Sprintf("PersistentDispositions[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, CreateTransactionEventRequestValidationError{
						field:  fmt.Sprintf("PersistentDispositions[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return CreateTransactionEventRequestValidationError{
					field:  fmt.Sprintf("PersistentDispositions[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetEpcList() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, CreateTransactionEventRequestValidationError{
						field:  fmt.Sprintf("EpcList[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, CreateTransactionEventRequestValidationError{
						field:  fmt.Sprintf("EpcList[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return CreateTransactionEventRequestValidationError{
					field:  fmt.Sprintf("EpcList[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetBizTransactionList() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, CreateTransactionEventRequestValidationError{
						field:  fmt.Sprintf("BizTransactionList[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, CreateTransactionEventRequestValidationError{
						field:  fmt.Sprintf("BizTransactionList[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return CreateTransactionEventRequestValidationError{
					field:  fmt.Sprintf("BizTransactionList[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetQuantityList() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, CreateTransactionEventRequestValidationError{
						field:  fmt.Sprintf("QuantityList[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, CreateTransactionEventRequestValidationError{
						field:  fmt.Sprintf("QuantityList[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return CreateTransactionEventRequestValidationError{
					field:  fmt.Sprintf("QuantityList[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetSourceList() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, CreateTransactionEventRequestValidationError{
						field:  fmt.Sprintf("SourceList[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, CreateTransactionEventRequestValidationError{
						field:  fmt.Sprintf("SourceList[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return CreateTransactionEventRequestValidationError{
					field:  fmt.Sprintf("SourceList[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetDestinationList() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, CreateTransactionEventRequestValidationError{
						field:  fmt.Sprintf("DestinationList[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, CreateTransactionEventRequestValidationError{
						field:  fmt.Sprintf("DestinationList[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return CreateTransactionEventRequestValidationError{
					field:  fmt.Sprintf("DestinationList[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetSensorElementList() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, CreateTransactionEventRequestValidationError{
						field:  fmt.Sprintf("SensorElementList[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, CreateTransactionEventRequestValidationError{
						field:  fmt.Sprintf("SensorElementList[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return CreateTransactionEventRequestValidationError{
					field:  fmt.Sprintf("SensorElementList[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return CreateTransactionEventRequestMultiError(errors)
	}

	return nil
}

// CreateTransactionEventRequestMultiError is an error wrapping multiple
// validation errors returned by CreateTransactionEventRequest.ValidateAll()
// if the designated constraints aren't met.
type CreateTransactionEventRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateTransactionEventRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateTransactionEventRequestMultiError) AllErrors() []error { return m }

// CreateTransactionEventRequestValidationError is the validation error
// returned by CreateTransactionEventRequest.Validate if the designated
// constraints aren't met.
type CreateTransactionEventRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateTransactionEventRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateTransactionEventRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateTransactionEventRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateTransactionEventRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateTransactionEventRequestValidationError) ErrorName() string {
	return "CreateTransactionEventRequestValidationError"
}

// Error satisfies the builtin error interface
func (e CreateTransactionEventRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateTransactionEventRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateTransactionEventRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateTransactionEventRequestValidationError{}

// Validate checks the field values on CreateTransactionEventResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CreateTransactionEventResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateTransactionEventResponse with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// CreateTransactionEventResponseMultiError, or nil if none found.
func (m *CreateTransactionEventResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateTransactionEventResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetTransactionEvent()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreateTransactionEventResponseValidationError{
					field:  "TransactionEvent",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreateTransactionEventResponseValidationError{
					field:  "TransactionEvent",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTransactionEvent()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreateTransactionEventResponseValidationError{
				field:  "TransactionEvent",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return CreateTransactionEventResponseMultiError(errors)
	}

	return nil
}

// CreateTransactionEventResponseMultiError is an error wrapping multiple
// validation errors returned by CreateTransactionEventResponse.ValidateAll()
// if the designated constraints aren't met.
type CreateTransactionEventResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateTransactionEventResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateTransactionEventResponseMultiError) AllErrors() []error { return m }

// CreateTransactionEventResponseValidationError is the validation error
// returned by CreateTransactionEventResponse.Validate if the designated
// constraints aren't met.
type CreateTransactionEventResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateTransactionEventResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateTransactionEventResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateTransactionEventResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateTransactionEventResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateTransactionEventResponseValidationError) ErrorName() string {
	return "CreateTransactionEventResponseValidationError"
}

// Error satisfies the builtin error interface
func (e CreateTransactionEventResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateTransactionEventResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateTransactionEventResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateTransactionEventResponseValidationError{}

// Validate checks the field values on GetTransactionEventRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetTransactionEventRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetTransactionEventRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetTransactionEventRequestMultiError, or nil if none found.
func (m *GetTransactionEventRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GetTransactionEventRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetGetRequest()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetTransactionEventRequestValidationError{
					field:  "GetRequest",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetTransactionEventRequestValidationError{
					field:  "GetRequest",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetGetRequest()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetTransactionEventRequestValidationError{
				field:  "GetRequest",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return GetTransactionEventRequestMultiError(errors)
	}

	return nil
}

// GetTransactionEventRequestMultiError is an error wrapping multiple
// validation errors returned by GetTransactionEventRequest.ValidateAll() if
// the designated constraints aren't met.
type GetTransactionEventRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetTransactionEventRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetTransactionEventRequestMultiError) AllErrors() []error { return m }

// GetTransactionEventRequestValidationError is the validation error returned
// by GetTransactionEventRequest.Validate if the designated constraints aren't met.
type GetTransactionEventRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetTransactionEventRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetTransactionEventRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetTransactionEventRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetTransactionEventRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetTransactionEventRequestValidationError) ErrorName() string {
	return "GetTransactionEventRequestValidationError"
}

// Error satisfies the builtin error interface
func (e GetTransactionEventRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetTransactionEventRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetTransactionEventRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetTransactionEventRequestValidationError{}

// Validate checks the field values on GetTransactionEventResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetTransactionEventResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetTransactionEventResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetTransactionEventResponseMultiError, or nil if none found.
func (m *GetTransactionEventResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *GetTransactionEventResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetTransactionEvent()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetTransactionEventResponseValidationError{
					field:  "TransactionEvent",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetTransactionEventResponseValidationError{
					field:  "TransactionEvent",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTransactionEvent()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetTransactionEventResponseValidationError{
				field:  "TransactionEvent",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return GetTransactionEventResponseMultiError(errors)
	}

	return nil
}

// GetTransactionEventResponseMultiError is an error wrapping multiple
// validation errors returned by GetTransactionEventResponse.ValidateAll() if
// the designated constraints aren't met.
type GetTransactionEventResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetTransactionEventResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetTransactionEventResponseMultiError) AllErrors() []error { return m }

// GetTransactionEventResponseValidationError is the validation error returned
// by GetTransactionEventResponse.Validate if the designated constraints
// aren't met.
type GetTransactionEventResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetTransactionEventResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetTransactionEventResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetTransactionEventResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetTransactionEventResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetTransactionEventResponseValidationError) ErrorName() string {
	return "GetTransactionEventResponseValidationError"
}

// Error satisfies the builtin error interface
func (e GetTransactionEventResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetTransactionEventResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetTransactionEventResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetTransactionEventResponseValidationError{}

// Validate checks the field values on GetTransactionEventsRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetTransactionEventsRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetTransactionEventsRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetTransactionEventsRequestMultiError, or nil if none found.
func (m *GetTransactionEventsRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GetTransactionEventsRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Limit

	// no validation rules for NextCursor

	// no validation rules for UserEmail

	// no validation rules for RequestId

	if len(errors) > 0 {
		return GetTransactionEventsRequestMultiError(errors)
	}

	return nil
}

// GetTransactionEventsRequestMultiError is an error wrapping multiple
// validation errors returned by GetTransactionEventsRequest.ValidateAll() if
// the designated constraints aren't met.
type GetTransactionEventsRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetTransactionEventsRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetTransactionEventsRequestMultiError) AllErrors() []error { return m }

// GetTransactionEventsRequestValidationError is the validation error returned
// by GetTransactionEventsRequest.Validate if the designated constraints
// aren't met.
type GetTransactionEventsRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetTransactionEventsRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetTransactionEventsRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetTransactionEventsRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetTransactionEventsRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetTransactionEventsRequestValidationError) ErrorName() string {
	return "GetTransactionEventsRequestValidationError"
}

// Error satisfies the builtin error interface
func (e GetTransactionEventsRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetTransactionEventsRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetTransactionEventsRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetTransactionEventsRequestValidationError{}

// Validate checks the field values on GetTransactionEventsResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetTransactionEventsResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetTransactionEventsResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetTransactionEventsResponseMultiError, or nil if none found.
func (m *GetTransactionEventsResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *GetTransactionEventsResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetTransactionEvents() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, GetTransactionEventsResponseValidationError{
						field:  fmt.Sprintf("TransactionEvents[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, GetTransactionEventsResponseValidationError{
						field:  fmt.Sprintf("TransactionEvents[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return GetTransactionEventsResponseValidationError{
					field:  fmt.Sprintf("TransactionEvents[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for NextCursor

	if len(errors) > 0 {
		return GetTransactionEventsResponseMultiError(errors)
	}

	return nil
}

// GetTransactionEventsResponseMultiError is an error wrapping multiple
// validation errors returned by GetTransactionEventsResponse.ValidateAll() if
// the designated constraints aren't met.
type GetTransactionEventsResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetTransactionEventsResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetTransactionEventsResponseMultiError) AllErrors() []error { return m }

// GetTransactionEventsResponseValidationError is the validation error returned
// by GetTransactionEventsResponse.Validate if the designated constraints
// aren't met.
type GetTransactionEventsResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetTransactionEventsResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetTransactionEventsResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetTransactionEventsResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetTransactionEventsResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetTransactionEventsResponseValidationError) ErrorName() string {
	return "GetTransactionEventsResponseValidationError"
}

// Error satisfies the builtin error interface
func (e GetTransactionEventsResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetTransactionEventsResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetTransactionEventsResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetTransactionEventsResponseValidationError{}

// Validate checks the field values on TransformationEvent with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *TransformationEvent) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TransformationEvent with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// TransformationEventMultiError, or nil if none found.
func (m *TransformationEvent) ValidateAll() error {
	return m.validate(true)
}

func (m *TransformationEvent) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetEpcisEventD()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, TransformationEventValidationError{
					field:  "EpcisEventD",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, TransformationEventValidationError{
					field:  "EpcisEventD",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetEpcisEventD()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return TransformationEventValidationError{
				field:  "EpcisEventD",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetEpcisEventT()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, TransformationEventValidationError{
					field:  "EpcisEventT",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, TransformationEventValidationError{
					field:  "EpcisEventT",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetEpcisEventT()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return TransformationEventValidationError{
				field:  "EpcisEventT",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetErrorDeclarationD()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, TransformationEventValidationError{
					field:  "ErrorDeclarationD",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, TransformationEventValidationError{
					field:  "ErrorDeclarationD",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetErrorDeclarationD()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return TransformationEventValidationError{
				field:  "ErrorDeclarationD",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetErrorDeclarationT()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, TransformationEventValidationError{
					field:  "ErrorDeclarationT",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, TransformationEventValidationError{
					field:  "ErrorDeclarationT",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetErrorDeclarationT()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return TransformationEventValidationError{
				field:  "ErrorDeclarationT",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetTransformationEventD()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, TransformationEventValidationError{
					field:  "TransformationEventD",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, TransformationEventValidationError{
					field:  "TransformationEventD",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTransformationEventD()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return TransformationEventValidationError{
				field:  "TransformationEventD",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetCrUpdUser()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, TransformationEventValidationError{
					field:  "CrUpdUser",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, TransformationEventValidationError{
					field:  "CrUpdUser",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCrUpdUser()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return TransformationEventValidationError{
				field:  "CrUpdUser",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	for idx, item := range m.GetInputEpcList() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, TransformationEventValidationError{
						field:  fmt.Sprintf("InputEpcList[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, TransformationEventValidationError{
						field:  fmt.Sprintf("InputEpcList[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return TransformationEventValidationError{
					field:  fmt.Sprintf("InputEpcList[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetInputQuantityList() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, TransformationEventValidationError{
						field:  fmt.Sprintf("InputQuantityList[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, TransformationEventValidationError{
						field:  fmt.Sprintf("InputQuantityList[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return TransformationEventValidationError{
					field:  fmt.Sprintf("InputQuantityList[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetOutputEpcList() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, TransformationEventValidationError{
						field:  fmt.Sprintf("OutputEpcList[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, TransformationEventValidationError{
						field:  fmt.Sprintf("OutputEpcList[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return TransformationEventValidationError{
					field:  fmt.Sprintf("OutputEpcList[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetOutputQuantityList() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, TransformationEventValidationError{
						field:  fmt.Sprintf("OutputQuantityList[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, TransformationEventValidationError{
						field:  fmt.Sprintf("OutputQuantityList[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return TransformationEventValidationError{
					field:  fmt.Sprintf("OutputQuantityList[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetPersistentDispositions() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, TransformationEventValidationError{
						field:  fmt.Sprintf("PersistentDispositions[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, TransformationEventValidationError{
						field:  fmt.Sprintf("PersistentDispositions[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return TransformationEventValidationError{
					field:  fmt.Sprintf("PersistentDispositions[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetBizTransactionList() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, TransformationEventValidationError{
						field:  fmt.Sprintf("BizTransactionList[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, TransformationEventValidationError{
						field:  fmt.Sprintf("BizTransactionList[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return TransformationEventValidationError{
					field:  fmt.Sprintf("BizTransactionList[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetSourceList() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, TransformationEventValidationError{
						field:  fmt.Sprintf("SourceList[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, TransformationEventValidationError{
						field:  fmt.Sprintf("SourceList[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return TransformationEventValidationError{
					field:  fmt.Sprintf("SourceList[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetDestinationList() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, TransformationEventValidationError{
						field:  fmt.Sprintf("DestinationList[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, TransformationEventValidationError{
						field:  fmt.Sprintf("DestinationList[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return TransformationEventValidationError{
					field:  fmt.Sprintf("DestinationList[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetSensorElementList() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, TransformationEventValidationError{
						field:  fmt.Sprintf("SensorElementList[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, TransformationEventValidationError{
						field:  fmt.Sprintf("SensorElementList[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return TransformationEventValidationError{
					field:  fmt.Sprintf("SensorElementList[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return TransformationEventMultiError(errors)
	}

	return nil
}

// TransformationEventMultiError is an error wrapping multiple validation
// errors returned by TransformationEvent.ValidateAll() if the designated
// constraints aren't met.
type TransformationEventMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TransformationEventMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TransformationEventMultiError) AllErrors() []error { return m }

// TransformationEventValidationError is the validation error returned by
// TransformationEvent.Validate if the designated constraints aren't met.
type TransformationEventValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TransformationEventValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TransformationEventValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TransformationEventValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TransformationEventValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TransformationEventValidationError) ErrorName() string {
	return "TransformationEventValidationError"
}

// Error satisfies the builtin error interface
func (e TransformationEventValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTransformationEvent.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TransformationEventValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TransformationEventValidationError{}

// Validate checks the field values on TransformationEventD with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *TransformationEventD) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TransformationEventD with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// TransformationEventDMultiError, or nil if none found.
func (m *TransformationEventD) ValidateAll() error {
	return m.validate(true)
}

func (m *TransformationEventD) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for Uuid4

	// no validation rules for IdS

	// no validation rules for TransformationId

	// no validation rules for BizStep

	// no validation rules for Disposition

	// no validation rules for ReadPoint

	// no validation rules for BizLocation

	// no validation rules for Ilmd

	if len(errors) > 0 {
		return TransformationEventDMultiError(errors)
	}

	return nil
}

// TransformationEventDMultiError is an error wrapping multiple validation
// errors returned by TransformationEventD.ValidateAll() if the designated
// constraints aren't met.
type TransformationEventDMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TransformationEventDMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TransformationEventDMultiError) AllErrors() []error { return m }

// TransformationEventDValidationError is the validation error returned by
// TransformationEventD.Validate if the designated constraints aren't met.
type TransformationEventDValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TransformationEventDValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TransformationEventDValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TransformationEventDValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TransformationEventDValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TransformationEventDValidationError) ErrorName() string {
	return "TransformationEventDValidationError"
}

// Error satisfies the builtin error interface
func (e TransformationEventDValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTransformationEventD.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TransformationEventDValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TransformationEventDValidationError{}

// Validate checks the field values on CreateTransformationEventRequest with
// the rules defined in the proto definition for this message. If any rules
// are violated, the first error encountered is returned, or nil if there are
// no violations.
func (m *CreateTransformationEventRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateTransformationEventRequest with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// CreateTransformationEventRequestMultiError, or nil if none found.
func (m *CreateTransformationEventRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateTransformationEventRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for EventId

	// no validation rules for EventTimeZoneOffset

	// no validation rules for Certification

	// no validation rules for EventTime

	// no validation rules for Reason

	// no validation rules for DeclarationTime

	// no validation rules for TransformationId

	// no validation rules for BizStep

	// no validation rules for Disposition

	// no validation rules for ReadPoint

	// no validation rules for BizLocation

	// no validation rules for Ilmd

	// no validation rules for UserId

	// no validation rules for UserEmail

	// no validation rules for RequestId

	for idx, item := range m.GetInputEpcList() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, CreateTransformationEventRequestValidationError{
						field:  fmt.Sprintf("InputEpcList[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, CreateTransformationEventRequestValidationError{
						field:  fmt.Sprintf("InputEpcList[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return CreateTransformationEventRequestValidationError{
					field:  fmt.Sprintf("InputEpcList[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetInputQuantityList() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, CreateTransformationEventRequestValidationError{
						field:  fmt.Sprintf("InputQuantityList[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, CreateTransformationEventRequestValidationError{
						field:  fmt.Sprintf("InputQuantityList[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return CreateTransformationEventRequestValidationError{
					field:  fmt.Sprintf("InputQuantityList[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetOutputEpcList() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, CreateTransformationEventRequestValidationError{
						field:  fmt.Sprintf("OutputEpcList[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, CreateTransformationEventRequestValidationError{
						field:  fmt.Sprintf("OutputEpcList[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return CreateTransformationEventRequestValidationError{
					field:  fmt.Sprintf("OutputEpcList[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetOutputQuantityList() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, CreateTransformationEventRequestValidationError{
						field:  fmt.Sprintf("OutputQuantityList[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, CreateTransformationEventRequestValidationError{
						field:  fmt.Sprintf("OutputQuantityList[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return CreateTransformationEventRequestValidationError{
					field:  fmt.Sprintf("OutputQuantityList[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetPersistentDispositions() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, CreateTransformationEventRequestValidationError{
						field:  fmt.Sprintf("PersistentDispositions[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, CreateTransformationEventRequestValidationError{
						field:  fmt.Sprintf("PersistentDispositions[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return CreateTransformationEventRequestValidationError{
					field:  fmt.Sprintf("PersistentDispositions[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetBizTransactionList() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, CreateTransformationEventRequestValidationError{
						field:  fmt.Sprintf("BizTransactionList[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, CreateTransformationEventRequestValidationError{
						field:  fmt.Sprintf("BizTransactionList[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return CreateTransformationEventRequestValidationError{
					field:  fmt.Sprintf("BizTransactionList[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetSourceList() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, CreateTransformationEventRequestValidationError{
						field:  fmt.Sprintf("SourceList[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, CreateTransformationEventRequestValidationError{
						field:  fmt.Sprintf("SourceList[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return CreateTransformationEventRequestValidationError{
					field:  fmt.Sprintf("SourceList[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetDestinationList() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, CreateTransformationEventRequestValidationError{
						field:  fmt.Sprintf("DestinationList[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, CreateTransformationEventRequestValidationError{
						field:  fmt.Sprintf("DestinationList[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return CreateTransformationEventRequestValidationError{
					field:  fmt.Sprintf("DestinationList[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetSensorElementList() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, CreateTransformationEventRequestValidationError{
						field:  fmt.Sprintf("SensorElementList[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, CreateTransformationEventRequestValidationError{
						field:  fmt.Sprintf("SensorElementList[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return CreateTransformationEventRequestValidationError{
					field:  fmt.Sprintf("SensorElementList[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return CreateTransformationEventRequestMultiError(errors)
	}

	return nil
}

// CreateTransformationEventRequestMultiError is an error wrapping multiple
// validation errors returned by
// CreateTransformationEventRequest.ValidateAll() if the designated
// constraints aren't met.
type CreateTransformationEventRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateTransformationEventRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateTransformationEventRequestMultiError) AllErrors() []error { return m }

// CreateTransformationEventRequestValidationError is the validation error
// returned by CreateTransformationEventRequest.Validate if the designated
// constraints aren't met.
type CreateTransformationEventRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateTransformationEventRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateTransformationEventRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateTransformationEventRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateTransformationEventRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateTransformationEventRequestValidationError) ErrorName() string {
	return "CreateTransformationEventRequestValidationError"
}

// Error satisfies the builtin error interface
func (e CreateTransformationEventRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateTransformationEventRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateTransformationEventRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateTransformationEventRequestValidationError{}

// Validate checks the field values on CreateTransformationEventResponse with
// the rules defined in the proto definition for this message. If any rules
// are violated, the first error encountered is returned, or nil if there are
// no violations.
func (m *CreateTransformationEventResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateTransformationEventResponse
// with the rules defined in the proto definition for this message. If any
// rules are violated, the result is a list of violation errors wrapped in
// CreateTransformationEventResponseMultiError, or nil if none found.
func (m *CreateTransformationEventResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateTransformationEventResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetTransformationEvent()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreateTransformationEventResponseValidationError{
					field:  "TransformationEvent",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreateTransformationEventResponseValidationError{
					field:  "TransformationEvent",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTransformationEvent()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreateTransformationEventResponseValidationError{
				field:  "TransformationEvent",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return CreateTransformationEventResponseMultiError(errors)
	}

	return nil
}

// CreateTransformationEventResponseMultiError is an error wrapping multiple
// validation errors returned by
// CreateTransformationEventResponse.ValidateAll() if the designated
// constraints aren't met.
type CreateTransformationEventResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateTransformationEventResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateTransformationEventResponseMultiError) AllErrors() []error { return m }

// CreateTransformationEventResponseValidationError is the validation error
// returned by CreateTransformationEventResponse.Validate if the designated
// constraints aren't met.
type CreateTransformationEventResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateTransformationEventResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateTransformationEventResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateTransformationEventResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateTransformationEventResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateTransformationEventResponseValidationError) ErrorName() string {
	return "CreateTransformationEventResponseValidationError"
}

// Error satisfies the builtin error interface
func (e CreateTransformationEventResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateTransformationEventResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateTransformationEventResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateTransformationEventResponseValidationError{}

// Validate checks the field values on GetTransformationEventRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetTransformationEventRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetTransformationEventRequest with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// GetTransformationEventRequestMultiError, or nil if none found.
func (m *GetTransformationEventRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GetTransformationEventRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetGetRequest()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetTransformationEventRequestValidationError{
					field:  "GetRequest",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetTransformationEventRequestValidationError{
					field:  "GetRequest",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetGetRequest()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetTransformationEventRequestValidationError{
				field:  "GetRequest",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return GetTransformationEventRequestMultiError(errors)
	}

	return nil
}

// GetTransformationEventRequestMultiError is an error wrapping multiple
// validation errors returned by GetTransformationEventRequest.ValidateAll()
// if the designated constraints aren't met.
type GetTransformationEventRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetTransformationEventRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetTransformationEventRequestMultiError) AllErrors() []error { return m }

// GetTransformationEventRequestValidationError is the validation error
// returned by GetTransformationEventRequest.Validate if the designated
// constraints aren't met.
type GetTransformationEventRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetTransformationEventRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetTransformationEventRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetTransformationEventRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetTransformationEventRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetTransformationEventRequestValidationError) ErrorName() string {
	return "GetTransformationEventRequestValidationError"
}

// Error satisfies the builtin error interface
func (e GetTransformationEventRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetTransformationEventRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetTransformationEventRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetTransformationEventRequestValidationError{}

// Validate checks the field values on GetTransformationEventResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetTransformationEventResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetTransformationEventResponse with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// GetTransformationEventResponseMultiError, or nil if none found.
func (m *GetTransformationEventResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *GetTransformationEventResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetTransformationEvent()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetTransformationEventResponseValidationError{
					field:  "TransformationEvent",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetTransformationEventResponseValidationError{
					field:  "TransformationEvent",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTransformationEvent()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetTransformationEventResponseValidationError{
				field:  "TransformationEvent",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return GetTransformationEventResponseMultiError(errors)
	}

	return nil
}

// GetTransformationEventResponseMultiError is an error wrapping multiple
// validation errors returned by GetTransformationEventResponse.ValidateAll()
// if the designated constraints aren't met.
type GetTransformationEventResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetTransformationEventResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetTransformationEventResponseMultiError) AllErrors() []error { return m }

// GetTransformationEventResponseValidationError is the validation error
// returned by GetTransformationEventResponse.Validate if the designated
// constraints aren't met.
type GetTransformationEventResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetTransformationEventResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetTransformationEventResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetTransformationEventResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetTransformationEventResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetTransformationEventResponseValidationError) ErrorName() string {
	return "GetTransformationEventResponseValidationError"
}

// Error satisfies the builtin error interface
func (e GetTransformationEventResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetTransformationEventResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetTransformationEventResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetTransformationEventResponseValidationError{}

// Validate checks the field values on GetTransformationEventsRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetTransformationEventsRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetTransformationEventsRequest with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// GetTransformationEventsRequestMultiError, or nil if none found.
func (m *GetTransformationEventsRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GetTransformationEventsRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Limit

	// no validation rules for NextCursor

	// no validation rules for UserEmail

	// no validation rules for RequestId

	if len(errors) > 0 {
		return GetTransformationEventsRequestMultiError(errors)
	}

	return nil
}

// GetTransformationEventsRequestMultiError is an error wrapping multiple
// validation errors returned by GetTransformationEventsRequest.ValidateAll()
// if the designated constraints aren't met.
type GetTransformationEventsRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetTransformationEventsRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetTransformationEventsRequestMultiError) AllErrors() []error { return m }

// GetTransformationEventsRequestValidationError is the validation error
// returned by GetTransformationEventsRequest.Validate if the designated
// constraints aren't met.
type GetTransformationEventsRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetTransformationEventsRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetTransformationEventsRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetTransformationEventsRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetTransformationEventsRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetTransformationEventsRequestValidationError) ErrorName() string {
	return "GetTransformationEventsRequestValidationError"
}

// Error satisfies the builtin error interface
func (e GetTransformationEventsRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetTransformationEventsRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetTransformationEventsRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetTransformationEventsRequestValidationError{}

// Validate checks the field values on GetTransformationEventsResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetTransformationEventsResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetTransformationEventsResponse with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// GetTransformationEventsResponseMultiError, or nil if none found.
func (m *GetTransformationEventsResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *GetTransformationEventsResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetTransformationEvents() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, GetTransformationEventsResponseValidationError{
						field:  fmt.Sprintf("TransformationEvents[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, GetTransformationEventsResponseValidationError{
						field:  fmt.Sprintf("TransformationEvents[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return GetTransformationEventsResponseValidationError{
					field:  fmt.Sprintf("TransformationEvents[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for NextCursor

	if len(errors) > 0 {
		return GetTransformationEventsResponseMultiError(errors)
	}

	return nil
}

// GetTransformationEventsResponseMultiError is an error wrapping multiple
// validation errors returned by GetTransformationEventsResponse.ValidateAll()
// if the designated constraints aren't met.
type GetTransformationEventsResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetTransformationEventsResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetTransformationEventsResponseMultiError) AllErrors() []error { return m }

// GetTransformationEventsResponseValidationError is the validation error
// returned by GetTransformationEventsResponse.Validate if the designated
// constraints aren't met.
type GetTransformationEventsResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetTransformationEventsResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetTransformationEventsResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetTransformationEventsResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetTransformationEventsResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetTransformationEventsResponseValidationError) ErrorName() string {
	return "GetTransformationEventsResponseValidationError"
}

// Error satisfies the builtin error interface
func (e GetTransformationEventsResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetTransformationEventsResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetTransformationEventsResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetTransformationEventsResponseValidationError{}

// Validate checks the field values on PersistentDisposition with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *PersistentDisposition) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on PersistentDisposition with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// PersistentDispositionMultiError, or nil if none found.
func (m *PersistentDisposition) ValidateAll() error {
	return m.validate(true)
}

func (m *PersistentDisposition) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for SetDisp

	// no validation rules for UnsetDisp

	// no validation rules for EventId

	// no validation rules for TypeOfEvent

	if len(errors) > 0 {
		return PersistentDispositionMultiError(errors)
	}

	return nil
}

// PersistentDispositionMultiError is an error wrapping multiple validation
// errors returned by PersistentDisposition.ValidateAll() if the designated
// constraints aren't met.
type PersistentDispositionMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PersistentDispositionMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PersistentDispositionMultiError) AllErrors() []error { return m }

// PersistentDispositionValidationError is the validation error returned by
// PersistentDisposition.Validate if the designated constraints aren't met.
type PersistentDispositionValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PersistentDispositionValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PersistentDispositionValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PersistentDispositionValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PersistentDispositionValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PersistentDispositionValidationError) ErrorName() string {
	return "PersistentDispositionValidationError"
}

// Error satisfies the builtin error interface
func (e PersistentDispositionValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPersistentDisposition.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PersistentDispositionValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PersistentDispositionValidationError{}

// Validate checks the field values on CreatePersistentDispositionRequest with
// the rules defined in the proto definition for this message. If any rules
// are violated, the first error encountered is returned, or nil if there are
// no violations.
func (m *CreatePersistentDispositionRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreatePersistentDispositionRequest
// with the rules defined in the proto definition for this message. If any
// rules are violated, the result is a list of violation errors wrapped in
// CreatePersistentDispositionRequestMultiError, or nil if none found.
func (m *CreatePersistentDispositionRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *CreatePersistentDispositionRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for SetDisp

	// no validation rules for UnsetDisp

	// no validation rules for EventId

	// no validation rules for TypeOfEvent

	// no validation rules for UserId

	// no validation rules for UserEmail

	// no validation rules for RequestId

	if len(errors) > 0 {
		return CreatePersistentDispositionRequestMultiError(errors)
	}

	return nil
}

// CreatePersistentDispositionRequestMultiError is an error wrapping multiple
// validation errors returned by
// CreatePersistentDispositionRequest.ValidateAll() if the designated
// constraints aren't met.
type CreatePersistentDispositionRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreatePersistentDispositionRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreatePersistentDispositionRequestMultiError) AllErrors() []error { return m }

// CreatePersistentDispositionRequestValidationError is the validation error
// returned by CreatePersistentDispositionRequest.Validate if the designated
// constraints aren't met.
type CreatePersistentDispositionRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreatePersistentDispositionRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreatePersistentDispositionRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreatePersistentDispositionRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreatePersistentDispositionRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreatePersistentDispositionRequestValidationError) ErrorName() string {
	return "CreatePersistentDispositionRequestValidationError"
}

// Error satisfies the builtin error interface
func (e CreatePersistentDispositionRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreatePersistentDispositionRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreatePersistentDispositionRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreatePersistentDispositionRequestValidationError{}

// Validate checks the field values on CreatePersistentDispositionResponse with
// the rules defined in the proto definition for this message. If any rules
// are violated, the first error encountered is returned, or nil if there are
// no violations.
func (m *CreatePersistentDispositionResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreatePersistentDispositionResponse
// with the rules defined in the proto definition for this message. If any
// rules are violated, the result is a list of violation errors wrapped in
// CreatePersistentDispositionResponseMultiError, or nil if none found.
func (m *CreatePersistentDispositionResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *CreatePersistentDispositionResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetPersistentDisposition()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreatePersistentDispositionResponseValidationError{
					field:  "PersistentDisposition",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreatePersistentDispositionResponseValidationError{
					field:  "PersistentDisposition",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetPersistentDisposition()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreatePersistentDispositionResponseValidationError{
				field:  "PersistentDisposition",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return CreatePersistentDispositionResponseMultiError(errors)
	}

	return nil
}

// CreatePersistentDispositionResponseMultiError is an error wrapping multiple
// validation errors returned by
// CreatePersistentDispositionResponse.ValidateAll() if the designated
// constraints aren't met.
type CreatePersistentDispositionResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreatePersistentDispositionResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreatePersistentDispositionResponseMultiError) AllErrors() []error { return m }

// CreatePersistentDispositionResponseValidationError is the validation error
// returned by CreatePersistentDispositionResponse.Validate if the designated
// constraints aren't met.
type CreatePersistentDispositionResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreatePersistentDispositionResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreatePersistentDispositionResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreatePersistentDispositionResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreatePersistentDispositionResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreatePersistentDispositionResponseValidationError) ErrorName() string {
	return "CreatePersistentDispositionResponseValidationError"
}

// Error satisfies the builtin error interface
func (e CreatePersistentDispositionResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreatePersistentDispositionResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreatePersistentDispositionResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreatePersistentDispositionResponseValidationError{}

// Validate checks the field values on GetPersistentDispositionsRequest with
// the rules defined in the proto definition for this message. If any rules
// are violated, the first error encountered is returned, or nil if there are
// no violations.
func (m *GetPersistentDispositionsRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetPersistentDispositionsRequest with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// GetPersistentDispositionsRequestMultiError, or nil if none found.
func (m *GetPersistentDispositionsRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GetPersistentDispositionsRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for EventId

	// no validation rules for TypeOfEvent

	// no validation rules for UserEmail

	// no validation rules for RequestId

	if len(errors) > 0 {
		return GetPersistentDispositionsRequestMultiError(errors)
	}

	return nil
}

// GetPersistentDispositionsRequestMultiError is an error wrapping multiple
// validation errors returned by
// GetPersistentDispositionsRequest.ValidateAll() if the designated
// constraints aren't met.
type GetPersistentDispositionsRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetPersistentDispositionsRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetPersistentDispositionsRequestMultiError) AllErrors() []error { return m }

// GetPersistentDispositionsRequestValidationError is the validation error
// returned by GetPersistentDispositionsRequest.Validate if the designated
// constraints aren't met.
type GetPersistentDispositionsRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetPersistentDispositionsRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetPersistentDispositionsRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetPersistentDispositionsRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetPersistentDispositionsRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetPersistentDispositionsRequestValidationError) ErrorName() string {
	return "GetPersistentDispositionsRequestValidationError"
}

// Error satisfies the builtin error interface
func (e GetPersistentDispositionsRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetPersistentDispositionsRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetPersistentDispositionsRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetPersistentDispositionsRequestValidationError{}

// Validate checks the field values on GetPersistentDispositionsResponse with
// the rules defined in the proto definition for this message. If any rules
// are violated, the first error encountered is returned, or nil if there are
// no violations.
func (m *GetPersistentDispositionsResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetPersistentDispositionsResponse
// with the rules defined in the proto definition for this message. If any
// rules are violated, the result is a list of violation errors wrapped in
// GetPersistentDispositionsResponseMultiError, or nil if none found.
func (m *GetPersistentDispositionsResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *GetPersistentDispositionsResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetPersistentDispositions() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, GetPersistentDispositionsResponseValidationError{
						field:  fmt.Sprintf("PersistentDispositions[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, GetPersistentDispositionsResponseValidationError{
						field:  fmt.Sprintf("PersistentDispositions[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return GetPersistentDispositionsResponseValidationError{
					field:  fmt.Sprintf("PersistentDispositions[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return GetPersistentDispositionsResponseMultiError(errors)
	}

	return nil
}

// GetPersistentDispositionsResponseMultiError is an error wrapping multiple
// validation errors returned by
// GetPersistentDispositionsResponse.ValidateAll() if the designated
// constraints aren't met.
type GetPersistentDispositionsResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetPersistentDispositionsResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetPersistentDispositionsResponseMultiError) AllErrors() []error { return m }

// GetPersistentDispositionsResponseValidationError is the validation error
// returned by GetPersistentDispositionsResponse.Validate if the designated
// constraints aren't met.
type GetPersistentDispositionsResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetPersistentDispositionsResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetPersistentDispositionsResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetPersistentDispositionsResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetPersistentDispositionsResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetPersistentDispositionsResponseValidationError) ErrorName() string {
	return "GetPersistentDispositionsResponseValidationError"
}

// Error satisfies the builtin error interface
func (e GetPersistentDispositionsResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetPersistentDispositionsResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetPersistentDispositionsResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetPersistentDispositionsResponseValidationError{}

// Validate checks the field values on Epc with the rules defined in the proto
// definition for this message. If any rules are violated, the first error
// encountered is returned, or nil if there are no violations.
func (m *Epc) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Epc with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in EpcMultiError, or nil if none found.
func (m *Epc) ValidateAll() error {
	return m.validate(true)
}

func (m *Epc) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for EpcValue

	// no validation rules for EventId

	// no validation rules for TypeOfEvent

	// no validation rules for TypeOfEpc

	if len(errors) > 0 {
		return EpcMultiError(errors)
	}

	return nil
}

// EpcMultiError is an error wrapping multiple validation errors returned by
// Epc.ValidateAll() if the designated constraints aren't met.
type EpcMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m EpcMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m EpcMultiError) AllErrors() []error { return m }

// EpcValidationError is the validation error returned by Epc.Validate if the
// designated constraints aren't met.
type EpcValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e EpcValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e EpcValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e EpcValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e EpcValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e EpcValidationError) ErrorName() string { return "EpcValidationError" }

// Error satisfies the builtin error interface
func (e EpcValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sEpc.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = EpcValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = EpcValidationError{}

// Validate checks the field values on CreateEpcRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *CreateEpcRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateEpcRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreateEpcRequestMultiError, or nil if none found.
func (m *CreateEpcRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateEpcRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for EpcValue

	// no validation rules for EventId

	// no validation rules for TypeOfEvent

	// no validation rules for TypeOfEpc

	// no validation rules for UserId

	// no validation rules for UserEmail

	// no validation rules for RequestId

	if len(errors) > 0 {
		return CreateEpcRequestMultiError(errors)
	}

	return nil
}

// CreateEpcRequestMultiError is an error wrapping multiple validation errors
// returned by CreateEpcRequest.ValidateAll() if the designated constraints
// aren't met.
type CreateEpcRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateEpcRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateEpcRequestMultiError) AllErrors() []error { return m }

// CreateEpcRequestValidationError is the validation error returned by
// CreateEpcRequest.Validate if the designated constraints aren't met.
type CreateEpcRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateEpcRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateEpcRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateEpcRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateEpcRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateEpcRequestValidationError) ErrorName() string { return "CreateEpcRequestValidationError" }

// Error satisfies the builtin error interface
func (e CreateEpcRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateEpcRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateEpcRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateEpcRequestValidationError{}

// Validate checks the field values on CreateEpcResponse with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *CreateEpcResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateEpcResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreateEpcResponseMultiError, or nil if none found.
func (m *CreateEpcResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateEpcResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetEpc()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreateEpcResponseValidationError{
					field:  "Epc",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreateEpcResponseValidationError{
					field:  "Epc",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetEpc()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreateEpcResponseValidationError{
				field:  "Epc",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return CreateEpcResponseMultiError(errors)
	}

	return nil
}

// CreateEpcResponseMultiError is an error wrapping multiple validation errors
// returned by CreateEpcResponse.ValidateAll() if the designated constraints
// aren't met.
type CreateEpcResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateEpcResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateEpcResponseMultiError) AllErrors() []error { return m }

// CreateEpcResponseValidationError is the validation error returned by
// CreateEpcResponse.Validate if the designated constraints aren't met.
type CreateEpcResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateEpcResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateEpcResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateEpcResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateEpcResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateEpcResponseValidationError) ErrorName() string {
	return "CreateEpcResponseValidationError"
}

// Error satisfies the builtin error interface
func (e CreateEpcResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateEpcResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateEpcResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateEpcResponseValidationError{}

// Validate checks the field values on GetEpcsRequest with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *GetEpcsRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetEpcsRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in GetEpcsRequestMultiError,
// or nil if none found.
func (m *GetEpcsRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GetEpcsRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for EventId

	// no validation rules for TypeOfEvent

	// no validation rules for TypeOfEpc

	// no validation rules for UserEmail

	// no validation rules for RequestId

	if len(errors) > 0 {
		return GetEpcsRequestMultiError(errors)
	}

	return nil
}

// GetEpcsRequestMultiError is an error wrapping multiple validation errors
// returned by GetEpcsRequest.ValidateAll() if the designated constraints
// aren't met.
type GetEpcsRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetEpcsRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetEpcsRequestMultiError) AllErrors() []error { return m }

// GetEpcsRequestValidationError is the validation error returned by
// GetEpcsRequest.Validate if the designated constraints aren't met.
type GetEpcsRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetEpcsRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetEpcsRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetEpcsRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetEpcsRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetEpcsRequestValidationError) ErrorName() string { return "GetEpcsRequestValidationError" }

// Error satisfies the builtin error interface
func (e GetEpcsRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetEpcsRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetEpcsRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetEpcsRequestValidationError{}

// Validate checks the field values on GetEpcsResponse with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *GetEpcsResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetEpcsResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetEpcsResponseMultiError, or nil if none found.
func (m *GetEpcsResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *GetEpcsResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetEpcs() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, GetEpcsResponseValidationError{
						field:  fmt.Sprintf("Epcs[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, GetEpcsResponseValidationError{
						field:  fmt.Sprintf("Epcs[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return GetEpcsResponseValidationError{
					field:  fmt.Sprintf("Epcs[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return GetEpcsResponseMultiError(errors)
	}

	return nil
}

// GetEpcsResponseMultiError is an error wrapping multiple validation errors
// returned by GetEpcsResponse.ValidateAll() if the designated constraints
// aren't met.
type GetEpcsResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetEpcsResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetEpcsResponseMultiError) AllErrors() []error { return m }

// GetEpcsResponseValidationError is the validation error returned by
// GetEpcsResponse.Validate if the designated constraints aren't met.
type GetEpcsResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetEpcsResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetEpcsResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetEpcsResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetEpcsResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetEpcsResponseValidationError) ErrorName() string { return "GetEpcsResponseValidationError" }

// Error satisfies the builtin error interface
func (e GetEpcsResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetEpcsResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetEpcsResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetEpcsResponseValidationError{}

// Validate checks the field values on BizTransaction with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *BizTransaction) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on BizTransaction with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in BizTransactionMultiError,
// or nil if none found.
func (m *BizTransaction) ValidateAll() error {
	return m.validate(true)
}

func (m *BizTransaction) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for BizTransactionType

	// no validation rules for BizTransaction

	// no validation rules for EventId

	// no validation rules for TypeOfEvent

	if len(errors) > 0 {
		return BizTransactionMultiError(errors)
	}

	return nil
}

// BizTransactionMultiError is an error wrapping multiple validation errors
// returned by BizTransaction.ValidateAll() if the designated constraints
// aren't met.
type BizTransactionMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m BizTransactionMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m BizTransactionMultiError) AllErrors() []error { return m }

// BizTransactionValidationError is the validation error returned by
// BizTransaction.Validate if the designated constraints aren't met.
type BizTransactionValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e BizTransactionValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e BizTransactionValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e BizTransactionValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e BizTransactionValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e BizTransactionValidationError) ErrorName() string { return "BizTransactionValidationError" }

// Error satisfies the builtin error interface
func (e BizTransactionValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sBizTransaction.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = BizTransactionValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = BizTransactionValidationError{}

// Validate checks the field values on CreateBizTransactionRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CreateBizTransactionRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateBizTransactionRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreateBizTransactionRequestMultiError, or nil if none found.
func (m *CreateBizTransactionRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateBizTransactionRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for BizTransactionType

	// no validation rules for BizTransaction

	// no validation rules for EventId

	// no validation rules for TypeOfEvent

	// no validation rules for UserId

	// no validation rules for UserEmail

	// no validation rules for RequestId

	if len(errors) > 0 {
		return CreateBizTransactionRequestMultiError(errors)
	}

	return nil
}

// CreateBizTransactionRequestMultiError is an error wrapping multiple
// validation errors returned by CreateBizTransactionRequest.ValidateAll() if
// the designated constraints aren't met.
type CreateBizTransactionRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateBizTransactionRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateBizTransactionRequestMultiError) AllErrors() []error { return m }

// CreateBizTransactionRequestValidationError is the validation error returned
// by CreateBizTransactionRequest.Validate if the designated constraints
// aren't met.
type CreateBizTransactionRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateBizTransactionRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateBizTransactionRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateBizTransactionRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateBizTransactionRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateBizTransactionRequestValidationError) ErrorName() string {
	return "CreateBizTransactionRequestValidationError"
}

// Error satisfies the builtin error interface
func (e CreateBizTransactionRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateBizTransactionRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateBizTransactionRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateBizTransactionRequestValidationError{}

// Validate checks the field values on CreateBizTransactionResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CreateBizTransactionResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateBizTransactionResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreateBizTransactionResponseMultiError, or nil if none found.
func (m *CreateBizTransactionResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateBizTransactionResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetBizTransaction()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreateBizTransactionResponseValidationError{
					field:  "BizTransaction",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreateBizTransactionResponseValidationError{
					field:  "BizTransaction",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetBizTransaction()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreateBizTransactionResponseValidationError{
				field:  "BizTransaction",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return CreateBizTransactionResponseMultiError(errors)
	}

	return nil
}

// CreateBizTransactionResponseMultiError is an error wrapping multiple
// validation errors returned by CreateBizTransactionResponse.ValidateAll() if
// the designated constraints aren't met.
type CreateBizTransactionResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateBizTransactionResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateBizTransactionResponseMultiError) AllErrors() []error { return m }

// CreateBizTransactionResponseValidationError is the validation error returned
// by CreateBizTransactionResponse.Validate if the designated constraints
// aren't met.
type CreateBizTransactionResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateBizTransactionResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateBizTransactionResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateBizTransactionResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateBizTransactionResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateBizTransactionResponseValidationError) ErrorName() string {
	return "CreateBizTransactionResponseValidationError"
}

// Error satisfies the builtin error interface
func (e CreateBizTransactionResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateBizTransactionResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateBizTransactionResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateBizTransactionResponseValidationError{}

// Validate checks the field values on GetBizTransactionsRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetBizTransactionsRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetBizTransactionsRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetBizTransactionsRequestMultiError, or nil if none found.
func (m *GetBizTransactionsRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GetBizTransactionsRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for EventId

	// no validation rules for TypeOfEvent

	// no validation rules for UserEmail

	// no validation rules for RequestId

	if len(errors) > 0 {
		return GetBizTransactionsRequestMultiError(errors)
	}

	return nil
}

// GetBizTransactionsRequestMultiError is an error wrapping multiple validation
// errors returned by GetBizTransactionsRequest.ValidateAll() if the
// designated constraints aren't met.
type GetBizTransactionsRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetBizTransactionsRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetBizTransactionsRequestMultiError) AllErrors() []error { return m }

// GetBizTransactionsRequestValidationError is the validation error returned by
// GetBizTransactionsRequest.Validate if the designated constraints aren't met.
type GetBizTransactionsRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetBizTransactionsRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetBizTransactionsRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetBizTransactionsRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetBizTransactionsRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetBizTransactionsRequestValidationError) ErrorName() string {
	return "GetBizTransactionsRequestValidationError"
}

// Error satisfies the builtin error interface
func (e GetBizTransactionsRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetBizTransactionsRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetBizTransactionsRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetBizTransactionsRequestValidationError{}

// Validate checks the field values on GetBizTransactionsResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetBizTransactionsResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetBizTransactionsResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetBizTransactionsResponseMultiError, or nil if none found.
func (m *GetBizTransactionsResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *GetBizTransactionsResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetBizTransactions() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, GetBizTransactionsResponseValidationError{
						field:  fmt.Sprintf("BizTransactions[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, GetBizTransactionsResponseValidationError{
						field:  fmt.Sprintf("BizTransactions[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return GetBizTransactionsResponseValidationError{
					field:  fmt.Sprintf("BizTransactions[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return GetBizTransactionsResponseMultiError(errors)
	}

	return nil
}

// GetBizTransactionsResponseMultiError is an error wrapping multiple
// validation errors returned by GetBizTransactionsResponse.ValidateAll() if
// the designated constraints aren't met.
type GetBizTransactionsResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetBizTransactionsResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetBizTransactionsResponseMultiError) AllErrors() []error { return m }

// GetBizTransactionsResponseValidationError is the validation error returned
// by GetBizTransactionsResponse.Validate if the designated constraints aren't met.
type GetBizTransactionsResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetBizTransactionsResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetBizTransactionsResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetBizTransactionsResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetBizTransactionsResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetBizTransactionsResponseValidationError) ErrorName() string {
	return "GetBizTransactionsResponseValidationError"
}

// Error satisfies the builtin error interface
func (e GetBizTransactionsResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetBizTransactionsResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetBizTransactionsResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetBizTransactionsResponseValidationError{}

// Validate checks the field values on QuantityElement with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *QuantityElement) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on QuantityElement with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// QuantityElementMultiError, or nil if none found.
func (m *QuantityElement) ValidateAll() error {
	return m.validate(true)
}

func (m *QuantityElement) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for EpcClass

	// no validation rules for Quantity

	// no validation rules for Uom

	// no validation rules for EventId

	// no validation rules for TypeOfEvent

	// no validation rules for TypeOfQuantity

	if len(errors) > 0 {
		return QuantityElementMultiError(errors)
	}

	return nil
}

// QuantityElementMultiError is an error wrapping multiple validation errors
// returned by QuantityElement.ValidateAll() if the designated constraints
// aren't met.
type QuantityElementMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m QuantityElementMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m QuantityElementMultiError) AllErrors() []error { return m }

// QuantityElementValidationError is the validation error returned by
// QuantityElement.Validate if the designated constraints aren't met.
type QuantityElementValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e QuantityElementValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e QuantityElementValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e QuantityElementValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e QuantityElementValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e QuantityElementValidationError) ErrorName() string { return "QuantityElementValidationError" }

// Error satisfies the builtin error interface
func (e QuantityElementValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sQuantityElement.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = QuantityElementValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = QuantityElementValidationError{}

// Validate checks the field values on CreateQuantityElementRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CreateQuantityElementRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateQuantityElementRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreateQuantityElementRequestMultiError, or nil if none found.
func (m *CreateQuantityElementRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateQuantityElementRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for EpcClass

	// no validation rules for Quantity

	// no validation rules for Uom

	// no validation rules for EventId

	// no validation rules for TypeOfEvent

	// no validation rules for TypeOfQuantity

	// no validation rules for UserId

	// no validation rules for UserEmail

	// no validation rules for RequestId

	if len(errors) > 0 {
		return CreateQuantityElementRequestMultiError(errors)
	}

	return nil
}

// CreateQuantityElementRequestMultiError is an error wrapping multiple
// validation errors returned by CreateQuantityElementRequest.ValidateAll() if
// the designated constraints aren't met.
type CreateQuantityElementRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateQuantityElementRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateQuantityElementRequestMultiError) AllErrors() []error { return m }

// CreateQuantityElementRequestValidationError is the validation error returned
// by CreateQuantityElementRequest.Validate if the designated constraints
// aren't met.
type CreateQuantityElementRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateQuantityElementRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateQuantityElementRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateQuantityElementRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateQuantityElementRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateQuantityElementRequestValidationError) ErrorName() string {
	return "CreateQuantityElementRequestValidationError"
}

// Error satisfies the builtin error interface
func (e CreateQuantityElementRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateQuantityElementRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateQuantityElementRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateQuantityElementRequestValidationError{}

// Validate checks the field values on CreateQuantityElementResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CreateQuantityElementResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateQuantityElementResponse with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// CreateQuantityElementResponseMultiError, or nil if none found.
func (m *CreateQuantityElementResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateQuantityElementResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetQuantityElement()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreateQuantityElementResponseValidationError{
					field:  "QuantityElement",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreateQuantityElementResponseValidationError{
					field:  "QuantityElement",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetQuantityElement()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreateQuantityElementResponseValidationError{
				field:  "QuantityElement",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return CreateQuantityElementResponseMultiError(errors)
	}

	return nil
}

// CreateQuantityElementResponseMultiError is an error wrapping multiple
// validation errors returned by CreateQuantityElementResponse.ValidateAll()
// if the designated constraints aren't met.
type CreateQuantityElementResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateQuantityElementResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateQuantityElementResponseMultiError) AllErrors() []error { return m }

// CreateQuantityElementResponseValidationError is the validation error
// returned by CreateQuantityElementResponse.Validate if the designated
// constraints aren't met.
type CreateQuantityElementResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateQuantityElementResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateQuantityElementResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateQuantityElementResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateQuantityElementResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateQuantityElementResponseValidationError) ErrorName() string {
	return "CreateQuantityElementResponseValidationError"
}

// Error satisfies the builtin error interface
func (e CreateQuantityElementResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateQuantityElementResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateQuantityElementResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateQuantityElementResponseValidationError{}

// Validate checks the field values on GetQuantityElementsRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetQuantityElementsRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetQuantityElementsRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetQuantityElementsRequestMultiError, or nil if none found.
func (m *GetQuantityElementsRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GetQuantityElementsRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for EventId

	// no validation rules for TypeOfEvent

	// no validation rules for TypeOfQuantity

	// no validation rules for UserEmail

	// no validation rules for RequestId

	if len(errors) > 0 {
		return GetQuantityElementsRequestMultiError(errors)
	}

	return nil
}

// GetQuantityElementsRequestMultiError is an error wrapping multiple
// validation errors returned by GetQuantityElementsRequest.ValidateAll() if
// the designated constraints aren't met.
type GetQuantityElementsRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetQuantityElementsRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetQuantityElementsRequestMultiError) AllErrors() []error { return m }

// GetQuantityElementsRequestValidationError is the validation error returned
// by GetQuantityElementsRequest.Validate if the designated constraints aren't met.
type GetQuantityElementsRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetQuantityElementsRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetQuantityElementsRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetQuantityElementsRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetQuantityElementsRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetQuantityElementsRequestValidationError) ErrorName() string {
	return "GetQuantityElementsRequestValidationError"
}

// Error satisfies the builtin error interface
func (e GetQuantityElementsRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetQuantityElementsRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetQuantityElementsRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetQuantityElementsRequestValidationError{}

// Validate checks the field values on GetQuantityElementsResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetQuantityElementsResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetQuantityElementsResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetQuantityElementsResponseMultiError, or nil if none found.
func (m *GetQuantityElementsResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *GetQuantityElementsResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetQuantityElements() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, GetQuantityElementsResponseValidationError{
						field:  fmt.Sprintf("QuantityElements[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, GetQuantityElementsResponseValidationError{
						field:  fmt.Sprintf("QuantityElements[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return GetQuantityElementsResponseValidationError{
					field:  fmt.Sprintf("QuantityElements[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return GetQuantityElementsResponseMultiError(errors)
	}

	return nil
}

// GetQuantityElementsResponseMultiError is an error wrapping multiple
// validation errors returned by GetQuantityElementsResponse.ValidateAll() if
// the designated constraints aren't met.
type GetQuantityElementsResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetQuantityElementsResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetQuantityElementsResponseMultiError) AllErrors() []error { return m }

// GetQuantityElementsResponseValidationError is the validation error returned
// by GetQuantityElementsResponse.Validate if the designated constraints
// aren't met.
type GetQuantityElementsResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetQuantityElementsResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetQuantityElementsResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetQuantityElementsResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetQuantityElementsResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetQuantityElementsResponseValidationError) ErrorName() string {
	return "GetQuantityElementsResponseValidationError"
}

// Error satisfies the builtin error interface
func (e GetQuantityElementsResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetQuantityElementsResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetQuantityElementsResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetQuantityElementsResponseValidationError{}

// Validate checks the field values on Source with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Source) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Source with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in SourceMultiError, or nil if none found.
func (m *Source) ValidateAll() error {
	return m.validate(true)
}

func (m *Source) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for SourceType

	// no validation rules for Source

	// no validation rules for EventId

	// no validation rules for TypeOfEvent

	if len(errors) > 0 {
		return SourceMultiError(errors)
	}

	return nil
}

// SourceMultiError is an error wrapping multiple validation errors returned by
// Source.ValidateAll() if the designated constraints aren't met.
type SourceMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SourceMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SourceMultiError) AllErrors() []error { return m }

// SourceValidationError is the validation error returned by Source.Validate if
// the designated constraints aren't met.
type SourceValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SourceValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SourceValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SourceValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SourceValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SourceValidationError) ErrorName() string { return "SourceValidationError" }

// Error satisfies the builtin error interface
func (e SourceValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSource.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SourceValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SourceValidationError{}

// Validate checks the field values on CreateSourceRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CreateSourceRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateSourceRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreateSourceRequestMultiError, or nil if none found.
func (m *CreateSourceRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateSourceRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for SourceType

	// no validation rules for Source

	// no validation rules for EventId

	// no validation rules for TypeOfEvent

	// no validation rules for UserId

	// no validation rules for UserEmail

	// no validation rules for RequestId

	if len(errors) > 0 {
		return CreateSourceRequestMultiError(errors)
	}

	return nil
}

// CreateSourceRequestMultiError is an error wrapping multiple validation
// errors returned by CreateSourceRequest.ValidateAll() if the designated
// constraints aren't met.
type CreateSourceRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateSourceRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateSourceRequestMultiError) AllErrors() []error { return m }

// CreateSourceRequestValidationError is the validation error returned by
// CreateSourceRequest.Validate if the designated constraints aren't met.
type CreateSourceRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateSourceRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateSourceRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateSourceRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateSourceRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateSourceRequestValidationError) ErrorName() string {
	return "CreateSourceRequestValidationError"
}

// Error satisfies the builtin error interface
func (e CreateSourceRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateSourceRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateSourceRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateSourceRequestValidationError{}

// Validate checks the field values on CreateSourceResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CreateSourceResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateSourceResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreateSourceResponseMultiError, or nil if none found.
func (m *CreateSourceResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateSourceResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetSource()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreateSourceResponseValidationError{
					field:  "Source",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreateSourceResponseValidationError{
					field:  "Source",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSource()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreateSourceResponseValidationError{
				field:  "Source",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return CreateSourceResponseMultiError(errors)
	}

	return nil
}

// CreateSourceResponseMultiError is an error wrapping multiple validation
// errors returned by CreateSourceResponse.ValidateAll() if the designated
// constraints aren't met.
type CreateSourceResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateSourceResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateSourceResponseMultiError) AllErrors() []error { return m }

// CreateSourceResponseValidationError is the validation error returned by
// CreateSourceResponse.Validate if the designated constraints aren't met.
type CreateSourceResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateSourceResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateSourceResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateSourceResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateSourceResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateSourceResponseValidationError) ErrorName() string {
	return "CreateSourceResponseValidationError"
}

// Error satisfies the builtin error interface
func (e CreateSourceResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateSourceResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateSourceResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateSourceResponseValidationError{}

// Validate checks the field values on GetSourcesRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *GetSourcesRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetSourcesRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetSourcesRequestMultiError, or nil if none found.
func (m *GetSourcesRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GetSourcesRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for EventId

	// no validation rules for TypeOfEvent

	// no validation rules for UserEmail

	// no validation rules for RequestId

	if len(errors) > 0 {
		return GetSourcesRequestMultiError(errors)
	}

	return nil
}

// GetSourcesRequestMultiError is an error wrapping multiple validation errors
// returned by GetSourcesRequest.ValidateAll() if the designated constraints
// aren't met.
type GetSourcesRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetSourcesRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetSourcesRequestMultiError) AllErrors() []error { return m }

// GetSourcesRequestValidationError is the validation error returned by
// GetSourcesRequest.Validate if the designated constraints aren't met.
type GetSourcesRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetSourcesRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetSourcesRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetSourcesRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetSourcesRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetSourcesRequestValidationError) ErrorName() string {
	return "GetSourcesRequestValidationError"
}

// Error satisfies the builtin error interface
func (e GetSourcesRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetSourcesRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetSourcesRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetSourcesRequestValidationError{}

// Validate checks the field values on GetSourcesResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetSourcesResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetSourcesResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetSourcesResponseMultiError, or nil if none found.
func (m *GetSourcesResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *GetSourcesResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetSources() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, GetSourcesResponseValidationError{
						field:  fmt.Sprintf("Sources[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, GetSourcesResponseValidationError{
						field:  fmt.Sprintf("Sources[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return GetSourcesResponseValidationError{
					field:  fmt.Sprintf("Sources[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return GetSourcesResponseMultiError(errors)
	}

	return nil
}

// GetSourcesResponseMultiError is an error wrapping multiple validation errors
// returned by GetSourcesResponse.ValidateAll() if the designated constraints
// aren't met.
type GetSourcesResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetSourcesResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetSourcesResponseMultiError) AllErrors() []error { return m }

// GetSourcesResponseValidationError is the validation error returned by
// GetSourcesResponse.Validate if the designated constraints aren't met.
type GetSourcesResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetSourcesResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetSourcesResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetSourcesResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetSourcesResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetSourcesResponseValidationError) ErrorName() string {
	return "GetSourcesResponseValidationError"
}

// Error satisfies the builtin error interface
func (e GetSourcesResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetSourcesResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetSourcesResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetSourcesResponseValidationError{}

// Validate checks the field values on Destination with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Destination) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Destination with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in DestinationMultiError, or
// nil if none found.
func (m *Destination) ValidateAll() error {
	return m.validate(true)
}

func (m *Destination) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for DestType

	// no validation rules for Destination

	// no validation rules for EventId

	// no validation rules for TypeOfEvent

	if len(errors) > 0 {
		return DestinationMultiError(errors)
	}

	return nil
}

// DestinationMultiError is an error wrapping multiple validation errors
// returned by Destination.ValidateAll() if the designated constraints aren't met.
type DestinationMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DestinationMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DestinationMultiError) AllErrors() []error { return m }

// DestinationValidationError is the validation error returned by
// Destination.Validate if the designated constraints aren't met.
type DestinationValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DestinationValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DestinationValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DestinationValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DestinationValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DestinationValidationError) ErrorName() string { return "DestinationValidationError" }

// Error satisfies the builtin error interface
func (e DestinationValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDestination.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DestinationValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DestinationValidationError{}

// Validate checks the field values on CreateDestinationRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CreateDestinationRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateDestinationRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreateDestinationRequestMultiError, or nil if none found.
func (m *CreateDestinationRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateDestinationRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for DestType

	// no validation rules for Destination

	// no validation rules for EventId

	// no validation rules for TypeOfEvent

	// no validation rules for UserId

	// no validation rules for UserEmail

	// no validation rules for RequestId

	if len(errors) > 0 {
		return CreateDestinationRequestMultiError(errors)
	}

	return nil
}

// CreateDestinationRequestMultiError is an error wrapping multiple validation
// errors returned by CreateDestinationRequest.ValidateAll() if the designated
// constraints aren't met.
type CreateDestinationRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateDestinationRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateDestinationRequestMultiError) AllErrors() []error { return m }

// CreateDestinationRequestValidationError is the validation error returned by
// CreateDestinationRequest.Validate if the designated constraints aren't met.
type CreateDestinationRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateDestinationRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateDestinationRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateDestinationRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateDestinationRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateDestinationRequestValidationError) ErrorName() string {
	return "CreateDestinationRequestValidationError"
}

// Error satisfies the builtin error interface
func (e CreateDestinationRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateDestinationRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateDestinationRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateDestinationRequestValidationError{}

// Validate checks the field values on CreateDestinationResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CreateDestinationResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateDestinationResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreateDestinationResponseMultiError, or nil if none found.
func (m *CreateDestinationResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateDestinationResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetDestination()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreateDestinationResponseValidationError{
					field:  "Destination",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreateDestinationResponseValidationError{
					field:  "Destination",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDestination()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreateDestinationResponseValidationError{
				field:  "Destination",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return CreateDestinationResponseMultiError(errors)
	}

	return nil
}

// CreateDestinationResponseMultiError is an error wrapping multiple validation
// errors returned by CreateDestinationResponse.ValidateAll() if the
// designated constraints aren't met.
type CreateDestinationResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateDestinationResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateDestinationResponseMultiError) AllErrors() []error { return m }

// CreateDestinationResponseValidationError is the validation error returned by
// CreateDestinationResponse.Validate if the designated constraints aren't met.
type CreateDestinationResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateDestinationResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateDestinationResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateDestinationResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateDestinationResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateDestinationResponseValidationError) ErrorName() string {
	return "CreateDestinationResponseValidationError"
}

// Error satisfies the builtin error interface
func (e CreateDestinationResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateDestinationResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateDestinationResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateDestinationResponseValidationError{}

// Validate checks the field values on GetDestinationsRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetDestinationsRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetDestinationsRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetDestinationsRequestMultiError, or nil if none found.
func (m *GetDestinationsRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GetDestinationsRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for EventId

	// no validation rules for TypeOfEvent

	// no validation rules for UserEmail

	// no validation rules for RequestId

	if len(errors) > 0 {
		return GetDestinationsRequestMultiError(errors)
	}

	return nil
}

// GetDestinationsRequestMultiError is an error wrapping multiple validation
// errors returned by GetDestinationsRequest.ValidateAll() if the designated
// constraints aren't met.
type GetDestinationsRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetDestinationsRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetDestinationsRequestMultiError) AllErrors() []error { return m }

// GetDestinationsRequestValidationError is the validation error returned by
// GetDestinationsRequest.Validate if the designated constraints aren't met.
type GetDestinationsRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetDestinationsRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetDestinationsRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetDestinationsRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetDestinationsRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetDestinationsRequestValidationError) ErrorName() string {
	return "GetDestinationsRequestValidationError"
}

// Error satisfies the builtin error interface
func (e GetDestinationsRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetDestinationsRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetDestinationsRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetDestinationsRequestValidationError{}

// Validate checks the field values on GetDestinationsResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetDestinationsResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetDestinationsResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetDestinationsResponseMultiError, or nil if none found.
func (m *GetDestinationsResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *GetDestinationsResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetDestinations() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, GetDestinationsResponseValidationError{
						field:  fmt.Sprintf("Destinations[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, GetDestinationsResponseValidationError{
						field:  fmt.Sprintf("Destinations[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return GetDestinationsResponseValidationError{
					field:  fmt.Sprintf("Destinations[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return GetDestinationsResponseMultiError(errors)
	}

	return nil
}

// GetDestinationsResponseMultiError is an error wrapping multiple validation
// errors returned by GetDestinationsResponse.ValidateAll() if the designated
// constraints aren't met.
type GetDestinationsResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetDestinationsResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetDestinationsResponseMultiError) AllErrors() []error { return m }

// GetDestinationsResponseValidationError is the validation error returned by
// GetDestinationsResponse.Validate if the designated constraints aren't met.
type GetDestinationsResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetDestinationsResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetDestinationsResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetDestinationsResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetDestinationsResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetDestinationsResponseValidationError) ErrorName() string {
	return "GetDestinationsResponseValidationError"
}

// Error satisfies the builtin error interface
func (e GetDestinationsResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetDestinationsResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetDestinationsResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetDestinationsResponseValidationError{}

// Validate checks the field values on SensorElement with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *SensorElement) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SensorElement with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in SensorElementMultiError, or
// nil if none found.
func (m *SensorElement) ValidateAll() error {
	return m.validate(true)
}

func (m *SensorElement) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetSensorMetadataD()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, SensorElementValidationError{
					field:  "SensorMetadataD",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, SensorElementValidationError{
					field:  "SensorMetadataD",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSensorMetadataD()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return SensorElementValidationError{
				field:  "SensorMetadataD",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetSensorMetadataT()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, SensorElementValidationError{
					field:  "SensorMetadataT",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, SensorElementValidationError{
					field:  "SensorMetadataT",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSensorMetadataT()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return SensorElementValidationError{
				field:  "SensorMetadataT",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetSensorElementD()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, SensorElementValidationError{
					field:  "SensorElementD",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, SensorElementValidationError{
					field:  "SensorElementD",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSensorElementD()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return SensorElementValidationError{
				field:  "SensorElementD",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	for idx, item := range m.GetSensorReports() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, SensorElementValidationError{
						field:  fmt.Sprintf("SensorReports[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, SensorElementValidationError{
						field:  fmt.Sprintf("SensorReports[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return SensorElementValidationError{
					field:  fmt.Sprintf("SensorReports[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return SensorElementMultiError(errors)
	}

	return nil
}

// SensorElementMultiError is an error wrapping multiple validation errors
// returned by SensorElement.ValidateAll() if the designated constraints
// aren't met.
type SensorElementMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SensorElementMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SensorElementMultiError) AllErrors() []error { return m }

// SensorElementValidationError is the validation error returned by
// SensorElement.Validate if the designated constraints aren't met.
type SensorElementValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SensorElementValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SensorElementValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SensorElementValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SensorElementValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SensorElementValidationError) ErrorName() string { return "SensorElementValidationError" }

// Error satisfies the builtin error interface
func (e SensorElementValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSensorElement.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SensorElementValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SensorElementValidationError{}

// Validate checks the field values on SensorElementD with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *SensorElementD) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SensorElementD with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in SensorElementDMultiError,
// or nil if none found.
func (m *SensorElementD) ValidateAll() error {
	return m.validate(true)
}

func (m *SensorElementD) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for EventId

	// no validation rules for TypeOfEvent

	if len(errors) > 0 {
		return SensorElementDMultiError(errors)
	}

	return nil
}

// SensorElementDMultiError is an error wrapping multiple validation errors
// returned by SensorElementD.ValidateAll() if the designated constraints
// aren't met.
type SensorElementDMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SensorElementDMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SensorElementDMultiError) AllErrors() []error { return m }

// SensorElementDValidationError is the validation error returned by
// SensorElementD.Validate if the designated constraints aren't met.
type SensorElementDValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SensorElementDValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SensorElementDValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SensorElementDValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SensorElementDValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SensorElementDValidationError) ErrorName() string { return "SensorElementDValidationError" }

// Error satisfies the builtin error interface
func (e SensorElementDValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSensorElementD.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SensorElementDValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SensorElementDValidationError{}

// Validate checks the field values on CreateSensorElementRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CreateSensorElementRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateSensorElementRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreateSensorElementRequestMultiError, or nil if none found.
func (m *CreateSensorElementRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateSensorElementRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for DeviceId

	// no validation rules for DeviceMetadata

	// no validation rules for RawData

	// no validation rules for DataProcessingMethod

	// no validation rules for BizRules

	// no validation rules for SensorTime

	// no validation rules for StartTime

	// no validation rules for EndTime

	// no validation rules for EventId

	// no validation rules for TypeOfEvent

	// no validation rules for UserId

	// no validation rules for UserEmail

	// no validation rules for RequestId

	for idx, item := range m.GetSensorReports() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, CreateSensorElementRequestValidationError{
						field:  fmt.Sprintf("SensorReports[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, CreateSensorElementRequestValidationError{
						field:  fmt.Sprintf("SensorReports[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return CreateSensorElementRequestValidationError{
					field:  fmt.Sprintf("SensorReports[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return CreateSensorElementRequestMultiError(errors)
	}

	return nil
}

// CreateSensorElementRequestMultiError is an error wrapping multiple
// validation errors returned by CreateSensorElementRequest.ValidateAll() if
// the designated constraints aren't met.
type CreateSensorElementRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateSensorElementRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateSensorElementRequestMultiError) AllErrors() []error { return m }

// CreateSensorElementRequestValidationError is the validation error returned
// by CreateSensorElementRequest.Validate if the designated constraints aren't met.
type CreateSensorElementRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateSensorElementRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateSensorElementRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateSensorElementRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateSensorElementRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateSensorElementRequestValidationError) ErrorName() string {
	return "CreateSensorElementRequestValidationError"
}

// Error satisfies the builtin error interface
func (e CreateSensorElementRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateSensorElementRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateSensorElementRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateSensorElementRequestValidationError{}

// Validate checks the field values on CreateSensorElementResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CreateSensorElementResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateSensorElementResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreateSensorElementResponseMultiError, or nil if none found.
func (m *CreateSensorElementResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateSensorElementResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetSensorElement()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreateSensorElementResponseValidationError{
					field:  "SensorElement",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreateSensorElementResponseValidationError{
					field:  "SensorElement",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSensorElement()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreateSensorElementResponseValidationError{
				field:  "SensorElement",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return CreateSensorElementResponseMultiError(errors)
	}

	return nil
}

// CreateSensorElementResponseMultiError is an error wrapping multiple
// validation errors returned by CreateSensorElementResponse.ValidateAll() if
// the designated constraints aren't met.
type CreateSensorElementResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateSensorElementResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateSensorElementResponseMultiError) AllErrors() []error { return m }

// CreateSensorElementResponseValidationError is the validation error returned
// by CreateSensorElementResponse.Validate if the designated constraints
// aren't met.
type CreateSensorElementResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateSensorElementResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateSensorElementResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateSensorElementResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateSensorElementResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateSensorElementResponseValidationError) ErrorName() string {
	return "CreateSensorElementResponseValidationError"
}

// Error satisfies the builtin error interface
func (e CreateSensorElementResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateSensorElementResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateSensorElementResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateSensorElementResponseValidationError{}

// Validate checks the field values on GetSensorElementsRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetSensorElementsRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetSensorElementsRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetSensorElementsRequestMultiError, or nil if none found.
func (m *GetSensorElementsRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GetSensorElementsRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for EventId

	// no validation rules for TypeOfEvent

	// no validation rules for UserEmail

	// no validation rules for RequestId

	if len(errors) > 0 {
		return GetSensorElementsRequestMultiError(errors)
	}

	return nil
}

// GetSensorElementsRequestMultiError is an error wrapping multiple validation
// errors returned by GetSensorElementsRequest.ValidateAll() if the designated
// constraints aren't met.
type GetSensorElementsRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetSensorElementsRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetSensorElementsRequestMultiError) AllErrors() []error { return m }

// GetSensorElementsRequestValidationError is the validation error returned by
// GetSensorElementsRequest.Validate if the designated constraints aren't met.
type GetSensorElementsRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetSensorElementsRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetSensorElementsRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetSensorElementsRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetSensorElementsRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetSensorElementsRequestValidationError) ErrorName() string {
	return "GetSensorElementsRequestValidationError"
}

// Error satisfies the builtin error interface
func (e GetSensorElementsRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetSensorElementsRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetSensorElementsRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetSensorElementsRequestValidationError{}

// Validate checks the field values on GetSensorElementsResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetSensorElementsResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetSensorElementsResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetSensorElementsResponseMultiError, or nil if none found.
func (m *GetSensorElementsResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *GetSensorElementsResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetSensorElements() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, GetSensorElementsResponseValidationError{
						field:  fmt.Sprintf("SensorElements[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, GetSensorElementsResponseValidationError{
						field:  fmt.Sprintf("SensorElements[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return GetSensorElementsResponseValidationError{
					field:  fmt.Sprintf("SensorElements[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return GetSensorElementsResponseMultiError(errors)
	}

	return nil
}

// GetSensorElementsResponseMultiError is an error wrapping multiple validation
// errors returned by GetSensorElementsResponse.ValidateAll() if the
// designated constraints aren't met.
type GetSensorElementsResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetSensorElementsResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetSensorElementsResponseMultiError) AllErrors() []error { return m }

// GetSensorElementsResponseValidationError is the validation error returned by
// GetSensorElementsResponse.Validate if the designated constraints aren't met.
type GetSensorElementsResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetSensorElementsResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetSensorElementsResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetSensorElementsResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetSensorElementsResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetSensorElementsResponseValidationError) ErrorName() string {
	return "GetSensorElementsResponseValidationError"
}

// Error satisfies the builtin error interface
func (e GetSensorElementsResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetSensorElementsResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetSensorElementsResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetSensorElementsResponseValidationError{}

// Validate checks the field values on SensorReport with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *SensorReport) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SensorReport with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in SensorReportMultiError, or
// nil if none found.
func (m *SensorReport) ValidateAll() error {
	return m.validate(true)
}

func (m *SensorReport) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetSensorReportD()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, SensorReportValidationError{
					field:  "SensorReportD",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, SensorReportValidationError{
					field:  "SensorReportD",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSensorReportD()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return SensorReportValidationError{
				field:  "SensorReportD",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetSensorReportT()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, SensorReportValidationError{
					field:  "SensorReportT",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, SensorReportValidationError{
					field:  "SensorReportT",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSensorReportT()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return SensorReportValidationError{
				field:  "SensorReportT",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return SensorReportMultiError(errors)
	}

	return nil
}

// SensorReportMultiError is an error wrapping multiple validation errors
// returned by SensorReport.ValidateAll() if the designated constraints aren't met.
type SensorReportMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SensorReportMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SensorReportMultiError) AllErrors() []error { return m }

// SensorReportValidationError is the validation error returned by
// SensorReport.Validate if the designated constraints aren't met.
type SensorReportValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SensorReportValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SensorReportValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SensorReportValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SensorReportValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SensorReportValidationError) ErrorName() string { return "SensorReportValidationError" }

// Error satisfies the builtin error interface
func (e SensorReportValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSensorReport.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SensorReportValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SensorReportValidationError{}

// Validate checks the field values on CreateSensorReportRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CreateSensorReportRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateSensorReportRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreateSensorReportRequestMultiError, or nil if none found.
func (m *CreateSensorReportRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateSensorReportRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for SensorReportType

	// no validation rules for DeviceId

	// no validation rules for RawData

	// no validation rules for DataProcessingMethod

	// no validation rules for Microorganism

	// no validation rules for ChemicalSubstance

	// no validation rules for SensorValue

	// no validation rules for Component

	// no validation rules for StringValue

	// no validation rules for BooleanValue

	// no validation rules for HexBinaryValue

	// no validation rules for UriValue

	// no validation rules for MinValue

	// no validation rules for MaxValue

	// no validation rules for MeanValue

	// no validation rules for PercRank

	// no validation rules for PercValue

	// no validation rules for Uom

	// no validation rules for SDev

	// no validation rules for DeviceMetadata

	// no validation rules for SensorElementId

	// no validation rules for SensorReportTime

	// no validation rules for UserId

	// no validation rules for UserEmail

	// no validation rules for RequestId

	if len(errors) > 0 {
		return CreateSensorReportRequestMultiError(errors)
	}

	return nil
}

// CreateSensorReportRequestMultiError is an error wrapping multiple validation
// errors returned by CreateSensorReportRequest.ValidateAll() if the
// designated constraints aren't met.
type CreateSensorReportRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateSensorReportRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateSensorReportRequestMultiError) AllErrors() []error { return m }

// CreateSensorReportRequestValidationError is the validation error returned by
// CreateSensorReportRequest.Validate if the designated constraints aren't met.
type CreateSensorReportRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateSensorReportRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateSensorReportRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateSensorReportRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateSensorReportRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateSensorReportRequestValidationError) ErrorName() string {
	return "CreateSensorReportRequestValidationError"
}

// Error satisfies the builtin error interface
func (e CreateSensorReportRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateSensorReportRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateSensorReportRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateSensorReportRequestValidationError{}

// Validate checks the field values on SensorReportD with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *SensorReportD) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SensorReportD with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in SensorReportDMultiError, or
// nil if none found.
func (m *SensorReportD) ValidateAll() error {
	return m.validate(true)
}

func (m *SensorReportD) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for SensorReportType

	// no validation rules for DeviceId

	// no validation rules for RawData

	// no validation rules for DataProcessingMethod

	// no validation rules for Microorganism

	// no validation rules for ChemicalSubstance

	// no validation rules for SensorValue

	// no validation rules for Component

	// no validation rules for StringValue

	// no validation rules for BooleanValue

	// no validation rules for HexBinaryValue

	// no validation rules for UriValue

	// no validation rules for MinValue

	// no validation rules for MaxValue

	// no validation rules for MeanValue

	// no validation rules for PercRank

	// no validation rules for PercValue

	// no validation rules for Uom

	// no validation rules for SDev

	// no validation rules for DeviceMetadata

	// no validation rules for SensorElementId

	if len(errors) > 0 {
		return SensorReportDMultiError(errors)
	}

	return nil
}

// SensorReportDMultiError is an error wrapping multiple validation errors
// returned by SensorReportD.ValidateAll() if the designated constraints
// aren't met.
type SensorReportDMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SensorReportDMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SensorReportDMultiError) AllErrors() []error { return m }

// SensorReportDValidationError is the validation error returned by
// SensorReportD.Validate if the designated constraints aren't met.
type SensorReportDValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SensorReportDValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SensorReportDValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SensorReportDValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SensorReportDValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SensorReportDValidationError) ErrorName() string { return "SensorReportDValidationError" }

// Error satisfies the builtin error interface
func (e SensorReportDValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSensorReportD.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SensorReportDValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SensorReportDValidationError{}

// Validate checks the field values on SensorReportT with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *SensorReportT) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SensorReportT with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in SensorReportTMultiError, or
// nil if none found.
func (m *SensorReportT) ValidateAll() error {
	return m.validate(true)
}

func (m *SensorReportT) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetSensorReportTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, SensorReportTValidationError{
					field:  "SensorReportTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, SensorReportTValidationError{
					field:  "SensorReportTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSensorReportTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return SensorReportTValidationError{
				field:  "SensorReportTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return SensorReportTMultiError(errors)
	}

	return nil
}

// SensorReportTMultiError is an error wrapping multiple validation errors
// returned by SensorReportT.ValidateAll() if the designated constraints
// aren't met.
type SensorReportTMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SensorReportTMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SensorReportTMultiError) AllErrors() []error { return m }

// SensorReportTValidationError is the validation error returned by
// SensorReportT.Validate if the designated constraints aren't met.
type SensorReportTValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SensorReportTValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SensorReportTValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SensorReportTValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SensorReportTValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SensorReportTValidationError) ErrorName() string { return "SensorReportTValidationError" }

// Error satisfies the builtin error interface
func (e SensorReportTValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSensorReportT.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SensorReportTValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SensorReportTValidationError{}
